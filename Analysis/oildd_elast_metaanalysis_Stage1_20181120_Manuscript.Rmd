---
title: Using Meta-Analysis to Estimate World Oil Demand Elasticity
author:
  - name: Rocio Uria-Martinez
    email: uriamartiner@ornl.gov
    affiliation: Oak Ridge National Laboratory
    footnote: Corresponding Author
  - name: Paul N. Leiby
    email: leibypn@ornl.gov
    affiliation: Oak Ridge National Laboratory
  - name: Gbadebo A. Oladosu
    email: oladosuga@ornl.gov
    affiliation: Oak Ridge National Laboratory
  - name: David C. Bowman
    email: econotech@hotmail.com
    affiliation: Econotech
  - name: Megan M. Johnson
    email: johnsonmm@ornl.gov
    affiliation: Oak Ridge National Laboratory  

address:
  - code: Oak Ridge National Laboratory
    address: Energy Analysis Group, One Bethel Valley Road, Oak Ridge, TN, 37831-6036

abstract: Oil demand elasticities are important behavioral parameters for assessing the effectiveness of many energy policy proposals and the economic impact of oil market shocks. Most of the literature on petroleum demand computes elasticities for one particular petroleum product in a country or group of countries. There are fewer published values for world oil demand elasticity because the reduced-form single equation approach used in much of the petroleum product demand literature leads to endogeneity bias when applied to global demand. This study uses meta-analysis techniques to compute world oil demand elasticity. Metaregressions are first conducted to identify sources of variation in elasticity estimates for transportation and non-transportation sectors collected from 75 studies published from 2000 to 2015. The estimated coefficients from the metaregressions are then summarized into elasticity baseline values for several combinations of moderator variable values. Finally, a global oil demand elasticity is computed as the consumption-weighted average of the two sectoral elasticities. Resulting mean values for the short-run oil demand elasticities with respect to price range from -0.7 to -0.14 depending on the attributes selected for the price variable. The long-run range of mean values is much wider (-0.26, -0.83). 

keywords: petroleum demand, elasticity, meta-analysis
  
#bibliography: mybibfile.bib
geometry: margin=2cm
output: pdf_document 

---

<!--_Text based on elsarticle sample manuscript, see [http://www.elsevier.com/author-schemas/latex-instructions#elsarticle](http://www.elsevier.com/author-schemas/latex-instructions#elsarticle)_
-->

<!-- Chunk descriptions
Note: chunk names following "out_*" pattern are simply output chunks to include figures and tables in knitted version of the document
Note: inactive chunks correspond to metaregressions based on 16 elasticity groupings rather than 8
Chunk 1: global_options
Chunk 2: setup (root directory setup)
Chunk 3: loadLibraries (loads all necessary R libraries)
Chunk 4: LoadData (loads allelast dataframe outputted from DataPrep.Rmd script and drops observations not to be included in metaregressions)                
Chunk 5: plotTimeRange (plot showing periods of analysis covered by each paper in the database)
Chunk 6: out_paperperiods
Chunk 7 [Inactive]: g16.MetaAnalysisMeans (computes unweighted, fixed effect and random effects means for each elasticity grouping)
Chunk 8: g8.MetaAnalysisMeans (computes unweighted, fixed effect and random effects means for each elasticity grouping)
Chunk 9: out_forestplot
Chunk 10: CreateVars  (adds columns to allelast dataframe that are needed to construct the moderator variables to be used in metaregressions)
Chunk 11 [Inactive]: g16.Metareg (metaregression analysis: WLS and LME specifications; diagnostic tests)
Chunk 12 [Inactive]: g16.Results.Summary (collects baseline elasticities, standard errors, and other model attributes of interest into a summary table)
Chunk 13 [Inactive]: g16.world_elast (constructs oil demand world price-elasticity as weighted average of the various regions and sectors)
Chunk 14 [Inactive]: g16.IncomeEffects (incorporates income effects to the oil demand price-elasticity)
Chunk 15: g8.Metareg  (metaregression analysis: WLS and LME specifications; diagnostic tests)
Chunk 16: outFunnelPlots
Chunk 17: out.Tables_PSRTransp
Chunk 18: out.Tables_PSROther
Chunk 19: out.Tables_PLRTransp
Chunk 20: out.Tables_PLROther
Chunk 21: out.Tables_YSRTransp
Chunk 22: out.Tables_YSROther
Chunk 23: out.Tables_YLRTransp
Chunk 24: out.Tables_YLROther
Chunk 25: out.tbl.baselines
Chunk 26: g8.world_elast (constructs oil demand world price-elasticity as weighted average of the various sectors)
Chunk 27: g8.IncomeEffects (incorporates income effects to the oil demand price-elasticity)
Chunk 28: outworldelastplot
Chunk 29: WorldElast.compare (comparison plot between short-run world oil demand price elasticity from metaregressions and other published estimates)
Chunk 30: out_elastcompare
-->


```{r loadLibraries, eval=TRUE, include=FALSE}
library(tidyverse)
library(broom)
library(broom.mixed)
library(readxl)
library(scales)
library(grid)
library(gridExtra)
library(stargazer) #to produce nice tables for the results
library(knitr)

library(car) #for computing variance inflation factors to evaluate the extent to which multicollinearity is an issue
library(truncnorm) #for truncated normal distribution
library(lmtest)
library(sandwich)
library(multiwayvcov) #to compute cluster-robust standard errors
library(lme4) #for linear mixed effects estimation
library(ICC) #for computing intraclass correlation coefficients

#library(kableExtra)

#draft("oildd_elast_metaanalysis_Stage1_20170818_Manuscript.Rmd", template = "elsevier_article", package = "rticles")
##https://philmikejones.wordpress.com/2014/05/12/regression-diagnostics-r/
##http://www.theanalysisfactor.com/the-intraclass-correlation-coefficient-in-mixed-models/

## clear: remove (almost) everything in the working environment.
## You will get no warning, so don't do this unless you are sure.
rm(list = ls())
```
WORKING PAPER
==============

<!--
Changes relative to 20170824 version to be submitted for publication:
-Remove "CALC_STERROR" from the metaregression for P_LR_nonOECD_Transp (the symptom that made me go back to revise the specification for that particular metaregression was that the estimated elasticity baseline was ~0 and significantly smaller than the short-run baseline elasticity for the same region-sector combination; the justification to remove that variable is that it was highly correlated -0.71 with StaticP and there is more of a theoretical argument to include StaticP rather than CALC_STERROR). After the change, the estimated baseline for P_LR_nonOECD_Transp becomes -0.18.

-Add OECD dummies to non-transportation price elasticity metaregressions so that I can compute separate OECD and non-OECD baselines out of the g8 metaregressions. For the transportation sector, different OECD/nonOECD baselines are based on evaluating the PRICE.1998.cent variable at the average for OECD and non-OECD countries respectively. For income elasticities, different OECD/nonOECD baselines are based on evaluating the rgdpe_cap.1998.cent variable at the average for OECD and non-OECD countries respectively. [For the transportation sector price elasticities and for the income elasticities, an OECD dummy would be highly correlated with the cross-sectional variables so I don't think it is a good option.]


-->

1. Introduction 
================

Oil demand elasticities are important behavioral parameters for assessing the effectiveness of many energy policy proposals and the economic impact of oil market shocks. Estimation of these parameters became a focus of attention during the oil crises of the 1970s, as the governments of industrialized countries looked for ways to improve energy efficiency and advance energy security, and has remained an active research topic ever since. Elasticities must be periodically re-estimated to incorporate the effects of changes in technology, policy, and market factors.  

With improvements in the availability and quality of energy consumption data (particularly for non-OECD countries) and the development of new econometric methods that enable better analysis of time series and panel data, demand elasticity estimation approaches have changed substantially over time.  Basso and Oum (2007) review the evolution of preferred model specifications for vehicle fuel demand estimation. Static demand equations and partial adjustment models were the most common choices in the 1970s and 1980s. In the 1990s, econometricians introduced error correction and co-integration techniques for the analysis of time-series data and their application in fuel demand elasticity estimation has steadily gained popularity.^[Because researchers are typically interested in measuring demand responsiveness over a specific time period, time-series data have generally been considered more appropriate than cross-sectional data for estimating elasticities. However, oil demand analysis based on cross-sectional data has remained a parallel track. These studies produce long-run elasticities that summarize responses to all price and income conditions experienced by the survey respondents until the data collection period.] Even though the model specifications used to analyze vehicle fuel demand are sometimes applied to studies of other sectors, non-transportation oil demand is often explored with distinct methodologies. For instance, interfuel substitution models are frequently used to estimate oil own-price and cross-price elasticities in the industrial sector and at the household level.  

The vast majority of the literature on petroleum demand computes elasticities for one particular region and/or oil product. There are fewer published values for world oil demand elasticity because estimating it is more difficult. For world oil demand, oil price is not exogenous and the reduced-form single equation approach used in much of the petroleum product demand literature leads to endogeneity bias. Instead, most estimations of world oil demand elasticities are based on systems of equations. Within this group, recent structural vector autoregression (SVAR) models whose results challenge the prevailing view that short-run world oil demand elasticity is very low have garnered much attention. For instance, Kilian and Murphy (2014) find world oil demand elasticities in the range of -0.26 to -0.44 in the first month after a supply shock using 1973-2009 data. Baumeister and Peersman (2013) obtain an average elasticity of -0.26 for that same period, but they allow for time-varying parameters which reveal a substantial steepening of the oil supply and demand curves after the mid-1980s. IMF (2011) employ a different approach to correct for endogeneity bias in their exploration of world oil demand elasticity. Taking advantage of cross-sectional variation in a 45-country data panel, they estimate fixed-effect models of OECD and non-OECD oil demand and average the resulting elasticities, using consumption weights, into a world elasticity of approximately -0.02 from 1990 to 2009.^[The authors of the IMF study contend that any remaining endogeneity bias using their approach should be small because country-specific demand shocks will have little or no effect on the world oil price and common demand shocks are accounted for through inclusion of GDP as one of the explanatory variables.]  

From the three studies referenced in the previous paragraph stems a wide range of world oil demand elasticity estimates. We contribute to the existing literature by constructing a "bottom-up" world elasticity, based on hundreds of estimates from dozens of studies focused on different portions of global oil demand. Several studies explore differences in oil demand responsiveness across uses and/or countries (Dargay and Gately, 2010; Dargay et al., 2007; Dees et al., 2007; IMF, 2011). These studies have agreed in their finding that oil demand elasticities in OECD countries have been higher than in other regions. As for sectors, Dargay et al. (2007) and Dargay and Gately (2010) argue that the OECD has already largely abandoned oil consumption in those uses where fuel switching was easier (e.g., electricity generation, space heating). Both of these studies conclude that world oil demand elasticity should be expected to decrease as the fraction of total oil demand corresponding to more inelastic regions and sectors increases.  

Although other researchers have used metaregressions in surveys of the demand elasticities of gasoline (Espey, 1998; Brons et al., 2008; Havranek et al., 2012; Havranek and Kokes, 2015), industrial oil (Stern, 2009), or multiple energy products (Labandeira et al., 2017), our study is the first that applies this methodology to gain insight on the value of world oil elasticity computed as a weighted average of the price responsiveness of two sectors (transportation and non-transportation). Our choice of moderator variables is driven by the objective of identifying sources of variation that are important to produce adequate elasticity values for specific empirical applications. For instance, a model exploring multi-year period responses to a policy (e.g., international carbon tax) and a model that depicts short-run responses to an oil supply shock require different elasticity inputs. We also pay attention to the relationship between elasticities and cross-sectional differences in price and income levels and add more detail to the interpretation of long-run elasticities.


```{r LoadData, eval = TRUE, include=FALSE}
load(file="../Data/allelast_v1")
load(file="../Data/allelast_v1_NAspeed")

#Convert from tibble to data.frame so that row.names can be reset as needed
allelast <- as.data.frame(allelast)

#Change spelling of references using non-English characters to avoid errors when they are used as input in plots
allelast$REFERENCE[allelast$REFERENCE == "GundimedaK\xf6hlin2008"] <- "GundimedaKohlin2008"

#Drop studies published before year 2000 and implausibly large elasticities
allelast <- subset(allelast, STUDY_YR > 1999 & abs(BETA) < 5)
rownames(allelast) <- seq_len( nrow(allelast))  #reset row.names so that it matches the current length of the allelast dataframe

#Drop observations for which the relevant cross section variables (PRICE.1998 for price elasts or rgdpecap.1998 for income elasts) are NAs
allelast$RoadTransp = ifelse(allelast$PROD_SECT == "Gasoline" |allelast$PROD_SECT == "Diesel" |allelast$PROD_SECT == "Transportation",1,0) 
allelast$OtherSector = ifelse(allelast$PROD_SECT != "Total_oil" & allelast$RoadTransp != 1, 1, 0)

allelast.P.NA <- subset(allelast, TYPE == "P" & RoadTransp == "1" & is.na(PRICE.1998))
allelast.GDP.NA <- subset(allelast, TYPE == "Y" & REGION != "World" & is.na(rgdpe_cap.1998))
  
allelast <- allelast[!rownames(allelast) %in% rownames(allelast.P.NA) &
                     !rownames(allelast) %in% rownames(allelast.GDP.NA) ,]
rownames(allelast) <- seq_len( nrow(allelast))
  
#Construct separate data.frame for estimates that will not be used in the metaregression analysis because they cannot be allocated to OECD-nonOECD regions or Transportation-nonTransportation sectors (most of these are world elasticity estimates) and remove those rows from allelast dataframe
allelast$OECD <- ifelse(allelast$REG == "US"|allelast$REG == "OECD",1,0)
allelast$nonOECD <- ifelse(allelast$REG != "US" & allelast$REG != "OECD" & allelast$REG != "World", 1,0)

allelast.metareg <- subset(allelast, OECD =="1" & RoadTransp =="1"| OECD =="1" & OtherSector == "1"|
                                     nonOECD =="1" & RoadTransp == "1"| nonOECD =="1" & OtherSector == "1")
allelast.excluded <- anti_join(allelast, allelast.metareg, by = c("OECD","nonOECD","RoadTransp","OtherSector"))

allelast <- allelast[rownames(allelast) %in% rownames(allelast.metareg),]
rownames(allelast) <- seq_len( nrow(allelast))

#Drop observations where the length of run is negative (because the estimated coefficient on lagged demand is greater than 1 or the estimated coefficient on the error correction term is positive)
allelast<- subset(allelast, SPEEDYRS >0)
rownames(allelast) <- seq_len( nrow(allelast))

#Drop observations where the standard error was estimated
#allelast <- subset(allelast, CALC_STERROR =="0")
#rownames(allelast) <- seq_len( nrow(allelast))
```

2. Meta-Analysis Database Description
=====================================

We searched for peer-reviewed journal articles and working papers containing primary estimates of oil and petroleum product demand elasticities via queries in Google Scholar and Econlit as well as snowball searches. Since we are primarily interested in elasticities based on recent data, we restricted the search to studies published between 2000 and 2015. We discarded studies that did not provide standard errors or other related information (t-statistic, p-value or confidence intervals) to infer the precision of the elasticity estimates. We excluded estimates with an absolute value outside of (-5,5) interval as well as observations that cannot be assigned to OECD/nonOECD regions or transportation/non-transportation sectors. Finally, we dropped observations for which the value of any of the moderator variables included in the metaregression analysis are not available. The resulting dataset to be used in the metaregression analysis consists of 1983 observations from the 75 papers listed in Appendix A.  

Figure 1 shows the initial and final year of the data period considered in each of the papers in our database. 

``` {r plotTimeRange, eval = TRUE, include=FALSE}
### Explore papers in terms of citation count and range of years covered in data
allelast.TS <- subset(allelast, DATA_TYPE == "TS")
allelast.CSTS <- subset(allelast, DATA_TYPE == "CS-TS")

summstats_reference <- allelast %>%
  group_by(REFERENCE) %>%
  summarise(count = length(CITATIONS), average=round(mean(CITATIONS),3), STUDY_YR=round(mean(STUDY_YR),3),minyrstart=min(YEAR_START), maxyrend=max(YEAR_END),pubdatalag=STUDY_YR-maxyrend, yrlength = maxyrend - minyrstart)
print(summstats_reference)

# Plot showing number of citations of each paper versus publication year
paper.citations <- 
  ggplot(summstats_reference,aes(x=STUDY_YR, y=average)) + 
  geom_point(shape = 16, size=3, colour = "blue") + 
  geom_text(aes(label = REFERENCE),hjust = -0.1, vjust = 0, size = 4) +
  xlim(-5+min(summstats_reference$STUDY_YR),max(summstats_reference$STUDY_YR)+10)+ 
  labs(x="Initial Year", y="Number of citations", title="Citations versus Publication Year") + 
  theme(plot.title=element_text(size=14, face="bold", hjust=0.5)) +
  theme(axis.text.x=element_text(size=10, angle=90, hjust=1),axis.text.y=element_text(size=10), axis.title=element_text(size=12,face="bold")) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
paper.citations
     
     
# Plot showing beginning and end years for each paper
paper.periods <- 
  ggplot(summstats_reference,aes(x=minyrstart, y=maxyrend)) + 
  geom_point(shape = 16, size=3, colour = "blue") + 
  geom_text(aes(label = REFERENCE),hjust = -0.1, vjust = 0, size = 2.5) +
  scale_x_continuous(limits = c(min(summstats_reference$minyrstart),max(summstats_reference$minyrstart)+5), breaks = pretty_breaks(n = 12)) +
  scale_y_continuous(limits = c(min(summstats_reference$maxyrend),max(summstats_reference$maxyrend)), breaks = pretty_breaks(n = 12)) +
  #xlim(min(summstats_reference$minyrstart),max(summstats_reference$maxyrend)+5)+ 
  geom_hline(yintercept=max(summstats_reference$maxyrend),linetype="dashed") +
  geom_vline(xintercept=min(summstats_reference$minyrstart),linetype="dashed") +
  labs(x="Initial Year", y="Final Year", title="") + 
  theme(plot.title=element_text(size=12, face="bold", hjust = 0.5)) +
  theme(axis.text.x=element_text(size=10, angle=65, hjust=1),axis.text.y=element_text(size=10), axis.title=element_text(size=10,face="bold")) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
paper.periods 
ggsave("../Output/paper.periods.png", width=6.5, height=4.5, units="in", dpi=600)
```
```{r out_paperperiods, echo = FALSE, warning =FALSE, message=FALSE }
paper.periods
```

**Figure 1. Periods of analysis in studies included in elasticity meta-analysis database**

Even though 40 of the 75 papers in the database were published after 2009, only 12 contain data for 2010 or later. The average lag between publication year and end of analysis period is approximately 5 years. Studies based on time series data tend to analyze longer periods and result in an average elasticities that might be less representative of recent conditions than those from studies using more recent data panels.^[The average length of data period covered by papers in our database using time series and panel data is 28 and 17 years respectively.] The average years in this database are 1989, 1994, and 2004 for subsets of studies using time series, panel, and cross-sectional data respectively.

Beyond the usual segmentations by type (price or income) and length of run (short or long run), we also segment the database by sector (transportation or non-transportation) because the data sources and estimation methods used for generating these two elasticities tend to be different.^[Gasoline or diesel demand elasticities were assigned to the transportation sector unless the study mentioned explicitly that its consumption data corresponded to a different sector. Elasticities in the non-transportation category include elasticities for petroleum demand in the industrial sector, residential sector (for uses other than transportation) or petroleum products used in those sectors (industrial use of diesel and gas oil, fuel oil, kerosene, liquefied petroleum gas, residual fuel oil, other petroleum products). Even though aviation is a transportation activity, jet fuel demand were assigned to the non-transportation category.] Segmentation by sector also enables a more tailored selection of moderator variables for the metaregression. We considered further segmenting the data by region (OECD versus non-OECD) but some of the resulting 16 groupings contained few observations making the validity of a metaregression analysis approach questionable. Instead, to control for regional differences, we include regional dummies and cross-sections of price and income levels as moderator variables in the metaregressions.

Accounting for response period is important when comparing elasticity estimates across studies. All else equal, demand responsiveness is expected to increase with the period over which the response is measured. We consider short-run elasticities as those that convey a first-period response: one year, one quarter, or one month depending on the data frequency used in each study. In addition, whenever possible, we assign long-run estimates a specific response length (in years). Dynamic demand specifications typically include a variable (lagged demand for partial adjustement models or error correction term in error correction models) whose estimated coefficient can be used to estimate the length of run implied by the long-run elasticities.^[Balcombe et al. (2004) show that the number of periods to achieve 90% of the long-run elasticity estimated using and ARDL specification can be calculated as $ln(1-0.9)/ln(\theta)$. $\theta$ is the estimated coefficient on lagged demand if the model specification is a partial adjustment model; for error correction models the formula is $ln(1-0.9)/ln(\theta)+1$] To our knowledge, this is the first meta-analysis that extracts this more detailed information on length of run from long-run elasticities. We classified most of the elasticities from cross sectional studies as long-run and assign them a length of run in years equal to the average adjustment period for long-run elasticities in the same grouping (i.e., type-sector combination).^[The only cross-sectional elasticities classified as short-run come from 3 studies that used data from household surveys where the same household is interviewed multiple times at intervals equal or less than one year (e.g., Frondel et al.,(2008)). Alternatively, data from these studies could have been categorized as a (very unbalanced) panel.]

As an initial exploratory step, Figure 2 displays unweighted means alongside the fixed effect and random effects means typically computed in meta-analyses, for the 8 elasticity groupings being analyzed: 2 types (price and income) times 2 lengths of run (short and long) times two sectors (transportation and non-transportation). Fixed effect means are appropriate when all elasticities in a given group originate from the same population and the only reason why they differ is sampling error. In that case, estimates with lowest standard errors should be weighted more heavily and vice versa. On the other hand, random effects means assume that variability in a given set of elasticities is partly due to inherent differences in the true effect sizes (e.g., the true population mean is different across countries, over time and/or based on other attributes). The weights applied to random effects mean include an extra component to account for between-estimate variation (Borenstein et al., 2009). As in most social sciences applications of meta-analysis, the random effects model seems most appropriate to describe our dataset.



```{r g8.MetaAnalysisMeans, eval = TRUE, include = FALSE}
#Compute unweighted mean and fixed and random means for the 16 subsets of observations for which metaregressions will be conducted
# Create a variable that combines the attributes by which we choose to segment the dataset elasticity type, length of run, and regional attributes
allelast <- mutate(allelast, Type_Sector = as.factor(paste(TYPE_LENGTH2, RoadTransp, OtherSector, sep = "_")))
#allelast <- subset(allelast, CALC_STERROR =="0")

#Unweighted, fixed effect, and random effects means for each of the subset of elasticities to be used in the metaregressions
#-----------------------------------------------------------------------------------------------------------------------------
#Note: changing the grouping factor to TYPE_LENGTH2 or a combination of TYPE_LENGTH2 and sector would be used to investigate the means for g4 or g8 groupings respectively

##Unweighted means
g8.avg_ALL <- allelast %>%
  group_by(Type_Sector) %>% 
  summarise(unweighted_mean = mean(BETA), n.obs = length(BETA))

## Fixed effect means and associated 95% confidence intervals (following Chapter 11 in Borenstein et al. 2009)
allelast$weights.FE <- 1/((allelast$ST_ERROR)**2) ##fixed effect weights
g8.FE_avg_ALL <- allelast %>%
  group_by(Type_Sector) %>%
  summarise(numerator = round(sum(BETA*weights.FE), 4),
            denominator = round(sum(weights.FE), 4),
            mean = round(numerator/denominator,4),
##The variance of the summary effect is estimated as the reciprocal of the sum of weights
            se = round(sqrt(1/denominator),4),
            n.obs = length(BETA),
            lo.CI95 = round(mean-(1.96*se),4),
            up.CI95 = round(mean+(1.96*se),4))
g8.FE_avg_ALL$Type <- "Fixed Effect Means"


## Random effects means (following Chapter 12 in Borenstein et al. 2009)
### Compute between-estimates variance
g8.interstudy_var <- allelast %>%
  group_by(Type_Sector) %>%
  ###Q is the total amount of study-to-study variation actually observed (where each observation is interepreted as an independent study)
  summarise(Q = sum(BETA*BETA*(weights.FE))-(sum(BETA*(weights.FE)*sum(BETA*(weights.FE)))/sum(weights.FE)),
            C = sum(weights.FE) -(sum((weights.FE)*(weights.FE))/sum((weights.FE))),
            df = length(BETA)-1,
  ###Q-df indicates how much the observed effects would be expected to vary from each other if the true effect was actually the same in all studies. The excess variation is assumed to reflect real differences in effect size
            tau = (Q-df)/C,
  ###I2 can be interpreted as the proportion of the observed variance that reflects real heterogeneity in effect size
            I2 =(Q-df)/Q) 
 ###Large I2 implies large effect size heterogeneity and can be used as justification for metaregression analysis as a way to explain the heterogeneity

### Assign appropriate between-estimates variance to each observation
for(i in levels(allelast$Type_Sector))
    {allelast$g8.tau[allelast$Type_Sector == i] = g8.interstudy_var$tau[g8.interstudy_var$Type_Sector == i]}
### Compute random effects weights
allelast$g8.weights.RE <- 1/((allelast$ST_ERROR)**2 + allelast$g8.tau)
allelast$g8.tau.frac <- allelast$g8.tau/allelast$g8.weights.RE
### Compute random effects means and associated 95% confidence intervals
g8.RE_avg_ALL <- allelast %>% 
  group_by(Type_Sector) %>% 
  summarise(numerator = round(sum(BETA*g8.weights.RE), 4),
            denominator = round(sum(g8.weights.RE), 4),
            mean = round(numerator/denominator,4),
            tau.frac.summ = round(mean(g8.tau.frac),4),      
##The variance of the summary effect is estimated as the reciprocal of the sum of weights
            se = round(sqrt(1/denominator),4),
            n.obs = length(BETA),
            lo.CI95 = round(mean-(1.96*se),4),
            up.CI95 = round(mean+(1.96*se),4))
g8.RE_avg_ALL$Type <- "Random Effects Means"


#Combine raw, fixed effect and random effects means and standard errors into a single data.frame
g8.avg.summary <- rbind(g8.FE_avg_ALL, g8.RE_avg_ALL[,c("Type_Sector","Type","numerator","denominator","mean","se","n.obs","lo.CI95","up.CI95")])
g8.avg.summary <- g8.avg.summary[,c("Type_Sector","Type","n.obs", "mean", "se", "lo.CI95", "up.CI95")]

Type_Sector <- c("P_SR_1_0", "P_SR_0_1", "P_LR_1_0", "P_LR_0_1", "Y_SR_1_0", "Y_SR_0_1", "Y_LR_1_0", "Y_LR_0_1")
g8.ElastID <- c("ShortRun-\nTransportation", "ShortRun-\nnonTransportation", "LongRun-\nTransportation", "LongRun-\nnonTransportation",
             "ShortRun-\nTransportation", "ShortRun-\nnonTransportation", "LongRun-\nTransportation", "LongRun-\nnonTransportation")
g8.ElastIDmatch <- data.frame(Type_Sector, g8.ElastID)
g8.avg.summary <- merge(g8.avg.summary, g8.ElastIDmatch, by=c("Type_Sector"))
g8.avg.summary <- merge(g8.avg.summary, g8.avg_ALL[,c("Type_Sector","unweighted_mean")], by=c("Type_Sector"))
g8.avg.summary$g8.ElastID <- as.factor(g8.avg.summary$g8.ElastID)

print(g8.avg.summary)

#Forest plots
g8.avg.summary$Length_Run <- as.factor(substr(g8.avg.summary$Type_Sector, 3,4))
g8.avg.summary$Elast_Type <- ifelse(substr(g8.avg.summary$Type_Sector, 1,1) =="P", "Price", "Income")

g8.forest.plot <- 
  ggplot(g8.avg.summary,aes(x=mean,y=g8.ElastID))+
        geom_point(aes(fill = Elast_Type, shape = Length_Run, color = Elast_Type), size = 2)+
        geom_point(aes(x=unweighted_mean,y=g8.ElastID), colour="black", size = 2)+
        geom_errorbarh(aes(xmin=lo.CI95,xmax=up.CI95),height=0.667)+
        geom_vline(xintercept=0,linetype="dashed")+
        xlim(-1,1) +
        facet_wrap(~Type, ncol=1) +
        scale_shape_manual(values = c(22,21)) + 
        scale_fill_manual(values = c("orange","turquoise")) + 
        scale_color_manual(values = c("orange","turquoise")) + 
        labs(x="Elasticity", y="Category", title = "",hjust=0.5, fill="Elasticity \nType", color="Elasticity \nType", shape="Length \nof \nRun")+ 
        theme(axis.text.x=element_text(size=10),axis.text.y=element_text(size=10),axis.title=element_text(size=11)) +
        theme(plot.title=element_text(size=11, face="bold"))+
        theme(legend.text=element_text(size=10), legend.title=element_text(size=10), legend.key=element_blank(), 
              legend.position="right") +
        theme(panel.grid.major.x = element_line(colour = "grey"), panel.grid.minor.x = element_line(colour = "grey"), panel.background = element_blank(), 
              axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1)) 
g8.forest.plot
ggsave("../Output/g8.forest.plot.png", width=6.5, height=4.5, units="in", dpi=600)

#Plot elasticity values against their standard errors
elastsubset <- subset(allelast, TYPE_LENGTH2 == "Y_LR" & RoadTransp == "0")
elastsubset.plot <- ggplot(elastsubset, aes(x=BETA, y=ST_ERROR, color= as.factor(CALC_STERROR))) + 
  geom_point(size = 1) +
  ylim(0,1)+
#  facet_wrap(~Metric, ncol = 1) +
#  scale_color_manual(values = c("red","black","blue","orange","turquoise")) + 
#  scale_shape_manual(values = shape.set11) + 
  labs(x="Elasticity", y="Variance", title="") +  
  theme(strip.text.x = element_text(size = 12)) + 
  theme(plot.title=element_text(size=12, face="bold", hjust=0.5)) +
  theme(axis.text.x=element_text(size=10, angle=65, hjust=1),axis.text.y=element_text(size=10), axis.title=element_text(size=10,face="bold")) +
  theme(legend.text=element_text(size=10), legend.title=element_text(size=10, face="bold"), legend.key=element_blank(), legend.position="right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
elastsubset.plot 

```

```{r out_forestplot, echo = FALSE, warning =FALSE, message=FALSE }
g8.forest.plot
```
Note: Black dots correspond to the unweighted means.  

**Figure 2. Forest plot of demand elasticities with respect to price and income**

All weighted and unweighted means are less than one in absolute value (i.e., inelastic). For both types of elasticity and both lengths of run, the unweighted average elasticities are greater for the transportation sector than for other sectors. The same result is true for the random effects means but not for the long-run fixed effect means. For all elasticity groupings except long-run non-transportation, the random effects mean is an intermediate value between the unweighted and fixed effect means. This result is consistent with a data set where the smaller effect sizes (elasticities in this case) are the most precisely measured. For long-run, nontransportation elasticities, fixed effect means are the largest. This result indicates that the relationship between effect size and precision of the estimate is weaker for that elasticity grouping.   


```{r CreateVars, eval = TRUE, include=FALSE}
##Brent price source: http://www.eia.gov/dnav/pet/pet_pri_spt_s1_a.htm
Brentp.1998 = 12.76/159  #Average crude oil price for 1998 (in $/liter)

allelast <- mutate(allelast, 
           Ones = 1, #(to be used for inspecting correlation across explanatory variables)
           YrLength = YEAR_END - YEAR_START, #Analysis period length (Years)
           INV_SPEEDYRS = 1/SPEEDYRS, #transformation to reflect non-linear elasticity increase with length of run
#Data Region variables
           World = ifelse(REG == "World", 1,0), #World
           NETEXP = ifelse(EXPCONS.ratio > 0, 1,0), #Net Importer/Exporter
#Data Product/Sector variables
           DslTransp = ifelse(PROD_SECT == "Diesel", 1,0), #Diesel
           ElecGen = ifelse(PROD_SECT == "ElecGen", 1,0),  #Electricity Generation
           Residential = ifelse(PROD_SECT == "Residential", 1, 0 ), #Residential  
           FuelSwitch = ifelse(Residential == 1| ElecGen ==1, 1,0), #Fuel Switching (as in Dargay&Gately2010)
           Industrial = ifelse(PROD_SECT == "Industrial",1,0), #Industrial
#Data Frequency variables
           Annual = ifelse(FREQUENCY =="annual"|FREQUENCY =="biennial",1,0), #Annual
           Quarterly = ifelse(FREQUENCY =="quarterly",1,0), #Quarterly
           Monthly = ifelse(FREQUENCY =="monthly",1,0), #Data Monthly
#Data Type variables
           TS = ifelse(DATA_TYPE =="TS",1,0), #Time Series
           CSTS = ifelse(DATA_TYPE =="CS-TS",1,0), #Panel data
           CS = ifelse(DATA_TYPE =="CS"|DATA_TYPE =="CS "|DATA_TYPE =="CS-TS (mostly CS)",1,0), #Cross Sectional
           Logarithmic = ifelse(LOGS == "1", 1,0), #Logarithmic
           PerCapita = ifelse(PER_CAPITA =="1", 1,0), #PerCapita variables
#Price Elasticity Characteristics (only relevant for price elasticities)
           EndUserP = ifelse(PRICE_POINT =="1", 1,0), #End-user Price 
           Pmax = ifelse(substr(VAR_SYMBOL, 1, 4) =="Pmax",1,0), #Price Component_ Pmax
           Pcut = ifelse(substr(VAR_SYMBOL, 1, 4) =="Pcut",1,0), #Price Component_ Pcut 
           Prec = ifelse(substr(VAR_SYMBOL, 1, 4) =="Prec",1,0), #Price Component_ Precovery 
           Psubmax = ifelse(substr(VAR_SYMBOL, 1, 4) =="Psub",1,0), #Price Component_ Psubmax
#Income Elasticity Characteristics (only relevant for income elasticities)
           Ymax = ifelse(substr(VAR_SYMBOL, 1, 4) =="Ymax",1,0), #Income Component_ Ymax 
           Ycut = ifelse(substr(VAR_SYMBOL, 1, 4) =="Ycut",1,0), #Income Component_ Ycut 
           Yrec = ifelse(substr(VAR_SYMBOL, 1, 4) =="Yrec",1,0), #Income Component_ Yrec
#Model Specification variables
           DynamicP = ifelse(P_DYNAMIC == "1", 1, 0), #DynamicP
           StaticP = ifelse(P_DYNAMIC == "0", 1, 0), #StaticP
           DynamicY = ifelse(Y_DYNAMIC == "1", 1, 0), #DynamicY
           StaticY = ifelse(Y_DYNAMIC == "0", 1, 0), #StaticY
           ARDL = ifelse(MODEL_TYPE2 == "ARDL", 1, 0), #ARDL model family
           Coint = ifelse(MODEL_TYPE2 == "cointegration", 1, 0), #Cointegration model
           FlexForm = ifelse(MODEL_TYPE2 == "flex_form", 1, 0), #Flexible Functional Form
           SysEq = ifelse(MODEL_TYPE2 == "system", 1,0), #System of Equations
           GenEQ = ifelse(MODEL_TYPE2 == "DSGE" | MODEL_TYPE2 == "SVAR", 1, 0), #General Equilibrium 
           nonARDLcomb = ifelse(MODEL_TYPE2 =="ARDL"| MODEL_TYPE2 =="cointegration"| 
                                MODEL_TYPE2 =="linear_static", 0, 1), #not from ARDL model family 
           OtherLagsP = ifelse(P_LAGS =="1",1,0), #Additional Lags P
           OtherLagsY = ifelse(Y_LAGS =="1",1,0), #Additional Lags Y
           Psubst = ifelse(grepl("price_substitutes", OTH_VAR_CAT), 1, 0), #model w/ price of substitutes regressor
           VehStk = ifelse(grepl("vehicle_stock", OTH_VAR_CAT), 1, 0), #model w/ vehicle stock regressor

           PRICE.1998.cent = PRICE.1998 - Brentp.1998, #normalize Price cross section to be 0 for the Brent price level
           VARIANCE = ST_ERROR * ST_ERROR,
           PRECISION = 1/abs(ST_ERROR),
           TSTAT = BETA/ST_ERROR,
           SQ.NOBS = sqrt(N_SIZE),
#Interaction variables
           StaticP.CS = StaticP * CS,
           StaticY.CS = StaticY * CS
           
)


##Centering continuous variables to avoid extremely large estimated intercepts and to give the estimated intercept a meaningful interpretation.
for(i in 1: nrow(allelast)){
##YrAvg
allelast$YrAvg.avg[i] <-  mean(allelast$AVGYR
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$OECD == allelast$OECD[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i]]
                               )
allelast$YrAvg.cent[i] <- allelast$AVGYR[i]- allelast$YrAvg.avg[i]
##SPEEDYRS (only matters for long-run elasticities because this moderator variable only enters the long-run metaregressions)
allelast$SPEEDYRS.avg[i] <-  mean(allelast$SPEEDYRS
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$OECD == allelast$OECD[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i] &
                              allelast$CS == "0" ]
                               )
allelast$SPEEDYRS.cent[i] <- ifelse(allelast$CS[i] == "0", allelast$SPEEDYRS[i]- allelast$SPEEDYRS.avg[i], allelast$SPEEDYRS.avg[i])
                                  

##rgdpecap.1998
allelast$rgdpe_cap.1998.avg[i] <-  mean(allelast$rgdpe_cap.1998
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$OECD == allelast$OECD[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i]]
                               )
allelast$rgdpe_cap.1998.cent[i] <- allelast$rgdpe_cap.1998[i]- allelast$rgdpe_cap.1998.avg[i]


##PRICE1998
# allelast$PRICE.1998.avg[i] <-  mean(allelast$PRICE.1998
#                              [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
#                               allelast$OECD == allelast$OECD[i] & 
#                               allelast$RoadTransp == allelast$RoadTransp[i]]
#                                )
# allelast$PRICE.1998.cent[i] <- allelast$PRICE.1998[i]- allelast$PRICE.1998.avg[i]
}

#Repeat the process for g8 groupings
for(i in 1: nrow(allelast)){
##YrAvg
allelast$g8.YrAvg.avg[i] <-  mean(allelast$AVGYR
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i]]
                               )
allelast$g8.YrAvg.cent[i] <- allelast$AVGYR[i]- allelast$g8.YrAvg.avg[i]
##SPEEDYRS (only matters for long-run elasticities because this moderator variable only enters the short-run metaregressions)
allelast$g8.SPEEDYRS.avg[i] <-  mean(allelast$SPEEDYRS
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i] &
                              allelast$CS == "0"]
                               )
allelast$g8.SPEEDYRS.cent[i] <- ifelse(allelast$CS[i] == "0",allelast$SPEEDYRS[i]- allelast$g8.SPEEDYRS.avg[i],allelast$g8.SPEEDYRS.avg[i])
##rgdpecap.1998
allelast$g8.rgdpe_cap.1998.avg[i] <-  mean(allelast$rgdpe_cap.1998
                             [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] & 
                              allelast$RoadTransp == allelast$RoadTransp[i]]
                               )
allelast$g8.rgdpe_cap.1998.cent[i] <- allelast$rgdpe_cap.1998[i]- allelast$g8.rgdpe_cap.1998.avg[i]

##PRICE1998
# allelast$g8.PRICE.1998.avg[i] <-  mean(allelast$PRICE.1998
#                              [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] &
#                               allelast$RoadTransp == allelast$RoadTransp[i]]
#                                )
# allelast$g8.PRICE.1998.cent[i] <- allelast$PRICE.1998[i]- allelast$g8.PRICE.1998.avg[i]
}

```


```{r g8.Metareg, eval = TRUE, include = FALSE}

g8.selectorVarList = c("TYPE_LENGTH2", "RoadTransp", "OtherSector")
g8.selectorSets = rbind( 
                c("P_SR","1","0"),
                c("P_LR","1","0"),
                c("Y_SR","1","0"),
                c("Y_LR","1","0"),
                c("P_SR","0","1"),
                c("P_LR","0","1"),
                c("Y_SR","0","1"),
                c("Y_LR","0","1")
                )

printf <- function(...) invisible(print(sprintf(...))) # formatted printing

# given selection values in passed array sv, construct a string for the subset argument in the estimation command 
g8.selectorSubsetString <- function(g8.sv=c("P_SR","1","0")) {
  return(paste0("TYPE_LENGTH2 ==",g8.sv[1],"&",
                "RoadTransp   ==",g8.sv[2],"&",
                "OtherSector  ==",g8.sv[3]))
}

# given selection values in passed array sv, construct a logical vector to select (subset) desired observations from the dataset 
g8.selectorLogicalVec <- function(g8.sv=c("P_SR","1","0")) {
  return(allelast$TYPE_LENGTH2 == g8.sv[1] &
         allelast$RoadTransp   == g8.sv[2] &
         allelast$OtherSector  == g8.sv[3])
}

g8.selectorLogicalVecs = matrix(ncol=nrow(g8.selectorSets), nrow=nrow(allelast))
for (i in 1:nrow(g8.selectorSets)) {
  g8.selectorLogicalVecs[,i] = g8.selectorLogicalVec(g8.selectorSets[i,])
}


#Select moderator variable sets
Specification = 7
    all_varList_P_SR.Transp =    c("g8.YrAvg.cent","Quarterly","Monthly","CSTS","Pmax","OECD","StaticP","StaticP.CS","PRICE.1998.cent","DslTransp","VehStk","VARIANCE","CALC_STERROR")
    all_varList_P_LR.Transp =    c("g8.YrAvg.cent","g8.SPEEDYRS.cent","CS","CSTS","Pmax","OECD","StaticP","PRICE.1998.cent","DslTransp","VehStk","VARIANCE","CALC_STERROR")
    all_varList_P_SR.nonTransp = c("g8.YrAvg.cent","Quarterly","Monthly","CSTS","OECD","Pmax","StaticP","StaticP.CS","EndUserP","FuelSwitch","VARIANCE","CALC_STERROR")
    all_varList_P_LR.nonTransp = c("g8.YrAvg.cent","g8.SPEEDYRS.cent","CSTS","OECD","Pmax","EndUserP","VARIANCE","CALC_STERROR")
    all_varList_Y_SR.Transp =    c("g8.YrAvg.cent","Monthly","CSTS","Ymax","StaticY","StaticY.CS","g8.rgdpe_cap.1998.cent","DslTransp","VehStk","VARIANCE","CALC_STERROR")
    all_varList_Y_LR.Transp =    c("g8.YrAvg.cent","g8.SPEEDYRS.cent","CSTS","Ymax","g8.rgdpe_cap.1998.cent","DslTransp","VehStk","VARIANCE","CALC_STERROR")
    all_varList_Y_SR.nonTransp = c("g8.YrAvg.cent","Quarterly","Monthly","CSTS","Ymax","StaticY","StaticY.CS","g8.rgdpe_cap.1998.cent","FuelSwitch","VARIANCE","CALC_STERROR")
    all_varList_Y_LR.nonTransp = c("g8.YrAvg.cent","g8.SPEEDYRS.cent","CSTS","Ymax","g8.rgdpe_cap.1998.cent","CALC_STERROR")
    
#Create lists to store elements/results of interest from each metaregression

# Store intraclass correlation coefficients for effect sizes
g8.ICC.all = list()
g8.ICC.all2 = list()

# Store results from publication bias test
g8.pubbias.test = list()

# Store data subsets used for final set of metaregressions
g8.obsSel2 = list()

## (WLS) weighted least squares estimation
g8.modelsEstimated = list()    #saves results from WLS metaregressions  
g8.modelsEstimated2 = list()   #saves tidy results from WLS metaregressions (post outlier analysis)
g8.modelsEstimated2.raw = list()   #saves untidy results from WLS metaregressions (post outlier analysis)
g8.WLS.elastID = list()    #saves elasticity type-regions-sector ID for WLS metaregressions
g8.coeffsEstimated = list()    #saves estimated coefficients with their cluster-robust standard errors
g8.coeffsEstimated2 = list()   #saves estimated coefficients with their cluster-robust standard errors (post outlier analysis)
g8.vifEstimated = list()       #saves variance inflation factors associated to WLS metaregressions
g8.vifEstimated2 = list()      #saves variance inflation factors associated to WLS metaregressions (post outlier analysis) 
g8.ICC_resid.all = list()      #saves intraclass coefficients for WLS residuals
g8.ICC_resid.all2 = list()     #saves intraclass coefficients for WLS residuals (post outlier analysis)

## (LME)linear mixed effects estimation
g8.modelsEstimated.LME = list() #saves results from LME metaregressions
g8.modelsEstimated2.LME = list() #saves tidy results from LME metaregressions (post outlier analysis)
g8.modelsEstimated2.LME.raw = list() #saves untidy results from LME metaregressions (post outlier analysis)
g8.LME.elastID = list() #saves elasticity type-regions-sector ID for LME metaregressions

## Likelihood ratio tests to select WLS or LME as a preferred model specification 
g8.LRT = list()

## (OLS)estimation (only to be used post-outlier analysis with Huber-White standard errors as an alternative to the use of precision-based weights in addressing heteroskedasticity; this specification would not include VARIANCE as a moderator variable either so it would not be correcting for publication bias)
g8.modelsEstimated2.OLS = list() #saves results from OLD metaregressions
g8.coeffsEstimated2.OLS = list() #saves estimated coefficients with their heteroskedasticity-consistent standard errors (post outlier analysis)
g8.modelsEstimated2.OLS.raw = list() #saves untidy results from LME metaregressions (post outlier analysis)
g8.OLS.elastID = list() #saves elasticity type-regions-sector ID for OLS metaregressions

## Baselines elasticities
g8.baseline.comps = list()  # saves components needed to compute baseline (WLS and LME, post outlier analysis)
g8.baselinesEstimated = list()  # saves baseline elasticities and other results (WLS and LME, post outlier analysis)    
    

for (i in 1:nrow(g8.selectorSets)) {
  #for (i in 1:1) {
  print(i)
 
  g8.curr_varList = ifelse(substr(g8.selectorSets[i,1], 1, 4)=="P_SR" & g8.selectorSets[i,2] == "1" & g8.selectorSets[i,3] == "0", list(all_varList_P_SR.Transp),
                     ifelse(substr(g8.selectorSets[i,1], 1, 4)=="P_SR" & g8.selectorSets[i,2] == "0" & g8.selectorSets[i,3] == "1", list(all_varList_P_SR.nonTransp),
                      ifelse(substr(g8.selectorSets[i,1], 1, 4)=="P_LR" & g8.selectorSets[i,2] == "1" & g8.selectorSets[i,3] == "0", list(all_varList_P_LR.Transp),
                       ifelse(substr(g8.selectorSets[i,1], 1, 4)=="P_LR" & g8.selectorSets[i,2] == "0" & g8.selectorSets[i,3] == "1", list(all_varList_P_LR.nonTransp),
                        ifelse(substr(g8.selectorSets[i,1], 1, 4)=="Y_SR" & g8.selectorSets[i,2] == "1" & g8.selectorSets[i,3] == "0", list(all_varList_Y_SR.Transp),
                         ifelse(substr(g8.selectorSets[i,1], 1, 4)=="Y_SR" & g8.selectorSets[i,2] == "0" & g8.selectorSets[i,3] == "1", list(all_varList_Y_SR.nonTransp),
                          ifelse(substr(g8.selectorSets[i,1], 1, 4)=="Y_LR" & g8.selectorSets[i,2] == "1" & g8.selectorSets[i,3] == "0", list(all_varList_Y_LR.Transp),
                           ifelse(substr(g8.selectorSets[i,1], 1, 4)=="Y_LR" & g8.selectorSets[i,2] == "0" & g8.selectorSets[i,3] == "1", list(all_varList_Y_LR.nonTransp), NA
                     ))))))))
                       
                         
  g8.curr_varList = c(do.call("cbind", g8.curr_varList))
  g8.curr_obsSel = g8.selectorLogicalVec(g8.selectorSets[i,])  # logical vec for selection of desired observations
  
  #Create a second list of variables that excludes VARIANCE in order to compute number of "unique" observations providing added information to the metaregression
  g8.curr_varList_minusVARIANCE <- g8.curr_varList[g8.curr_varList != "VARIANCE"]

  printf("Subset selection: %s", g8.selectorSubsetString(g8.selectorSets[i,]))

# Drop variables for which there is no variability within the set of observations g8.curr_obsSel
  g8.mydf<-matrix(0,1,length(g8.curr_varList))
    colnames(g8.mydf) <- g8.curr_varList
    for(j in 1:length(g8.curr_varList)){
    g8.mydf[1,j] = max(allelast[g8.curr_obsSel,g8.curr_varList[j]]) - min(allelast[g8.curr_obsSel,g8.curr_varList[j]])
      }
    g8.curr_varList = g8.curr_varList[g8.mydf[1,]!=0] 
  printf("Variables: %s", g8.curr_varList)
  
  g8.curr_formula = paste("BETA",paste(g8.curr_varList, collapse="+"),sep="~") 
  printf("Formula estimated: %s",g8.curr_formula)
  g8.curr_formula.lme = paste(paste("BETA",paste(g8.curr_varList, collapse="+"),sep="~"),"(1|REFERENCE)", sep = "+")
  print(summary(allelast[g8.curr_obsSel,c("BETA",g8.curr_varList)])) # review dataset for this regression
  g8.curr_formula.ols = paste("BETA",paste(g8.curr_varList[g8.curr_varList != "VARIANCE" & g8.curr_varList != "CALC_STERROR"], collapse="+"),sep="~")
  
  g8.curr_cor = round(cor(allelast[g8.curr_obsSel,c("BETA","Ones", g8.curr_varList)], use = "pairwise.complete.obs", method = "spearman"),2)
  print(g8.curr_cor)

  ## Compute intraclass correlation coefficient
  g8.curr_elast.by.REF <- allelast[g8.curr_obsSel,c("REFERENCE","BETA")]
  g8.curr_ICC <- ICCest(REFERENCE, BETA, g8.curr_elast.by.REF, alpha = 0.05, CI.type = c("THD"))
  g8.ICC.all[[i]] = g8.curr_ICC
  
  
  g8.curr_model <- lm( formula=g8.curr_formula, data=allelast,
                              subset=g8.curr_obsSel,
                              weights = PRECISION)
  # compute clustered standard errors using REFERENCE as the clustering variable
  g8.clust.vcov <- cluster.vcov(g8.curr_model, subset(allelast, g8.curr_obsSel)$REFERENCE)
  #g8.clust.vcov <- coef_test(g8.curr_model, vcov="CR1", cluster = unlist(subset(allelast, g8.curr_obsSel)$REFERENCE), test = "Satterthwaite")
  
#Note: The weights need to be normalized to facilitate comparison of the residual standard error from the various metaregressions
#http://stats.stackexchange.com/questions/73966/in-weighted-least-squares-how-do-i-weight-the-residuals-to-get-an-accurate-z-s
  g8.subsetString <- g8.selectorSubsetString(g8.selectorSets[i,])
  g8.subsetString2<- paste(g8.selectorSets[i,1],g8.selectorSets[i,2],g8.selectorSets[i,3], sep = "_")
  printf("Subset selection: %s", g8.selectorSubsetString(g8.selectorSets[i,]))
  printf("Formula estimated: %s",g8.curr_formula)
  #print output from lm regression
  print(summary(g8.curr_model, robust = F))
  #print coefficient tests using the clustered standard errors
  print(coeftest(g8.curr_model, g8.clust.vcov))

  # Plot residuals
  #plot(g8.curr_model$residuals)
  # Plot observed values versus fitted values
  #plot(subset(allelast, g8.curr_obsSel)$BETA, g8.curr_model$fitted.values)
  #abline(0,1)
  
  ## Compute intraclass correlation coefficient of the residuals
    g8.curr_resid.by.REF <- cbind(g8.curr_elast.by.REF, g8.curr_model$residuals)
    g8.curr_resid.by.REF$RESIDUAL = g8.curr_resid.by.REF[,3]
    g8.curr_resid_ICC <- ICCest(REFERENCE, RESIDUAL, g8.curr_resid.by.REF, alpha = 0.05, CI.type = c("THD"))
    g8.ICC_resid.all[[i]] = g8.curr_resid_ICC
  
  # if needed, re-do analysis dropping vars for which coeff is "NA"
  if (NA %in% coefficients(g8.curr_model)) {
    g8.curr_varList = g8.curr_varList[!is.na(coefficients(g8.curr_model)[-1])]   # drop first coefficient (for constant) from coefficient list
    g8.curr_formula = paste("BETA",paste(g8.curr_varList, collapse="+"),sep="~")  # construct text string for formula (apparently required)
    g8.curr_model <- lm( formula=g8.curr_formula, data=allelast, 
                              subset=g8.curr_obsSel,
                              weights = PRECISION)
    
    # compute clustered standard errors using REFERENCE as the clustering variable
    g8.clust.vcov <- cluster.vcov(g8.curr_model, subset(allelast, g8.curr_obsSel)$REFERENCE)
    #g8.clust.vcov <- coef_test(g8.curr_model, vcov = "CR2", cluster = subset(allelast, g8.curr_obsSel)$REFERENCE, test = "Satterthwaite")
                              
    printf("Subset selection: %s", g8.selectorSubsetString(g8.selectorSets[i,]))
    printf("Formula estimated: %s",g8.curr_formula)
      } 
  else(varinflation = vif(g8.curr_model))
  print(varinflation)

  g8.modelsEstimated[[i]] = g8.curr_model
  
# Outlier analysis based on http://polisci.msu.edu/jacoby/icpsr/regress3/lectures/week3/11.Outliers.pdf (see, especially, slide 33)
  plot(hatvalues(g8.curr_model), rstudent(g8.curr_model), type ="n",
       main = "Influence Plot", xlab = "Hat Values", ylab = "Studentized Residuals")
  cook <- sqrt(cooks.distance(g8.curr_model))
  points(hatvalues(g8.curr_model), rstudent(g8.curr_model), cex = 10*cook/max(cook))
  leverage_threshold = 3*((length(g8.curr_model$coefficients)+1)/length(g8.curr_model$fitted.values))
  abline (v = leverage_threshold , lty = 2) # line for hatvalues
  abline(h = c(-2,0,2),lty = 2) # lines for standardized residuals
 # Identify the outliers (we classify as outliers those obs whose studentized residuals are outside of the (-2,2) interval)
  g8.curr_outliers <- g8.curr_model$fitted.values[rstudent(g8.curr_model) >2 | rstudent(g8.curr_model) < -2]
  g8.rows_outliers <- as.numeric(names(g8.curr_outliers))
  g8.curr_obsSel2 <- g8.curr_obsSel
  g8.curr_obsSel2[g8.rows_outliers] <- "FALSE"
  g8.curr_obsSel2 <- as.logical(g8.curr_obsSel2)
  
 ## Compute intraclass correlation coefficient
  g8.curr_elast.by.REF2 <- allelast[g8.curr_obsSel2,c("REFERENCE","BETA")]
  g8.curr_ICC2 <- ICCest(REFERENCE, BETA, g8.curr_elast.by.REF2, alpha = 0.05, CI.type = c("THD"))
  g8.ICC.all2[[i]] = g8.curr_ICC2
  
##MODEL ESTIMATION (POST-OUTLIER ANALYSIS)  
if(length(g8.curr_obsSel2[g8.curr_obsSel2 == "TRUE"]) < length(g8.curr_obsSel[g8.curr_obsSel == "TRUE"])){
    g8.currFAT2 <- lm(formula = BETA ~ ST_ERROR, data=allelast, subset=g8.curr_obsSel2, weights = PRECISION)
#Regression of st.error on effect size and dummy variable indicating whether standard error has been obtained directly from the paper or estimated
    g8.currSEbias <- lm(formula = ST_ERROR ~ BETA + CALC_STERROR -1, data = allelast, subset=g8.curr_obsSel2)
    
    g8.curr_model2 <- lm( formula=g8.curr_formula, data=allelast, 
                              subset=g8.curr_obsSel2,
                              weights = PRECISION )
         g8.curr_model2.lme <- lmer(formula=g8.curr_formula.lme, data=allelast,
                                subset=g8.curr_obsSel2, 
                                weights = PRECISION, REML = FALSE)
          g8.curr_model2.ols <- lm(formula=g8.curr_formula.ols, data=allelast, 
                                    subset=g8.curr_obsSel2)
    
    # if needed, re-do analysis dropping vars for which coeff is "NA"
  if (NA %in% coefficients(g8.curr_model2)) {
    g8.curr_varList = g8.curr_varList[!is.na(coefficients(g8.curr_model2)[-1])]   # drop first coefficient (for constant) from coefficient list
    
    g8.curr_formula = paste("BETA",paste(g8.curr_varList, collapse="+"),sep="~")  # construct text string for formula (apparently required)
    g8.curr_formula.lme = paste(paste("BETA",paste(g8.curr_varList, collapse="+"),sep="~"),"(1|REFERENCE)", sep = "+")
    g8.curr_formula.ols = paste("BETA",paste(g8.curr_varList[g8.curr_varList != "VARIANCE" & g8.curr_varList != "CALC_STERROR"], collapse="+"),sep="~")
    
    g8.curr_model2 <- lm(formula=g8.curr_formula, data=allelast, 
                              subset=g8.curr_obsSel2,
                              weights = PRECISION)
      g8.curr_model2.lme <- lmer(formula=g8.curr_formula.lme, data=allelast,
                              subset=g8.curr_obsSel2, 
                              weights = PRECISION, REML = FALSE)
        g8.curr_model2.ols <- lm(formula=g8.curr_formula.ols, data=allelast, 
                                  subset=g8.curr_obsSel2)
    }
    
    # compute clustered standard errors for the WLS model using REFERENCE as the clustering variable
    g8.clust.vcov.2 <- cluster.vcov(g8.curr_model2, subset(allelast, g8.curr_obsSel2)$REFERENCE)
    # substitute heteroskedasticity-consistent standard errors for default standard errors in OLS regressions
    #g8.HC.vcov.2 <- sqrt(diag(vcovHC(g8.curr_model2.ols)))
    g8.HC.vcov.2 <- vcovHC(g8.curr_model2.ols)
         
    ## Compute intraclass correlation coefficient of the residuals
    g8.curr_resid.by.REF2 <- cbind(g8.curr_elast.by.REF2, g8.curr_model2$residuals)
    g8.curr_resid.by.REF2$RESIDUAL = g8.curr_resid.by.REF2[,3]
    g8.curr_resid_ICC2 <- ICCest(REFERENCE, RESIDUAL, g8.curr_resid.by.REF2, alpha = 0.05, CI.type = c("THD"))
    g8.ICC_resid.all2[[i]] = g8.curr_resid_ICC2
    

#End of Estimation
#==================
    
#Print Results
#=============
    printf("Subset selection: %s", g8.selectorSubsetString(g8.selectorSets[i,]))
    printf("Formula estimated: %s",g8.curr_formula)
        
#Pre-model estimation tests
    plot(allelast[g8.curr_obsSel2,"BETA"], allelast[g8.curr_obsSel2,"PRECISION"],type="p",
       main = "Funnel Plot", xlab = "Elasticity Values", ylab = "Precision (1/standard error)")
    print(summary(g8.currFAT2))  #print results from funnel asymmetry test
    print(summary(g8.currSEbias)) #print results from testing whether there is bias in the standard errors that have been calculated
    
#Results from WLS estimation    
    print(summary(g8.curr_model2, robust = F)) #print summary of WLS regression
    print(coeftest(g8.curr_model2, g8.clust.vcov.2)) #print coefficient tests of WLS regression based on clustered standard errors
    #Model diagnostics
    ##Model Fit 
    plot(subset(allelast, g8.curr_obsSel2)$BETA, g8.curr_model2$fitted.values)  #plot observed values versus fitted values
    abline(0,1)    
    ## Multicolinearity    
    print(vif(g8.curr_model2))   # print variance inflation factors    
    ## Normality of residuals 
    print(shapiro.test(g8.curr_model2$residuals)) # Shapiro-Wilk normality test (null hypothesis: residuals are normally distributed)
    ## Heteroskedasticity
    plot(g8.curr_model2$fitted.values, g8.curr_model2$residuals, main = "Residuals vs. Fitted Values")
    print(bptest(g8.curr_model2))     #print results from Breusch-Pagan test
    
#Results from LME estimation    
    print(summary(g8.curr_model2.lme)) #print summary of linear mixed effect model
    
#Likelihood-ratio test to compare the fit of the lme and ols model (null hypothesis: restricted model (OLS in this case) is better)
    print(lrtest(g8.curr_model2.lme, g8.curr_model2))

#Results from OLS estimation
    print(summary(g8.curr_model2.ols))  #print summary of OLS regression
    print(coeftest(g8.curr_model2.ols, g8.HC.vcov.2))   #print coefficient tests of OLS regression based on heteroskedasticity-consistent standard errors    
    #print(summaryw(g8.curr_model2.ols)) #print summary of OLS regression based on heteroskedasticity-consistent standard errors


#Compute baseline elasticity and associated standard error
#=========================================================

# Create dataframe with as many rows as unique moderator variable names across the 8 metaregressions
g8_curr.baseline <- as.data.frame(Reduce(union, list(c("(Intercept)"),all_varList_P_SR.Transp, all_varList_P_LR.Transp, all_varList_P_SR.nonTransp, all_varList_P_LR.nonTransp, all_varList_Y_SR.Transp, all_varList_Y_LR.Transp, all_varList_Y_SR.nonTransp, all_varList_Y_LR.nonTransp)))

colnames(g8_curr.baseline)[1]<-"Varname"
#Create a column that contains the values to be used for each variable in estimating elasticity baselines. Start with zeros as a placeholder and adjust as desired for each specific variable
##Note: 5 alternative baselines are computed for elasticity with respect to crude oil price, to a new price/income maximum, and to a new price/income maximum in petroleum product prices
g8_curr.baseline$Baseline.Value <- 0
g8_curr.baseline$Baseline.Value.OECD <- 0
g8_curr.baseline$Baseline.Value.nonOECD <- 0
g8_curr.baseline$Baseline.Value.Max <- 0
g8_curr.baseline$Baseline.Value.ProdPMax <- 0

##Baseline elasticity with respect to crude oil price
g8.eval.one <- c("(Intercept)")
g8.eval.mean <- c("g8.YrAvg.cent","g8.rgdpe_cap.1998.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS","OECD","Monthly","Quarterly")
g8.eval.mixed <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") #These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
g8.eval.mixed2 <- c("VehStk") #These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
g8_curr.baseline$Baseline.Value[g8_curr.baseline$Varname %in% g8.eval.one] <- 1

##Baseline elasticity with respect to crude oil price in OECD
g8.eval.one.OECD <- c("(Intercept)","OECD")
#g8.eval.mean.OECD <- c("g8.YrAvg.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS")
g8.eval.region.OECD <- c("g8.rgdpe_cap.1998.cent","g8.YrAvg.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS","Monthly","Quarterly")
g8.eval.mixed.OECD <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") #These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
g8.eval.mixed2.OECD <- c("VehStk") #These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
g8_curr.baseline$Baseline.Value.OECD[g8_curr.baseline$Varname %in% g8.eval.one.OECD] <- 1

##Baseline elasticity with respect to crude oil price in non-OECD
g8.eval.one.nonOECD <- c("(Intercept)")
#g8.eval.mean.nonOECD <- c("g8.YrAvg.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS")
g8.eval.region.nonOECD <- c("g8.rgdpe_cap.1998.cent", "g8.YrAvg.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS","Monthly","Quarterly")
g8.eval.mixed.nonOECD <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") #These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
g8.eval.mixed2.nonOECD <- c("VehStk") #These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
g8_curr.baseline$Baseline.Value.nonOECD[g8_curr.baseline$Varname %in% g8.eval.one.nonOECD] <- 1

##Baseline elasticity with respect to a new max in crude oil price
g8.eval.one.max <- c("(Intercept)","Pmax","Ymax")
g8_curr.baseline$Baseline.Value.Max[g8_curr.baseline$Varname %in% g8.eval.one.max] <- 1

##Baseline elasticity with respect to a new max in petroleum product prices
g8.eval.one.prodpmax <- c("(Intercept)","Pmax","Ymax","EndUserP")
g8.eval.mean.prodpmax <- c("g8.YrAvg.cent","g8.rgdpe_cap.1998.cent","DslTransp","FuelSwitch","g8.SPEEDYRS.cent","CS","CSTS","OECD","Monthly","Quarterly","PRICE.1998.cent")
g8_curr.baseline$Baseline.Value.ProdPMax[g8_curr.baseline$Varname %in% g8.eval.one.prodpmax] <- 1


for(j in 1:nrow(g8_curr.baseline)){
#Adjust value of moderator variables to be used in estimating elasticity baselines for members of the sets defined above to take values different from 0 or 1
  g8_curr.baseline$Baseline.Value[j] <- 
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
        ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mean & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
           g8_curr.baseline$Baseline.Value[j])))))
  
  
  g8_curr.baseline$Baseline.Value.OECD[j] <- 
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed.OECD & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed.OECD & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"])),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"]))/sum(allelast[g8.curr_obsSel2,"OECD"]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2.OECD & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"])),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"]))/sum(allelast[g8.curr_obsSel2,"OECD"]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2.OECD & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.region.OECD & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"])),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*allelast[g8.curr_obsSel2,"OECD"]))/sum(allelast[g8.curr_obsSel2,"OECD"]),
  g8_curr.baseline$Baseline.Value.OECD[j])))))
  
  
  g8_curr.baseline$Baseline.Value.nonOECD[j] <- 
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed.nonOECD & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed.nonOECD & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1))),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1)))/((-1)*(sum(allelast[g8.curr_obsSel2,"OECD"]-1))),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2.nonOECD & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1))),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1)))/((-1)*(sum(allelast[g8.curr_obsSel2,"OECD"]-1))),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2.nonOECD & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.region.nonOECD & !is.na(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1))),(sum(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]*(-1)*(allelast[g8.curr_obsSel2,"OECD"]-1)))/((-1)*(sum(allelast[g8.curr_obsSel2,"OECD"]-1))),
  g8_curr.baseline$Baseline.Value.nonOECD[j])))))
  
  
  g8_curr.baseline$Baseline.Value.Max[j] <- ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
        ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mean & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
           g8_curr.baseline$Baseline.Value.Max[j])))))
  
  g8_curr.baseline$Baseline.Value.ProdPMax[j] <- ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "SR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
    ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mixed2 & "LR" %in% substr(g8.selectorSets[i,1], 1, 4) & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), 0*mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
        ifelse(g8_curr.baseline$Varname[j] %in% g8.eval.mean.prodpmax  & !is.na(mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))])), mean(allelast[g8.curr_obsSel2,c(as.character(g8_curr.baseline$Varname[j]))]),
           g8_curr.baseline$Baseline.Value.ProdPMax[j])))))
  
  
  
  g8_curr.baseline$include[j] <- ifelse(g8_curr.baseline$Varname[j] %in% names(coefficients(g8.curr_model2)),1,0)
##extract info from WLS estimation
  g8_curr.baseline$coef.est[j] <- ifelse(g8_curr.baseline$include[j] == "1", coef(summary(g8.curr_model2))[as.character(g8_curr.baseline$Varname[j]),1], 0)
  g8_curr.baseline$st.error[j]  <- ifelse(g8_curr.baseline$include[j] == "1", coef(summary(g8.curr_model2))[as.character(g8_curr.baseline$Varname[j]),2], 0)
  g8_curr.baseline$clust.error[j]  <- ifelse(g8_curr.baseline$include[j] == "1", coeftest(g8.curr_model2, g8.clust.vcov.2)[as.character(g8_curr.baseline$Varname[j]),2], 0)
##extract info from LME estimation
  g8_curr.baseline$coef.est.LME[j] <- ifelse(g8_curr.baseline$include[j] == "1", coef(summary(g8.curr_model2.lme))[as.character(g8_curr.baseline$Varname[j]),1], 0)
  g8_curr.baseline$st.error.LME[j]  <- ifelse(g8_curr.baseline$include[j] == "1", coef(summary(g8.curr_model2.lme))[as.character(g8_curr.baseline$Varname[j]),2], 0)
##extract info from OLS estimation
  g8_curr.baseline$include.ols[j] <- ifelse(g8_curr.baseline$Varname[j] %in% names(coefficients(g8.curr_model2.ols)),1,0)
  g8_curr.baseline$coef.est.OLS[j] <- ifelse(g8_curr.baseline$include.ols[j] == "1", coef(summary(g8.curr_model2.ols))[as.character(g8_curr.baseline$Varname[j]),1], 0)
  g8_curr.baseline$st.error.OLS[j]  <- ifelse(g8_curr.baseline$include.ols[j] == "1", coef(summary(g8.curr_model2.ols))[as.character(g8_curr.baseline$Varname[j]),2], 0)
  #g8_curr.baseline$HC.error[j]  <-  ifelse(g8_curr.baseline$include[j] == "1", coef(summaryw(g8.curr_model2.ols))[as.character(g8_curr.baseline$Varname[j]),2], 0)
  g8_curr.baseline$HC.error[j]  <- ifelse(g8_curr.baseline$include.ols[j] == "1", coeftest(g8.curr_model2.ols, g8.HC.vcov.2)[as.character(g8_curr.baseline$Varname[j]),2], 0)
  }

#Compute baseline and standard error
g8_curr.baseline <- mutate(g8_curr.baseline, comp.mean = include * Baseline.Value * coef.est,
                                             comp.sterror = (include * Baseline.Value * st.error)**2,
                                             comp.clusterror = (include * Baseline.Value * clust.error)**2,
                                             comp.mean.LME = include * Baseline.Value *coef.est.LME,
                                             comp.sterror.LME = (include * Baseline.Value * st.error.LME)**2,
                                             comp.mean.ols = include * Baseline.Value * coef.est.OLS,
                                             comp.sterror.ols = (include * Baseline.Value * st.error.OLS)**2,
                                             comp.HCerror = (include * Baseline.Value * HC.error)**2,
                           
                                             comp.mean.OECD = include * Baseline.Value.OECD * coef.est,
                                             comp.sterror.OECD = (include * Baseline.Value.OECD * st.error)**2,
                                             comp.clusterror.OECD = (include * Baseline.Value.OECD * clust.error)**2,
                                             comp.mean.LME.OECD = include * Baseline.Value.OECD *coef.est.LME,
                                             comp.sterror.LME.OECD = (include * Baseline.Value.OECD * st.error.LME)**2,
                                             comp.mean.ols.OECD = include * Baseline.Value.OECD * coef.est.OLS,
                                             comp.sterror.ols.OECD = (include * Baseline.Value.OECD * st.error.OLS)**2,
                                             comp.HCerror.OECD = (include * Baseline.Value.OECD * HC.error)**2,
                           
                                             comp.mean.nonOECD = include * Baseline.Value.nonOECD * coef.est,
                                             comp.sterror.nonOECD = (include * Baseline.Value.nonOECD * st.error)**2,
                                             comp.clusterror.nonOECD = (include * Baseline.Value.nonOECD * clust.error)**2,
                                             comp.mean.LME.nonOECD = include * Baseline.Value.nonOECD *coef.est.LME,
                                             comp.sterror.LME.nonOECD = (include * Baseline.Value.nonOECD * st.error.LME)**2,
                                             comp.mean.ols.nonOECD = include * Baseline.Value.nonOECD * coef.est.OLS,
                                             comp.sterror.ols.nonOECD = (include * Baseline.Value.nonOECD * st.error.OLS)**2,
                                             comp.HCerror.nonOECD = (include * Baseline.Value.nonOECD * HC.error)**2,
                           
                                             comp.mean.max = include * Baseline.Value.Max * coef.est,
                                             comp.sterror.max = (include * Baseline.Value.Max * st.error)**2,
                                             comp.clusterror.max = (include * Baseline.Value.Max * clust.error)**2,
                                             comp.mean.LME.max = include * Baseline.Value.Max *coef.est.LME,
                                             comp.sterror.LME.max = (include * Baseline.Value.Max * st.error.LME)**2,
                                             comp.mean.ols.max = include * Baseline.Value.Max * coef.est.OLS,
                                             comp.sterror.ols.max = (include * Baseline.Value.Max * st.error.OLS)**2,
                                             comp.HCerror.max = (include * Baseline.Value.Max * HC.error)**2,
                           
                                             comp.mean.prodpmax = include * Baseline.Value.ProdPMax * coef.est,
                                             comp.sterror.prodpmax = (include * Baseline.Value.ProdPMax * st.error)**2,
                                             comp.clusterror.prodpmax = (include * Baseline.Value.ProdPMax * clust.error)**2,
                                             comp.mean.LME.prodpmax = include * Baseline.Value.ProdPMax *coef.est.LME,
                                             comp.sterror.LME.prodpmax = (include * Baseline.Value.ProdPMax * st.error.LME)**2,
                                             comp.mean.ols.prodpmax = include * Baseline.Value.ProdPMax * coef.est.OLS,
                                             comp.sterror.ols.prodpmax = (include * Baseline.Value.ProdPMax * st.error.OLS)**2,
                                             comp.HCerror.prodpmax = (include * Baseline.Value.ProdPMax * HC.error)**2
                           
                                             
                           )

g8.baseline.comps[[i]] = g8_curr.baseline

g8.base_elast = sum(g8_curr.baseline$comp.mean)
g8.stdv_base_elast  = sqrt(sum(g8_curr.baseline$comp.sterror))
g8.stdv_base_elast.clustse  = sqrt(sum(g8_curr.baseline$comp.clusterror))
g8.base_elast.LME  = sum(g8_curr.baseline$comp.mean.LME)
g8.stdv_base_elast.LME  = sqrt(sum(g8_curr.baseline$comp.sterror.LME))
g8.base_elast.OLS  = sum(g8_curr.baseline$comp.mean.ols)
g8.stdv_base_elast.OLS  = sqrt(sum(g8_curr.baseline$comp.sterror.ols))
g8.stdv_base_elast.HCse  = sqrt(sum(g8_curr.baseline$comp.HCerror))

g8.base_elast.OECD = sum(g8_curr.baseline$comp.mean.OECD )
g8.stdv_base_elast.OECD  = sqrt(sum(g8_curr.baseline$comp.sterror.OECD ))
g8.stdv_base_elast.clustse.OECD  = sqrt(sum(g8_curr.baseline$comp.clusterror.OECD ))
g8.base_elast.LME.OECD  = sum(g8_curr.baseline$comp.mean.LME.OECD )
g8.stdv_base_elast.LME.OECD  = sqrt(sum(g8_curr.baseline$comp.sterror.LME.OECD ))
g8.base_elast.OLS.OECD  = sum(g8_curr.baseline$comp.mean.ols.OECD )
g8.stdv_base_elast.OLS.OECD  = sqrt(sum(g8_curr.baseline$comp.sterror.ols.OECD ))
g8.stdv_base_elast.HCse.OECD  = sqrt(sum(g8_curr.baseline$comp.HCerror.OECD ))

g8.base_elast.nonOECD = sum(g8_curr.baseline$comp.mean.nonOECD )
g8.stdv_base_elast.nonOECD  = sqrt(sum(g8_curr.baseline$comp.sterror.nonOECD ))
g8.stdv_base_elast.clustse.nonOECD  = sqrt(sum(g8_curr.baseline$comp.clusterror.nonOECD ))
g8.base_elast.LME.nonOECD  = sum(g8_curr.baseline$comp.mean.LME.nonOECD )
g8.stdv_base_elast.LME.nonOECD  = sqrt(sum(g8_curr.baseline$comp.sterror.LME.nonOECD ))
g8.base_elast.OLS.nonOECD  = sum(g8_curr.baseline$comp.mean.ols.nonOECD )
g8.stdv_base_elast.OLS.nonOECD  = sqrt(sum(g8_curr.baseline$comp.sterror.ols.nonOECD ))
g8.stdv_base_elast.HCse.nonOECD  = sqrt(sum(g8_curr.baseline$comp.HCerror.nonOECD ))

g8.base_elast.max = sum(g8_curr.baseline$comp.mean.max)
g8.stdv_base_elast.max = sqrt(sum(g8_curr.baseline$comp.sterror.max))
g8.stdv_base_elast.clustse.max = sqrt(sum(g8_curr.baseline$comp.clusterror.max))
g8.base_elast.LME.max = sum(g8_curr.baseline$comp.mean.LME.max)
g8.stdv_base_elast.LME.max = sqrt(sum(g8_curr.baseline$comp.sterror.LME.max))
g8.base_elast.OLS.max = sum(g8_curr.baseline$comp.mean.ols.max)
g8.stdv_base_elast.OLS.max = sqrt(sum(g8_curr.baseline$comp.sterror.ols.max))
g8.stdv_base_elast.HCse.max = sqrt(sum(g8_curr.baseline$comp.HCerror.max))

g8.base_elast.prodpmax = sum(g8_curr.baseline$comp.mean.prodpmax)
g8.stdv_base_elast.prodpmax = sqrt(sum(g8_curr.baseline$comp.sterror.prodpmax))
g8.stdv_base_elast.clustse.prodpmax = sqrt(sum(g8_curr.baseline$comp.clusterror.prodpmax))
g8.base_elast.LME.prodpmax = sum(g8_curr.baseline$comp.mean.LME.prodpmax)
g8.stdv_base_elast.LME.prodpmax = sqrt(sum(g8_curr.baseline$comp.sterror.LME.prodpmax))
g8.base_elast.OLS.prodpmax = sum(g8_curr.baseline$comp.mean.ols.prodpmax)
g8.stdv_base_elast.OLS.prodpmax = sqrt(sum(g8_curr.baseline$comp.sterror.ols.prodpmax))
g8.stdv_base_elast.HCse.prodpmax = sqrt(sum(g8_curr.baseline$comp.HCerror.prodpmax))

g8.raw_mean <- mean(allelast[g8.curr_obsSel2,c("BETA")])
g8.raw_stdev <- sd(allelast[g8.curr_obsSel2,c("BETA")])
g8.npapers <- length(unique(subset(allelast,g8.curr_obsSel2)$REFERENCE))
g8.product.p.obs <- sum(allelast[g8.curr_obsSel2,c("EndUserP")])
g8.speedyrs.mean <- round(mean(allelast[g8.curr_obsSel2,c("SPEEDYRS")]),4)
g8.speedyrs.mean.OECD <- round((sum(allelast[g8.curr_obsSel2,c("SPEEDYRS")]*allelast[g8.curr_obsSel2,c("OECD")])/sum(allelast[g8.curr_obsSel2,c("OECD")])),4)
g8.speedyrs.mean.nonOECD <- round((sum(allelast[g8.curr_obsSel2,c("SPEEDYRS")]*(-1)*(allelast[g8.curr_obsSel2,c("OECD")]-1))/((-1)*sum(allelast[g8.curr_obsSel2,c("OECD")]-1))),4)
g8.yravg.mean <- round(mean(allelast[g8.curr_obsSel2,c("YrAvg.avg")]),4)
g8.rgdpe1998.mean <- round(mean(allelast[g8.curr_obsSel2,c("rgdpe_cap.1998.avg")]),4)
g8.adj_r_sq.wls <- summary(g8.curr_model2)$adj.r.squared
g8.adj_r_sq.ols <- summary(g8.curr_model2.ols)$adj.r.squared
g8.uniqueobs <- nrow(allelast[g8.curr_obsSel2,c("REFERENCE",g8.curr_varList_minusVARIANCE)][!duplicated(allelast[g8.curr_obsSel2,c("REFERENCE",g8.curr_varList_minusVARIANCE)]),])

g8.pubbias.test[[i]] = cbind(as.data.frame(rep(g8.subsetString2,2)), tidy(g8.currFAT2))
g8.obsSel2[[i]] = allelast[g8.curr_obsSel2,]
g8.modelsEstimated2[[i]] = tidy(g8.curr_model2)
g8.modelsEstimated2.raw[[i]] = g8.curr_model2
g8.coeffsEstimated2[[i]] = coeftest(g8.curr_model2, g8.clust.vcov.2)
g8.WLS.elastID[[i]] <- data.frame(ElastID= rep(g8.subsetString2, nrow(g8.coeffsEstimated2[[i]])))

#g8.modelsEstimated2.LME[[i]] = broom.mixed::tidy(g8.curr_model2.lme)
g8.modelsEstimated2.LME[[i]] = tidy(g8.curr_model2.lme)
g8.modelsEstimated2.LME.raw[[i]] = g8.curr_model2.lme
g8.LME.elastID[[i]] <- data.frame(ElastID= rep(g8.subsetString2, nrow(g8.modelsEstimated2.LME[[i]])))
g8.vifEstimated2[[i]] = vif(g8.curr_model2)

g8.LRT[[i]] <- lrtest(g8.curr_model2.lme, g8.curr_model2)

g8.modelsEstimated2.OLS[[i]] = tidy(g8.curr_model2.ols)
g8.coeffsEstimated2.OLS[[i]] = coeftest(g8.curr_model2.ols, g8.HC.vcov.2)
g8.modelsEstimated2.OLS.raw[[i]] = g8.curr_model2.ols
g8.OLS.elastID[[i]] <- data.frame(ElastID= rep(g8.subsetString2, nrow(g8.coeffsEstimated2.OLS[[i]])))


g8.baselinesEstimated[[i]] = c(g8.subsetString2, 
                               round(g8.raw_mean,4), 
                               round(g8.raw_stdev,4),
                               ##WLS-related results
                               round(mean(g8.curr_model2$fitted.values),4),
                               as.numeric(round(glance(g8.curr_model2)$sigma,4)),
                               round(g8.adj_r_sq.wls,2), 
                               as.numeric(round(g8.base_elast,6)), 
                               as.numeric(round(g8.stdv_base_elast,6)), 
                               as.numeric(round(g8.stdv_base_elast.clustse,6)),
                               
                               as.numeric(round(g8.base_elast.OECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.OECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.clustse.OECD,6)),
                               
                               as.numeric(round(g8.base_elast.nonOECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.nonOECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.clustse.nonOECD,6)),
                               
                               as.numeric(round(g8.base_elast.max,6)), 
                               as.numeric(round(g8.stdv_base_elast.max,6)), 
                               as.numeric(round(g8.stdv_base_elast.clustse.max,6)),
                               
                               as.numeric(round(g8.base_elast.prodpmax,6)), 
                               as.numeric(round(g8.stdv_base_elast.prodpmax,6)), 
                               as.numeric(round(g8.stdv_base_elast.clustse.prodpmax,6)),
              
                               ##LME-related results
                               round(mean(pull(augment(g8.curr_model2.lme)[,".fitted"])),4),
                               as.numeric(round(glance(g8.curr_model2.lme)$sigma,4)), 
                               as.numeric(round(g8.base_elast.LME,6)), 
                               as.numeric(round(g8.stdv_base_elast.LME,6)),
                               
                               as.numeric(round(g8.base_elast.LME.OECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.LME.OECD,6)),
                               
                               as.numeric(round(g8.base_elast.LME.nonOECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.LME.nonOECD,6)),
                               
                               as.numeric(round(g8.base_elast.LME.max,6)), 
                               as.numeric(round(g8.stdv_base_elast.LME.max,6)),
                               
                               as.numeric(round(g8.base_elast.LME.prodpmax,6)), 
                               as.numeric(round(g8.stdv_base_elast.LME.prodpmax,6)),
                               
                               #Likelihood ratio test
                               round(lrtest(g8.curr_model2.lme, g8.curr_model2)[nrow(lrtest(g8.curr_model2.lme, g8.curr_model2)),5],4),
                               ##OLS-related results
                               round(mean(g8.curr_model2.ols$fitted.values),4),
                               as.numeric(round(glance(g8.curr_model2.ols)$sigma,4)),
                               round(g8.adj_r_sq.ols,2), 
                               as.numeric(round(g8.base_elast.OLS,6)), 
                               as.numeric(round(g8.stdv_base_elast.OLS,6)), 
                               as.numeric(round(g8.stdv_base_elast.HCse,6)),
                               
                               as.numeric(round(g8.base_elast.OLS.OECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.OLS.OECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.HCse.OECD,6)),
                               
                               as.numeric(round(g8.base_elast.OLS.nonOECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.OLS.nonOECD,6)), 
                               as.numeric(round(g8.stdv_base_elast.HCse.nonOECD,6)),
                               
                               as.numeric(round(g8.base_elast.OLS.max,6)), 
                               as.numeric(round(g8.stdv_base_elast.OLS.max,6)), 
                               as.numeric(round(g8.stdv_base_elast.HCse.max,6)),
                               
                               as.numeric(round(g8.base_elast.OLS.prodpmax,6)), 
                               as.numeric(round(g8.stdv_base_elast.OLS.prodpmax,6)), 
                               as.numeric(round(g8.stdv_base_elast.HCse.prodpmax,6)),
                               
                               #Other summary metrics
                               length(g8.curr_model2$residuals),
                               g8.uniqueobs, 
                               g8.npapers, 
                               g8.product.p.obs, 
                               g8.speedyrs.mean, 
                               g8.speedyrs.mean.OECD, 
                               g8.speedyrs.mean.nonOECD, 
                               g8.yravg.mean, 
                               g8.rgdpe1998.mean)

}  
}
###End of metaregression loop

```

```{r metareg.store, echo = FALSE, warning =FALSE, message=FALSE }
# Store metaregression coefficients and metaregression id strings from WLS, LME, and OLS specifications into data.frames to be bound and exported to a .csv file

## WLS
g8.metareg.results2 <- do.call("rbind", g8.modelsEstimated2) ## store metaregression coefficients into a dataframe
##WLS with clustered standard errors
coefs.clust.se <- function(x){round(x[,c(1:4)],8)}
g8.metareg.results.clust.se <- lapply(g8.coeffsEstimated2, coefs.clust.se)
g8.coefs.all.clust.se <-(do.call("rbind",g8.metareg.results.clust.se))
g8.coefs.all.clust.se <- rownames_to_column(as.data.frame(g8.coefs.all.clust.se), "variable")
g8.WLS.elastIDs <- (do.call("rbind",g8.WLS.elastID))
g8.coefs.all.clust.se.ID <- cbind(g8.WLS.elastIDs,g8.coefs.all.clust.se)
g8.coefs.all.clust.se.ID <- as.data.frame(g8.coefs.all.clust.se.ID)

##LME
g8.LME.elastIDs <- (do.call("rbind",g8.LME.elastID))
g8.modelsEstimated2.LME.all <- do.call(rbind, g8.modelsEstimated2.LME)
g8.coefs.all.LME.ID <- cbind(g8.LME.elastIDs,g8.modelsEstimated2.LME.all)

## OLS
g8.metareg.results2.OLS <- do.call("rbind", g8.modelsEstimated2.OLS) ## store metaregression coefficients into a dataframe
##OLS with heteroskedasticity-consistent standard errors
coefs.hc.se <- function(x){round(x[,c(1:4)],8)}
g8.metareg.results.hc.se <- lapply(g8.coeffsEstimated2.OLS, coefs.hc.se)
#g8.metareg.results.hc.se <- lapply(summaryw(g8.modelsEstimated2.OLS), coefs.hc.se)
g8.coefs.all.hc.se <-(do.call("rbind",g8.metareg.results.hc.se))
g8.coefs.all.hc.se <- rownames_to_column(as.data.frame(g8.coefs.all.hc.se), "variable")
g8.OLS.elastIDs <- (do.call("rbind",g8.OLS.elastID))
g8.coefs.all.hc.se.ID <- cbind(g8.OLS.elastIDs,g8.coefs.all.hc.se)
g8.coefs.all.hc.se.ID <- as.data.frame(g8.coefs.all.hc.se.ID)

write.csv(g8.coefs.all.clust.se.ID, "../Output/g8.coefs.WLS.csv")
write.csv(g8.coefs.all.LME.ID, "../Output/g8.coefs.LME.csv")
write.csv(g8.coefs.all.hc.se.ID, "../Output/g8.coefs.OLS.csv")

##Store variance inflation factors into a data.frame
g8.vifs.all.df2 <- data.frame(matrix(unlist(g8.vifEstimated2)))
colnames(g8.vifs.all.df2) = "VIF"

g8.all_baselinesEstimated <- as.data.frame(do.call(rbind,g8.baselinesEstimated),stringsAsFactors = FALSE)
colnames(g8.all_baselinesEstimated) <- c("subsetString","raw.mean","raw.stdev",
                                         "fittedmean.WLS","sigma.WLS","R2adj.WLS",
                                         "baseline.WLS","sterror.baseline.WLS","clust.sterror.baseline.WLS",
                                         "baseline.WLS.OECD","sterror.baseline.WLS.OECD","clust.sterror.baseline.WLS.OECD",
                                         "baseline.WLS.nonOECD","sterror.baseline.WLS.nonOECD","clust.sterror.baseline.WLS.nonOECD",
                                         "baseline.WLS.max","sterror.baseline.WLS.max","clust.sterror.baseline.WLS.max",
                                         "baseline.WLS.prodpmax","sterror.baseline.WLS.prodpax","clust.sterror.baseline.WLS.prodpmax",
                                         
                                         "fittedmean.LME","sigma.LME",
                                         "baseline.LME","sterror.baseline.LME",
                                         "baseline.LME.OECD","sterror.baseline.LME.OECD",
                                         "baseline.LME.nonOECD","sterror.baseline.LME.nonOECD",
                                         "baseline.LME.max","sterror.baseline.LME.max",
                                         "baseline.LME.prodpmax","sterror.baseline.LME.prodpmax",
                                         
                                         "LRT_pvalue",
                                         "fittedmean.OLS","sigma.OLS","R2adj.OLS",
                                         "baseline.OLS","sterror.baseline.OLS","hc.sterror.baseline.OLS",
                                         "baseline.OLS.OECD","sterror.baseline.OLS.OECD","hc.sterror.baseline.OLS.OECD",
                                         "baseline.OLS.nonOECD","sterror.baseline.OLS.nonOECD","hc.sterror.baseline.OLS.nonOECD",
                                         "baseline.OLS.max","sterror.baseline.OLS.max","hc.sterror.baseline.OLS.max",
                                         "baseline.OLS.prodpmax","sterror.baseline.OLS.prodpmax","hc.sterror.baseline.OLS.prodpmax",
                                         
                                         "n.obs","unique.obs","n.papers","product.p.obs","mean.SPEEDYRS","mean.SPEEDYRS.OECD","mean.SPEEDYRS.nonOECD","mean.YrAvg","mean.rgdpe1998")

g8.all_baselinesEstimated$subsetString <- as.factor(g8.all_baselinesEstimated$subsetString)
g8.all_baselinesEstimated$raw.coeffvar <- as.numeric(g8.all_baselinesEstimated$raw.mean)/as.numeric(g8.all_baselinesEstimated$raw.stdev)
g8.all_baselinesEstimated$WLS.coeffvar <- as.numeric(g8.all_baselinesEstimated$baseline.WLS)/as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS)
g8.all_baselinesEstimated$OLS.coeffvar <- as.numeric(g8.all_baselinesEstimated$baseline.OLS)/as.numeric(g8.all_baselinesEstimated$hc.sterror.baseline.OLS)
g8.all_baselinesEstimated$LME.coeffvar <- as.numeric(g8.all_baselinesEstimated$baseline.LME)/as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME)

#For each elasticity grouping, select the baseline to be used for computing world oil demand elasticities out of the three model specifications estimated: WLS with clustered standard errors, OLS with heteroskedasticity-consistent standard errors, or linear mixed effects (LME)
g8.all_baselinesEstimated$fittedmean <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$fittedmean.LME),as.numeric(g8.all_baselinesEstimated$fittedmean.WLS))
g8.all_baselinesEstimated$sigma <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sigma.LME),as.numeric(g8.all_baselinesEstimated$sigma.WLS))

g8.all_baselinesEstimated$baseline <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$baseline.LME),as.numeric(g8.all_baselinesEstimated$baseline.WLS))
g8.all_baselinesEstimated$sterror.baseline <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME),as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS))

g8.all_baselinesEstimated$baseline.OECD <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$baseline.LME.OECD),as.numeric(g8.all_baselinesEstimated$baseline.WLS.OECD))
g8.all_baselinesEstimated$sterror.baseline.OECD <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME.OECD),as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS.OECD))

g8.all_baselinesEstimated$baseline.nonOECD <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$baseline.LME.nonOECD),as.numeric(g8.all_baselinesEstimated$baseline.WLS.nonOECD))
g8.all_baselinesEstimated$sterror.baseline.nonOECD <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME.nonOECD),as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS.nonOECD))

g8.all_baselinesEstimated$baseline.max <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$baseline.LME.max),as.numeric(g8.all_baselinesEstimated$baseline.WLS.max))
g8.all_baselinesEstimated$sterror.baseline.max <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME.max),as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS.max))

g8.all_baselinesEstimated$baseline.prodpmax <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$baseline.LME.prodpmax),as.numeric(g8.all_baselinesEstimated$baseline.WLS.prodpmax))
g8.all_baselinesEstimated$sterror.baseline.prodpmax <- ifelse(as.numeric(g8.all_baselinesEstimated$LRT_pvalue) < 0.05, as.numeric(g8.all_baselinesEstimated$sterror.baseline.LME.prodpmax),as.numeric(g8.all_baselinesEstimated$clust.sterror.baseline.WLS.prodpmax))

#print(g8.all_baselinesEstimated)
write.csv(g8.all_baselinesEstimated, file = "../Output/g8.baselines.csv")
```


3. Metaregression analysis: methods and moderator variables
===========================================================  

Our model specification and estimation method choices address the econometric issues that are typically present in energy and resource economics meta-analyses applications. The starting point for metaregression specification is a linear relationship between the elasticity estimates $\beta_i$, an intercept $\alpha_0$, and the set of explanatory variables $X$.
$$\beta_i = \alpha_0 + \sum_{k=1}^K \alpha_i*X_{i,k} + e_i$$ 

**a) Variance heterogeneity (heteroskedasticity)**  
When variances are known, Borenstein et al.(2009) and Nelson and Kennedy(2009) recommend giving more weight to the more precise estimates. To address the issue of variance heterogeneity, we estimate the model using weighted least squares with the inverse of standard error of each estimate $(1/se_i)$ as weights.
$$\frac{\beta_i}{se_i} = \frac{\alpha_0}{se_i} + \sum_{k=1}^K \alpha_i*\frac{X_{i,k}}{se_i} + \epsilon_i$$    

**b) Publication bias**  
Publication bias arises when the sample of published estimates is not a random sample of the full population of estimates. The bias results from researchers being more likely to submit, and journals being more likely to publish, studies finding larger effect sizes and/or estimates conforming to the theoretically expected sign. The panels in Figure 2 are funnel plots showing the relationship between the inverse of the standard error (i.e., precision) on the y-axis and the effect size on the x-axis for each of the 8 elasticity groupings. The more asymmetric a funnel plot is around the most precise estimate, the stronger publication bias there is. Funnel asymmetry tests confirmed statistically significant asymmetry at the 10% confidence level in 7 of the 8 metaregressions. Long-run income elasticities in non-transportation sector is the only grouping for which funnel asymmetry can be rejected at the 10% confidence level. 

```{r outFunnelPlots, echo = FALSE, warning =FALSE, message=FALSE }
g8.obsSel2.df <- do.call("rbind", g8.obsSel2)
g8.obsSel2.df <- mutate(g8.obsSel2.df, Type_Sector = as.factor(paste(TYPE_LENGTH2, RoadTransp, OtherSector, sep = "_")))

g8.ElastID2 <- c("Price \nShortRun-\nTransportation", "Price \nShortRun-\nnonTransportation", "Price \nLongRun-\nTransportation", "Price \nLongRun-\nnonTransportation",
             "Income \nShortRun-\nTransportation", "Income \nShortRun-\nnonTransportation", "Income \nLongRun-\nTransportation", "Income \nLongRun-\nnonTransportation")
g8.ElastIDmatch2 <- data.frame(Type_Sector, g8.ElastID2)
g8.ElastIDmatch2$g8.ElastID2 <- factor(g8.ElastIDmatch2$g8.ElastID2, levels=c("Price \nShortRun-\nTransportation", "Price \nShortRun-\nnonTransportation", "Price \nLongRun-\nTransportation", "Price \nLongRun-\nnonTransportation",
             "Income \nShortRun-\nTransportation", "Income \nShortRun-\nnonTransportation", "Income \nLongRun-\nTransportation", "Income \nLongRun-\nnonTransportation"))

g8.obsSel2.df <- merge(g8.obsSel2.df, g8.ElastIDmatch2, by="Type_Sector")

funnel.plots <- ggplot(g8.obsSel2.df, aes(x=BETA, y=PRECISION, label=sprintf("%0.2f", round(BETA, digits = 1)))) + 
  geom_point(size = 1) + 
  facet_wrap(~g8.ElastID2, ncol=4, scales = "free") +
  scale_x_continuous(labels = comma_format(), breaks = pretty_breaks(n = 8)) + 
  scale_y_continuous(labels = comma_format(), breaks = pretty_breaks(n = 6)) + 
  #scale_color_manual(values = color.set11) + 
  #scale_shape_manual(values = shape.set11) + 
  labs(x="Elasticity", y="Precision", title="") +  
  theme(strip.text.x = element_text(size = 9)) + 
  theme(plot.title=element_text(size=12, face="bold", hjust=0.5)) +
  theme(axis.text.x=element_text(size=10, angle=65, hjust=1),axis.text.y=element_text(size=10), axis.title=element_text(size=10,face="bold")) +
  theme(legend.text=element_text(size=10), legend.title=element_blank(), legend.key=element_blank(), legend.position="right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
funnel.plots 
ggsave("../Output/funnel.plots.png", width=6.5, height=4.5, units="in", dpi=600)

pub.bias.test <- do.call("rbind", g8.pubbias.test)
pub.bias.test <- rename(pub.bias.test, Type_Sector=`rep(g8.subsetString2, 2)`)
pub.bias.test <- merge(g8.ElastIDmatch, pub.bias.test, by="Type_Sector")
pub.bias.test$Type <- ifelse(substr(pub.bias.test$Type_Sector,1,1) == "P", "Price", "Income") %>% as.factor()
pub.bias.test$Length.of.Run <- ifelse(grepl("Long",pub.bias.test$g8.ElastID),"Long Run", "Short Run") %>% as.factor()
pub.bias.test$Sector <- ifelse(grepl("non",pub.bias.test$g8.ElastID),"nonTransportation", "Transportation") %>% as.factor()
pub.bias.test <- data.frame(lapply(pub.bias.test, function(y) if(is.numeric(y)) round(y, 3) else y))
pub.bias.test <- pub.bias.test[,c(8:10,3:5,7)]

#kable(pub.bias.test, digits = 3, caption = "Table 1. Results from Funnel Asymmetry Tests")
```

**Figure 3. Funnel Plots by Elasticity Grouping**

To correct for publication bias, we implement the _precision-effect estimate with standard error_ (PEESE) method outlined in Stanley and Doucouliagos (2007) in which the variance of the effect sizes is included as one of the moderator variables in a weighted least squares estimation. PEESE is a modified version of the Heckman regression used to address sample selection bias. PEESE uses the heteroscedastic nature of standard errors in a meta-analysis database to capture the relationship between the precision of elasticity estimates and their probability of being published.  
$$\frac{\beta_i}{se_i} = \frac{\alpha_0}{se_i} +\eta_0*se_i+ \sum_{k=1}^K \alpha_i*\frac{X_{i,k}}{se_i} + \epsilon_i$$  
**c) Within-study correlation of residuals**  
Most primary studies produce more than one elasticity estimate. In our database, we find that multiple effect sizes from the same paper typically result from authors reporting results from multiple estimation methods or segmenting their datasets by household characteristics, geographical units, or time periods. Each additional estimate from the same study provides less additional information that an estimate from a different study and should be weighted accordingly in the metaregression.^[We argue that overweighting will be less severe if the metaregression includes moderator variables to capture the various data segments and estimation methods in each paper. We computed the number of "unique" observations in each grouping as those for which at least one of the moderator variables (other than VARIANCE) differs from all the other observations in the grouping. Standard error clustering should be strongest for the subgroups with the lowest fraction of unique observations out of their total number of observations: short-run nontransportation price (23%) and short-run transportation income (38%) elasticities.] Nelson and Kennedy (2009) advise researchers to control for the clustering of standard errors that results from having multiple effect sizes from the same study. Depending on the sample size and number of papers, it sometimes is advisable to just pick the mean estimate from each paper or select a a preferred estimate. Here, such approach would result in very small sample sizes for some of the metaregressions. 

We apply two alternative approaches to control for within-study correlation of residuals. The first approach adds a correction to the standard errors of parameter estimates to control for the correlation among residuals from each study.^[The cluster-robust standard errors were computed using the cluster.vcov function from the _multiwaycov_ package in R. They incorporate degree of freedom corrections to mitigate over-rejection of the null hypothesis in coefficient tests when small number of clusters prevents application of asymptotic theory assumptions. The number of clusters in our database ranges between 13 for short-run income elasticities in non-transportation sectors and 58 for transportation short-run price elasticities.] In what follows, we refer to that specification as weighted-least squares (WLS) with cluster-robust standard errors. Without correction, WLS would tend to underestimate the variance of the estimated model coefficients (Cameron and Miller, 2015). The second variant is a linear mixed effects (LME) specification which acknowledges the presence of study-level clusters in the database more explicity. In the LME specification, model variables and their standard errors have an extra index $j$ that indicates the study (i.e., cluster) to which it belongs and the residual has a study-level component $\nu_j$ and an observation-level component $u_{ij}$.
$$\frac{\beta_{ij}}{se_{ij}} = \frac{\alpha_0}{se_{ij}} +\eta_0*se_{ij}+ \sum_{k=1}^K \alpha_i*\frac{X_{ij,k}}{se_{ij}} + \nu_j+ u_{ij}$$
For each of the 8 metaregressions, we report results from both approaches and perform likelihood ratio tests to select the one providing the best fit. The likelihood ratio tests find that the linear mixed effects estimation is generally preferred except in the 3 metaregressions with less than 20 clusters.  

3.1 Moderator variables
=======================

We used a general-to-specific approach to select moderator variables for the metaregressions. The most general specification included the subset of the moderator variables listed below that are applicable to each elasticity grouping. When the resulting metaregressions showed variance inflation factors (VIFs) above 5 for any of the variables, we dropped one at a time until all the VIFs were below 5 in order to alleviate multicollinearity concerns. 

- *YrAvg.cent* (included in all metaregressions): average year of the period of analysis in the study that produced the elasticity estimate.  

- *SPEEDYRS.cent* (included in long-run elasticity metaregressions): lenght of adjustment period (in years). 

- *Quarterly* (included in short-run elasticity metaregressions): indicator variable that takes the value 1 for elasticity estimates obtained from quarterly data.  

- *Monthly* (included in short-run elasticity metaregressions): indicator variable that takes the value 1 for elasticity estimates obtained from monthly data.  

- *CS* (included in long-run metaregressions): indicator variable that takes the value 1 for elasticity estimates from cross-sectional studies. 

- *CSTS* (included in all metaregressions): indicator variable that takes the value 1 for elasticity estimates from panel data analyses.  

- *Pmax* (included in price elasticity metaregressions) : indicator variable that takes the value 1 if the elasticity is with respect to a new historical price maximum rather than an average elasticity over the full period of analysis.  

- *Ymax* (included in income elasticity metaregressions) : indicator variable that takes the value 1 if the elasticity is with respect to a new historical income maximum rather than an average elasticity over the full period of analysis.  

- *StaticP* (included in price elasticity metaregressions) : indicator variable that takes the value 1 for elasticities estimated using static demand equations (in long-run metaregressions, all cointegration equations are codified with StaticP = 1).  

- *StaticY* (included in income elasticity metaregressions) : indicator variable that takes the value 1 for elasticities estimated using static demand equations (in long-run metaregressions, all cointegration equations are codified with StaticY = 1).  

- *StaticP.CS* (included in short-run price elasticity metaregressions) : interaction dummy that takes the value 1 for elasticities from cross-sectional studies estimated using static demand specifications.  

- *StaticY.CS* (included in short-run income elasticity metaregressions) : interaction dummy that takes the value 1 for elasticities from cross-sectional studies estimated using static demand specifications.  

- *PRICE.1998.cent* (included in transportation sector price elasticity metaregressions): average 1998 price for crude oil (Brent) or the relevant petroleum product in the country/region to which the elasticity refers.^[The cross section of 1998 price data comes from the GIZ survey (https://www.giz.de/expertise/html/4317.html). Although the survey also includes prices for non-transportation related oil consumption, the number of countries with missing observations was large and would have severely cut the sample size for those metaregressions. The year 1998 was chosen because it is close to the average year in our dataset (1992) and covered the most countries out of all the available versions of the GIZ survey conducted in the mid to late 1990s.]  

- *rgdpe_cap.1998.cent* (included in income elasticity metaregressions): 1998 GDP per capita in real terms for the country or group of countries to which the elasticity estimate refers.^[The data source for the 1998 GDP per capita is the Penn World Table, version 9.0 (www.ggdc.net/pwt)]  

- *EndUserP* (included in price, non-transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate is measured with respect to a petroleum product price and 0 if it is an elasticity with respect to the crude oil price.  

- *DslTransp* (included in transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate corresponds to diesel consumption.  

- *VehStk* (included in transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate comes from a study that includes a measure of vehicle stock as one of the explanatory variables for fuel demand.^[Havranek and Kokes(2015) found that studies of gasoline demand omitting this variable result in significantly larger income elasticity values.]  

- *FuelSwitch* (included in non-transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate refers to a product or sector with abundant fuel switching options (residential or electricity generation sectors following the categorization in Dargay and Gately(2010)).  

- *VARIANCE* (included in all metaregressions as correction for publication bias): the variance of the elasticity estimate.  

- *CALC_STERROR* (included in all metaregressions): indicator variable that takes the value 1 if the study did not report the standard error or t-statistic of the elasticity estimate but was calculated instead as a function of the standard error of other estimated coefficients using the Gaussian error propagation formula.^[Given random variables $x$ and $y$ measured with standard errors $\delta(x)$ and $\delta(y)$ and assuming that $x$ and $y$ are uncorrelated, the Gaussian error propagation formula for the standard error of $q=f(x,y)$ is $\delta(q) = \sqrt{(\frac{\partial q}{\partial x}*\delta(x))^2 +(\frac{\partial q}{\partial y}*\delta(y))^2}$] In his meta-analysis of the price elasticity of beer, Nelson (2014) finds that  calculated standard errors tend to be larger than those directly reported in the papers.^[We conducted two tests to evaluate whether calculated standard errors appear to be biased. First, as recommended in Nelson (2014), we regressed standard errors on the elasticities and a dummy that takes the value 1 for calculated standard errors. The estimated coefficients were positive in most cases but only statistically significant for the short-run, transportation income elasticity and the long-run, nontransportation price elasticity. Second, we calculated standard errors for a subset of long-run elasticities for which directly reported standard errors were also available. The ratio of reported to calculated standard errors in that subset was 0.946 and 0.877 for price and income elasticities respectively. These results suggest that calculated standard errors tend to be larger although not by a large amount.] To correct for possible bias, Nelson (2014) introduces a dummy variable in the metaregression that takes the value 1 for calculated standard errors. We use the same approach.  

Continuous variables (except VARIANCE) are centered around the average value within their grouping. For PRICE.1998.cent, centering is around the Brent crude oil price. With centered variables, the metaregression intercept has a straightforward interpretation as the elasticity evaluated at the average values of the continuous variables and zero values for the indicator variables. 

4. Results from metaregression analysis
=======================================

```{r out.table.lrt, eval = FALSE, echo = FALSE, warning = FALSE, message = FALSE, comment = NA}
LRT.table <- matrix(NA, 8, 6)
for (i in 1:length(g8.LRT)){
LRT.table[i,1] <- Type_Sector[i]  
LRT.table[i,2] <- round(g8.LRT[[i]][1, "LogLik"], 3) #log likelihood of the full model 
LRT.table[i,3] <- round(g8.LRT[[i]][2, "LogLik"], 3) #log likelihood of the restricted model
LRT.table[i,4] <- round(g8.LRT[[i]][2, "statistic"], 3) #value of the statistic
LRT.table[i,5] <- abs(g8.LRT[[i]][2, "df"]) #difference in degrees of freedom
LRT.table[i,6] <- round(g8.LRT[[i]][2, "p.value"], 3) #p-value of the statistic
}

LRT.table <- as.data.frame(LRT.table, row.names = FALSE)
colnames(LRT.table) <- c("Grouping","Log.Lik.MLE", "Log.Lik.WLS", "Statistic", "Degrees.of.Freedom", "p.value")
```


```{r out.Tables_PSRTransp, echo = FALSE, warning = FALSE, message = FALSE, comment = NA}

out.tbl.PSR.Transp <- stargazer(g8.modelsEstimated2.raw[[1]], g8.modelsEstimated2.LME.raw[[1]], 
                    se=list(g8.coeffsEstimated2[[1]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    dep.var.labels.include = FALSE,
                    colnames = TRUE, notes = NULL,
                    title="Table 1: Results from short-run price elasticity metaregressions (transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```
In agreement with results from previous meta-analyses of gasoline demand, static model specifications yield larger (in absolute value) short-run price elasticities of transportation demand. The combination of static specification and cross-sectional data leads to even larger elasticities. The estimated coefficient on VehStk is contrary to the idea that elasticities from models accounting explicitly for changes in vehicle stock should be smaller. However, since changes in stock are almost negligible within the length of period (one-year or less) considered in short-run elasticities, this argument seems more relevant for the long-run elasticity metaregressions. There is strong indication of demand responsiveness being positively correlated with price level both when we compare price levels across countries at one point in time (PRICE.1998.cent) and when we compare responsiveness to a new price maximum versus average price responsiveness (Pmax). Finally, the g8.YrAvg.cent variable reveals a decreasing trend on short-run price elasticity of transportation sector over time. Each year away from the sample average year (1993) detracts 0.0044 from the price responsiveness. Neither CALC_STERROR nor VARIANCE have a statistically significant coefficient indicating that 1) publication bias does not remain a concern after controlling for the effect of all other explanatory variables and 2) observations for which the standard error was calculated are not introducing bias into the metaregression. The linear mixed effect model is, according to a likelihood ratio test, the preferred alternative to fit this elasticity data subset.

\pagebreak

```{r out.Tables_PSROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}

out.tbl.PSR.Other <- stargazer(g8.modelsEstimated2.raw[[5]], g8.modelsEstimated2.LME.raw[[5]], 
                    se=list(g8.coeffsEstimated2[[5]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 2: Results from short-run price elasticity metaregressions (non-transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text",model.numbers = FALSE, style="aer")

```
For the short-run price of non-transportation sectors, the two model specifications yield the same results albeit with different standard errors. The linear mixed effects estimation technique does not improve the explanatory power of the model and it is rejected by the likelihood ratio test in favor of the weighted least squares model with cluster-robust standard errors. Panel data studies find smaller price elasticities for the non-transportation fraction of oil demand than those using time series data. The statistically significant estimated coefficient for EndUserP indicates that a 1% increase in the price of a petroleum product triggers a larger demand response than a 1% increase in crude oil price. In addition, elasticity with respect to a new price maximum is larger than the average elasticity across all price levels in the period of analysis.  

```{r out.Tables_PLRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}

out.tbl.PLR.Transp <- stargazer(g8.modelsEstimated2.raw[[2]], g8.modelsEstimated2.LME.raw[[2]], 
                    se=list(g8.coeffsEstimated2[[2]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 3: Results from long-run price elasticity metaregressions (transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```

The likelihood ratio test indicates that the linear mixed effects estimation method is preferred for long-run price elasticities in the transportation sector. If all indicator variables are evaluated at zero and all the continuous variables are at their sample means, the estimated long-run price elasticity of the transportation sector is -0.2621. Elasticity estimates with larger standard errors tend to be greater which is consistent with the presence of publication bias. The estimated coefficients on both Pmax and PRICE.1998.cent are strongly significant and imply large effects. As price level moves away from the crude price level or if it is a new price maximum, the estimated elasticity is tripled relative to the value indicated by the intercept. The estimated coefficient on PRICE.1998.cent is consistent with the idea of higher-income countries being better able to adjust their transportation fuel consumption to increases in oil prices than lower-income countries. All else equal, OECD countries are less responsive to transportation petroleum fuel prices in the long-run. Studies using cross sectional data obtain significantly higher, in absolute value, long-run elasticity estimates for the transportation sector. The estimated coefficient on g8.SPEEDYRS.cent indicates that, for every extra year of adjustment period duration, estimated long-run price elasticity increases by -0.01.

```{r out.Tables_PLROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }

out.tbl.PLR.Other <- stargazer(g8.modelsEstimated2.raw[[6]], g8.modelsEstimated2.LME.raw[[6]], 
                    se=list(g8.coeffsEstimated2[[6]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 4: Results from long-run price elasticity metaregressions (non-transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```
Based on the p-value from a likelihood ratio test, linear mixed effects is the preferred specification for this elasticity grouping. Similar to the findings for the transportation sector, each additional year of response period leads to an increase of elasticity (in absolute value) of 0.015. New price maxima and end-use prices (as opposed to crude oil prices) also increase the estimated elasticity by -0.18 and -0.13 respectively.

```{r out.Tables_YSRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }

out.tbl.YSR.Transp <- stargazer(g8.modelsEstimated2.raw[[3]], g8.modelsEstimated2.LME.raw[[3]], 
                    se=list(g8.coeffsEstimated2[[3]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 5: Results from short-run income elasticity metaregressions (transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```
The likelihood ratio test indicates that inclusion of a study-level random effect is appropriate in the case of the short-run income elasticities for the transportation sector. The baseline elasticity indicated by the intercept is 0.26. One of the attributes of this baseline value is that it corresponds to price elasticities of gasoline demand or overall transportation fuel demand. For diesel, all else equal, the income elasticity is 0.06 larger. Static model specifications result in much higher estimated elasticities. Contrary to the short-run price elasticity results in Table 1, the subset of elasticities obtained from static models using cross sectional data are smaller rather than larger than the average value for all elasticities from static models. Panel data also results on smaller income elasticities than those from studies using time series data. Althought the estimated coefficient on VehStk has the same coefficient as found in previous meta-analyses of gasoline demand (e.g., Espey, 1998; Havranek and Kokes, 2015), it is not statistically significant. The GDP per capita cross sectional variable suggests income elasticity is smaller in high-income countries. On the other hand, within a given country or region, the effect on elasticity of a new maximum income level is positive. However, neither of those two estimated coefficients are statistically significant at the 10% level in the preferred linear mixed effects specification. 

```{r out.Tables_YSROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}

out.tbl.YSR.Other <- stargazer(g8.modelsEstimated2.raw[[7]], g8.modelsEstimated2.LME.raw[[7]], 
                     se=list(g8.coeffsEstimated2[[7]][,2],NULL),
                     column.labels = c("WLS cluster-robust.se","LME"),
                     column.sep.width = "2pt",
                     colnames = TRUE, notes = NULL,
                     title="Table 6: Results from short-run income elasticity metaregressions (non-transportation)",
                     align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                     type="text", model.numbers = FALSE, style="aer")

```
Based on the likelihood ratio test, the linear mixed effects specification is preferred. The only two statistically significant effects are those corresponding to static specification and trend. Using a static model results in much larger income elasticities for this portion of oil demand and elasticity declines by 0.016 per year as we move away from the sample average year (1990). 

```{r out.Tables_YLRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }

out.tbl.YLR.Transp <- stargazer(g8.modelsEstimated2.raw[[4]], g8.modelsEstimated2.LME.raw[[4]], 
                    se=list(g8.coeffsEstimated2[[4]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 7: Results from long-run income elasticity metaregressions (transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```
For long-run income elasticities in the transportation sector, the likelihood ratio test indicates that the linear mixed effects specification is preferred. Results from that preferred specification indicate that the long-run responsiveness of transportation fuel demand to income is almost double for diesel versus gasoline. Studies including vehicle stock as an explanatory variable find, all else equal, smaller elasticities. Elasticities decrease with GDP per capita levels although the effect is not statistically significant. Contrary to what we would expect, long-run income elasticity slightly decreases as the length of the response period increases. The large negative effect of calculated standard errors on effect size is indicative of the missing covariance component in the error propagation formula being sizable in this case.  

```{r out.Tables_YLROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }

out.tbl.YLR.Other <- stargazer(g8.modelsEstimated2.raw[[8]], g8.modelsEstimated2.LME.raw[[8]], 
                    se=list(g8.coeffsEstimated2[[8]][,2],NULL),
                    column.labels = c("WLS cluster-robust.se","LME"),
                    column.sep.width = "2pt",
                    colnames = TRUE, notes = NULL,
                    title="Table 8: Results from long-run income elasticity metaregressions (non-transportation)",
                    align=TRUE, digits =4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
                    type="text", model.numbers = FALSE, style="aer")

```

In this case, the likelihood ratio test indicates that the WLS specification is preferred. The baseline elasticity value implied by the intercept is very similar to the one for the transportation sector as is the bias associated with the lack of direct information on standard errors in the source papers.^[Variance was not included as a moderator variable in this metaregression because the funnel asymmetry test did not find a statistically significant relationship between effect size and precision of the estimate.] The estimated coefficient on g8.YrAvg.cent is indicative of an increasing trend in income elasticity for the demand of petroleum fuels outside of the transportation sector. Income elasticities in response to a historical maximum income are substantially larger than for other income levels. However, when evaluated across a cross-section of countries, long-run income elasticity outside of the transportation sector is lower for countries with higher GDP.

4.1. World oil elasticity demand estimation  
===========================================  

To translate the metaregression results into an estimate of world oil demand elasticity, a further processing step is required. Table 9 displays multiple summary metrics for each of the 8 metaregressions. Fitted means result from computing the sumproduct of the estimated coefficients and the sample mean values of the explanatory variables. The fitted means are generally smaller but not much different from the raw means. The remaining columns in Table 9 display alternative estimated baselines and their standard errors. Each baseline is constructed as the sumproduct of the estimated coefficients and a value of either 0,1, or the sample mean for each of the explanatory variables.^[_g8.YrAvg.cent_, _g8.rgdpe_cap.1998.cent_, _DslTransp_, _FuelSwitch_, _g8.SPEEDYRS.cent_, _CS_, _CSTS_, _OECD_, _Monthly_, and _Quarterly_ are evaluated at their mean values. _StaticP_, _StaticY_, _StaticP.CS_, _StaticY.CS_ are evaluated at 0 for short-run elasticities and at their mean for long-run elasticities. _VehStk_ is evaluated at the mean for short-run elasticities and at zero for long-run elasticities. The rest of the moderator variables are evaluated at zero.] The 3 alternative baselines differ on the values at which price level-related explanatory variables are evaluated. The first baseline _bsl_ should be interpreted as the demand elasticity with respect to the average crude oil price ( _PRICE.1998.cent_ and _EndUserP_ evaluated at zero in the transportation and non-transportation metaregressions respectively and _Pmax_ and _Ymax_ also evaluated at zero). The second baseline _bsl.max_ is the demand elasticity with respect to a new crude oil price maximum or income maximum; it differs from the first in that _Pmax_ and _Ymax_ are evaluated at a value of 1. Finally, the third baseline _bsl.prodpmax_ evaluates _Pmax_, _Ymax_ at one, _PRICE.1998.cent_ at the mean, and _EndUserP_ at 1 and it conveys the demand responsiveness with respect to a new observed maximum in the petroleum product prices paid by final customers. The standard error of the baselines are calculated using the Gaussian error propagation formula. 

\pagebreak

**Table 9. Estimated Elasticities (fitted means and baselines)**

```{r out.tbl.baselines, echo=FALSE}
g8.all_baselinesEstimated.2 <- g8.all_baselinesEstimated[,c("subsetString", "fittedmean", "baseline", "sterror.baseline","baseline.max", "sterror.baseline.max", "baseline.prodpmax", "sterror.baseline.prodpmax")]
g8.all_baselinesEstimated.2 <- rename(g8.all_baselinesEstimated.2, Type_Sector = subsetString, bsl = baseline, st.err = sterror.baseline, bsl.max = baseline.max, st.err.max = sterror.baseline.max, bsl.prodpmax = baseline.prodpmax, st.err.prodpmax = sterror.baseline.prodpmax)

g8.ElastID3 <- c("SR_P_Tr", "SR_P_nonTr","LR-P-Tr", "LR-P-nonTr","SR_Y_Tr", "SR_Y_nonTr","LR-Y-Tr", "LR-Y-nonTr")
g8.ElastIDmatch3 <- data.frame(Type_Sector, g8.ElastID3)
g8.ElastIDmatch3$g8.ElastID3 <- factor(g8.ElastIDmatch3$g8.ElastID3, levels=c("SR_P_Tr", "SR_P_nonTr","LR-P-Tr", "LR-P-nonTr","SR_Y_Tr", "SR_Y_nonTr","LR-Y-Tr", "LR-Y-nonTr"))

g8.all_baselinesEstimated.2 <-merge(g8.all_baselinesEstimated.2, g8.ElastIDmatch3, by="Type_Sector")
g8.all_baselinesEstimated.2 <- rename(g8.all_baselinesEstimated.2, Grouping = g8.ElastID3)

g8.all_baselinesEstimated.2$Grouping <- factor(g8.all_baselinesEstimated.2$Grouping, levels=c("SR_P_Tr", "SR_P_nonTr","LR-P-Tr", "LR-P-nonTr","SR_Y_Tr", "SR_Y_nonTr","LR-Y-Tr", "LR-Y-nonTr"))
g8.all_baselinesEstimated.2 <- g8.all_baselinesEstimated.2[,c(9,2:8)]

kable(g8.all_baselinesEstimated.2, digits = 3)

```

```{r g8.elast_20000, eval=TRUE, include = FALSE}
#Read IEO 2016 data on petroleum consumption by end-use and fuel to compute transportation and non-transportation weights
# g8.worldelastw <- read_excel("auxiliary_inputs_20170829.xlsx", sheet = "cons.weights_IEO2016", col_names = TRUE, skip=4)
# g8.worldelastw <- rename(g8.worldelastw, api.key=`api key`)
# g8.worldelastw <- as.data.frame(g8.worldelastw)
# 
# #Only two rows of data are needed corresponding to api.keys 15-IEO2016.26.Reference-d021916a (liquids consumption in transportation sector) and 15-IEO2016.55.Reference-d021916a (total liquids consumption)
# g8.worldelastw <- subset(g8.worldelastw, api.key =="15-IEO2016.26.Reference-d021916a"|api.key=="15-IEO2016.55.Reference-d021916a")
# g8.worldelastw <- g8.worldelastw[,c(3,5:35)]
# g8.worldelastw.l <- gather(g8.worldelastw, YEAR, VALUE, - api.key)
# g8.worldelastw.l <- spread(g8.worldelastw.l, api.key, VALUE)
# g8.worldelastw.l$Transportation <- g8.worldelastw.l[,2]/g8.worldelastw.l[,3]
# g8.worldelastw.l$Nontransportation <- 1- g8.worldelastw.l$Transportation
# g8.worldelastw.l <- g8.worldelastw.l[,c(1,4,5)] 
# 
# g8.avg.transp.weight <- mean(g8.worldelastw.l$Transportation)
# g8.avg.other.weight <- mean(g8.worldelastw.l$Nontransportation)
# 
# g8.worldelastw2 <- gather(g8.worldelastw.l, Sector, VALUE, -YEAR)
# g8.worldelastw2 <- spread(g8.worldelastw2, YEAR, VALUE)

## These weights combine regional weights from AEO2014 with sectoral weights from IEO2013.
g8.worldelastw <- read_excel("../Data/auxiliary_inputs_20170829.xlsx", sheet = "cons.weights_IEO2013", col_names = TRUE)
g8.worldelastw <- as.data.frame(g8.worldelastw)
g8.worldelastw2 <- gather(g8.worldelastw, Year, VALUE, -Region, -Sector)
g8.worldelastw$RegSect <- paste(g8.worldelastw$Region, g8.worldelastw$Sector, sep = "_")

# Compute slope and intercept for lines relating elasticity to length of run
g8.out_summary <- g8.all_baselinesEstimated[, c("subsetString", "baseline", "sterror.baseline", "mean.SPEEDYRS")]
g8.out_summary$Region <- "1_1_"
g8.out_summary$BaselineType <- "crudep"

g8.out_summary.OECD <- g8.all_baselinesEstimated[, c("subsetString", "baseline.OECD", "sterror.baseline.OECD", "mean.SPEEDYRS.OECD")]
g8.out_summary.OECD$Region <- "1_0_"
g8.out_summary.OECD$BaselineType <- "crudep"
g8.out_summary.OECD <- dplyr::rename(g8.out_summary.OECD, baseline = baseline.OECD, sterror.baseline = sterror.baseline.OECD, mean.SPEEDYRS = mean.SPEEDYRS.OECD)
 
g8.out_summary.nonOECD <- g8.all_baselinesEstimated[, c("subsetString", "baseline.nonOECD", "sterror.baseline.nonOECD", "mean.SPEEDYRS.nonOECD")]
g8.out_summary.nonOECD$Region <- "0_1_"
g8.out_summary.nonOECD$BaselineType <- "crudep"
g8.out_summary.nonOECD <- dplyr::rename(g8.out_summary.nonOECD, baseline = baseline.nonOECD, sterror.baseline = sterror.baseline.nonOECD, mean.SPEEDYRS = mean.SPEEDYRS.nonOECD)

g8.out_summary.max <- g8.all_baselinesEstimated[, c("subsetString", "baseline.max", "sterror.baseline.max", "mean.SPEEDYRS")]
g8.out_summary.max$Region <- "1_1_"
g8.out_summary.max$BaselineType <- "crudepmax"
g8.out_summary.max <- dplyr::rename(g8.out_summary.max, baseline = baseline.max, sterror.baseline = sterror.baseline.max)

g8.out_summary.prodpmax <- g8.all_baselinesEstimated[, c("subsetString", "baseline.prodpmax", "sterror.baseline.prodpmax", "mean.SPEEDYRS")]
g8.out_summary.prodpmax$Region <- "1_1_"
g8.out_summary.prodpmax$BaselineType <- "prodpmax"
g8.out_summary.prodpmax <- dplyr::rename(g8.out_summary.prodpmax, baseline = baseline.prodpmax, sterror.baseline = sterror.baseline.prodpmax)
 
 
g8.out_summary <- rbind(g8.out_summary.OECD, g8.out_summary.nonOECD, g8.out_summary, g8.out_summary.max, g8.out_summary.prodpmax)
g8.out_summary$run <- as.factor(substr(g8.out_summary$subsetString, 3,4))
g8.out_summary$case2 <- as.factor(paste0(substr(g8.out_summary$subsetString,1,2), g8.out_summary$Region, substr(g8.out_summary$subsetString,6,8)))

g8.out_summary <- g8.out_summary[,c("baseline", "sterror.baseline","mean.SPEEDYRS","BaselineType","run","case2")]
g8.out_summary$mean.SPEEDYRS <- as.numeric(g8.out_summary$mean.SPEEDYRS)
#g8.out_summary2 <- reshape2::melt(g8.out_summary, id = c("case2", "run", "BaselineType")) 
g8.out_summary2 <-  g8.out_summary %>%
  gather(variable, value, -case2, -run, -BaselineType)  %>%
  unite(var.run, run, variable, sep = "_") %>%
  spread(var.run, value, fill = 0)
g8.out_summary2$full.label <- paste(g8.out_summary2$case2, g8.out_summary2$BaselineType, sep = "_")

# g8.out_summary2$value <- as.numeric(g8.out_summary2$value)
# g8.out_summary3 <- reshape2::recast(g8.out_summary2, case2 ~ run + variable)
 
 #Linear curve parameters and associated standard errors based on error propagation formula http://courses.washington.edu/phys431/propagation_errors_UCh.pdf
g8.out_summary3 <- mutate(g8.out_summary2, 
                        slope = (LR_baseline - SR_baseline)/(LR_mean.SPEEDYRS - SR_mean.SPEEDYRS),
                        intercept = LR_baseline - (slope * LR_mean.SPEEDYRS),
                        slope.sd = (1/(LR_mean.SPEEDYRS - SR_mean.SPEEDYRS)) * sqrt(LR_sterror.baseline**2 + ((-1*SR_sterror.baseline)**2)),
                        intercept.sd = sqrt(SR_sterror.baseline **2 + ((-SR_mean.SPEEDYRS*slope.sd) **2)),
                        intercept.minus.sd = intercept - 1*intercept.sd,
                        intercept.plus.sd = intercept + 1*intercept.sd,
                        elast = intercept + (slope * 1/12),
                        elast.minus.sd = intercept.minus.sd + (slope * 1/12),
                        elast.plus.sd = intercept.plus.sd + (slope * 1/12)
)
g8.out_summary3$full.label <- NULL

g8.out_summary5 <- g8.out_summary3 %>%
   mutate( type = substr(case2, 1,1),
           region = ifelse(substr(case2, 3,5) == "0_1", "nonOECD",
                           ifelse(substr(case2, 3,5) == "1_0","OECD", "world")),
           sector = ifelse(substr(case2, 7,9) == "0_1", "nontransp", "transp"),
           baselinetype = BaselineType,
           case_label = paste(type, region, sector, sep = "_")  )
g8.out_summary5 <- g8.out_summary5[,c(22,21,3:17)]
g8.out_summary5 <- dplyr::rename(g8.out_summary5, LR_est.baseline = LR_baseline, LR_baseline.sd = LR_sterror.baseline, LR_lengthrun.yrs = LR_mean.SPEEDYRS,
                                      SR_est.baseline = SR_baseline, SR_baseline.sd = SR_sterror.baseline, SR_lengthrun.yrs = SR_mean.SPEEDYRS)
write.csv(g8.out_summary5, "../Output/g8.elast_line_coeffs.csv")

# Simulate confidence intervals for all the baseline world oil elasticities resulting from the preferred (WLS or LME) model estimations. Alternatively, we could construct confidence intervals based on either of the two estimations choosing the appropriate columns for elasticiy baseline and standard error from the g8.all_baselinesEstimated table
g8.intercept = list()
g8.st_error = list()

for(i in 1:nrow(g8.out_summary3)){
g8.intercept[i] <- g8.out_summary3$intercept[i]
g8.st_error[i] <- g8.out_summary3$intercept.sd[i]
}

# Set seed and draw 20000 points out of each of the baseline elasticities
set.seed(14)

g8.elast.sim <- matrix(c(0), 20000, nrow(g8.out_summary3))
colnames(g8.elast.sim) = paste(g8.out_summary3$case2, g8.out_summary3$BaselineType, sep = "_")

for(i in 1:length(g8.intercept)){
#truncated normal distribution
  g8.elast.sim[,i] <- rtruncnorm(20000, a = as.numeric(g8.intercept[i])- 1 * as.numeric(g8.st_error[i]), b = as.numeric(g8.intercept[i])+ 1* as.numeric(g8.st_error[i]), mean = as.numeric(g8.intercept[i]), sd = as.numeric(g8.st_error[i]))
}


#Add rows with more descriptive titles for the simulated elasticities
g8.elast.sim_out <- as.data.frame(rbind(
  c("Price", "Price", "Price", "Price", "Price", "Price", "Income", "Income", "Income", "Income", "Income", "Income",
    "Price", "Price", "Income", "Income","Price", "Price", "Income", "Income"),
  c("nonOECD", "nonOECD", "OECD", "OECD", "world", "world","nonOECD", "nonOECD", "OECD", "OECD", "world", "world",
    "world", "world", "world", "world", "world", "world", "world", "world"),
  c("Non-transportation", "Transportation", "Non-transportation", "Transportation", "Non-transportation", "Transportation", "Non-transportation", "Transportation",
    "Non-transportation", "Transportation", "Non-transportation", "Transportation", "Non-transportation", "Transportation", "Non-transportation", "Transportation",
    "Non-transportation", "Transportation", "Non-transportation", "Transportation"),
  c("crudep", "crudep", "crudep", "crudep", "crudep", "crudep", "crudep", "crudep","crudep","crudep","crudep","crudep",
    "crudepmax", "crudepmax", "crudepmax", "crudepmax", "prodpmax", "prodpmax", "prodpmax", "prodpmax"),
                                      g8.out_summary3$slope, g8.out_summary3$intercept, g8.elast.sim))
rownames(g8.elast.sim_out) = c("Type", "Region", "Sector", "BaselineType","Mean_Slope", "Mean_Intercept", seq(1,nrow(g8.elast.sim),1))


# Export simulated price elasticities for use in BenEStock into .csv
#write.csv(g8.elast.sim_out[,1:nrow(g8.out_summary3)], "g8.sim_DDElasts_Out.csv")
write.csv(g8.elast.sim_out[,c(1:4,7:10)], "../Output/g8.sim_DDElasts_Out.csv")
```

```{r g8.worldelasts, eval=TRUE, include = FALSE}
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities

#### SHORT-RUN PRICE ELASTICITIES
#################################

##based on regional-sectoral baselines
g8.world_P_SR <- matrix(c(0),20000,31) 
for(i in 1:31){
               g8.world_P_SR[,i] = 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "P_0_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_0_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_0_1_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "P_0_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_0_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_0_1_1_0_crudep"]) +
               
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "P_1_0_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_0_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_0_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "P_1_0_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_0_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_0_1_0_crudep"])
}

##based on sectoral baselines
g8.world_P_SR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_SR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_crudep"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_crudep"])
}

##based on sectoral baselines and for crude price maximum
g8.world_P_SR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_SR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_crudepmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_crudepmax"])
}

##based on sectoral baselines and for product price maximum
g8.world_P_SR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_SR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_prodpmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_prodpmax"])
}

#### LONG-RUN PRICE ELASTICITIES
################################

##based on regional-sectoral baselines
g8.world_P_LR <- matrix(c(0),20000,31) 
for(i in 1:31){
                g8.world_P_LR[,i] = 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "P_0_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_0_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_0_1_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "P_0_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_0_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_0_1_1_0_crudep"]) +
               
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "P_1_0_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_0_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_0_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "P_1_0_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_0_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_0_1_0_crudep"]) 
               
}

##based on sectoral baselines
g8.world_P_LR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_LR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_crudep"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_crudep"])
}

##based on sectoral baselines and for crude price maximum
g8.world_P_LR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_LR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_crudepmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_crudepmax"])
}

##based on sectoral baselines and for product price maximum
g8.world_P_LR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_P_LR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_0_1_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_0_1" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_0_1_prodpmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "P_1_1_1_0_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "P_1_1_1_0" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "P_1_1_1_0_prodpmax"])
}

#### SHORT-RUN INCOME ELASTICITIES
##################################

##based on regional-sectoral baselines
g8.world_Y_SR <- matrix(c(0),20000,31) 
for(i in 1:31){
               g8.world_Y_SR[,i] = 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_0_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_0_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_0_1_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_0_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_0_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_0_1_1_0_crudep"]) +
               
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_1_0_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_0_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_0_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_1_0_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_0_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_0_1_0_crudep"])
}

##based on sectoral baselines
g8.world_Y_SR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_SR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_crudep"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_crudep"])
}

##based on sectoral baselines and for crude price maximum
g8.world_Y_SR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_SR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_crudepmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_crudepmax"])
}

##based on sectoral baselines and for product price maximum
g8.world_Y_SR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_SR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_prodpmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$SR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_prodpmax"])
}

#### LONG-RUN INCOME ELASTICITIES
##################################

##based on regional-sectoral baselines
g8.world_Y_LR <- matrix(c(0),20000,31) 
for(i in 1:31){
                g8.world_Y_LR[,i] = 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_0_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_0_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_0_1_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_0_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_0_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_0_1_1_0_crudep"]) +
               
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_1_0_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_0_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_0_0_1_crudep"]) +
                 
               g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)]*
                 (g8.elast.sim[, "Y_1_0_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_0_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_0_1_0_crudep"]) 
               
} 

##based on sectoral baselines
g8.world_Y_LR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_LR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_crudep"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_crudep"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "crudep"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_crudep"])
}

##based on sectoral baselines and for crude price maximum
g8.world_Y_LR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_LR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_crudepmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_crudepmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "crudepmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_crudepmax"])
}

##based on sectoral baselines and for product price maximum
g8.world_Y_LR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_Y_LR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_0_1_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_0_1" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_0_1_prodpmax"]) +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 (g8.elast.sim[, "Y_1_1_1_0_prodpmax"] + 
                    g8.out_summary3$slope[g8.out_summary3$case2 == "Y_1_1_1_0" & g8.out_summary3$BaselineType == "prodpmax"]*g8.out_summary2$LR_mean.SPEEDYRS[g8.out_summary2$full.label == "Y_1_1_1_0_prodpmax"])
}

#####

## Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
 g8.est.world_P_SR <- apply(g8.world_P_SR, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_SR_crudep <- apply(g8.world_P_SR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_SR_crudepmax <- apply(g8.world_P_SR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_SR_prodpmax <- apply(g8.world_P_SR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_P_LR <- apply(g8.world_P_LR, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_LR_crudep <- apply(g8.world_P_LR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_LR_crudepmax <- apply(g8.world_P_LR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_P_LR_prodpmax <- apply(g8.world_P_LR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_Y_SR <- apply(g8.world_Y_SR, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_SR_crudep <- apply(g8.world_Y_SR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_SR_crudepmax <- apply(g8.world_Y_SR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_SR_prodpmax <- apply(g8.world_Y_SR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_Y_LR <- apply(g8.world_Y_LR, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_LR_crudep <- apply(g8.world_Y_LR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_LR_crudepmax <- apply(g8.world_Y_LR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_Y_LR_prodpmax <- apply(g8.world_Y_LR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
##collect the results in a data frame for plotting in ggplot2
 g8.P_SR_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR[1,], middle = g8.est.world_P_SR[2,], upper = g8.est.world_P_SR[3,])
 g8.P_SR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_crudep[1,], middle = g8.est.world_P_SR_crudep[2,], upper = g8.est.world_P_SR_crudep[3,])
 g8.P_SR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_crudepmax[1,], middle = g8.est.world_P_SR_crudepmax[2,], upper = g8.est.world_P_SR_crudepmax[3,])
 g8.P_SR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_prodpmax[1,], middle = g8.est.world_P_SR_prodpmax[2,], upper = g8.est.world_P_SR_prodpmax[3,])
 
 g8.P_LR_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR[1,], middle = g8.est.world_P_LR[2,], upper = g8.est.world_P_LR[3,])
 g8.P_LR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_crudep[1,], middle = g8.est.world_P_LR_crudep[2,], upper = g8.est.world_P_LR_crudep[3,])
 g8.P_LR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_crudepmax[1,], middle = g8.est.world_P_LR_crudepmax[2,], upper = g8.est.world_P_LR_crudepmax[3,])
 g8.P_LR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_prodpmax[1,], middle = g8.est.world_P_LR_prodpmax[2,], upper = g8.est.world_P_LR_prodpmax[3,])
 
 g8.Y_SR_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_SR[1,], middle = g8.est.world_Y_SR[2,], upper = g8.est.world_Y_SR[3,])
 g8.Y_SR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_SR_crudep[1,], middle = g8.est.world_Y_SR_crudep[2,], upper = g8.est.world_Y_SR_crudep[3,])
 g8.Y_SR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_SR_crudepmax[1,], middle = g8.est.world_Y_SR_crudepmax[2,], upper = g8.est.world_Y_SR_crudepmax[3,])
 g8.Y_SR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_SR_prodpmax[1,], middle = g8.est.world_Y_SR_prodpmax[2,], upper = g8.est.world_Y_SR_prodpmax[3,])
 
 g8.Y_LR_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_LR[1,], middle = g8.est.world_Y_LR[2,], upper = g8.est.world_Y_LR[3,])
 g8.Y_LR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_LR_crudep[1,], middle = g8.est.world_Y_LR_crudep[2,], upper = g8.est.world_Y_LR_crudep[3,])
 g8.Y_LR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_LR_crudepmax[1,], middle = g8.est.world_Y_LR_crudepmax[2,], upper = g8.est.world_Y_LR_crudepmax[3,])
 g8.Y_LR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_Y_LR_prodpmax[1,], middle = g8.est.world_Y_LR_prodpmax[2,], upper = g8.est.world_Y_LR_prodpmax[3,])
 
 
g8.P_SR_dat$TypeLength <- "Short-Run Price"
g8.P_SR_crudep_dat$TypeLength <- "Short-Run Price"
g8.P_SR_crudepmax_dat$TypeLength <- "Short-Run Price"
g8.P_SR_prodpmax_dat$TypeLength <- "Short-Run Price"

g8.P_SR_dat$BaselineType <- "crudep_regions"
g8.P_SR_crudep_dat$BaselineType <- "crudep"
g8.P_SR_crudepmax_dat$BaselineType <- "crudepmax"
g8.P_SR_prodpmax_dat$BaselineType <- "prodpmax"

g8.P_LR_dat$TypeLength <- "Long-Run Price"
g8.P_LR_crudep_dat$TypeLength <- "Long-Run Price"
g8.P_LR_crudepmax_dat$TypeLength <- "Long-Run Price"
g8.P_LR_prodpmax_dat$TypeLength <- "Long-Run Price"

g8.P_LR_dat$BaselineType <- "crudep_regions"
g8.P_LR_crudep_dat$BaselineType <- "crudep"
g8.P_LR_crudepmax_dat$BaselineType <- "crudepmax"
g8.P_LR_prodpmax_dat$BaselineType <- "prodpmax"

g8.Y_SR_dat$TypeLength <- "Short-Run Income"
g8.Y_SR_crudep_dat$TypeLength <- "Short-Run Income"
g8.Y_SR_crudepmax_dat$TypeLength <- "Short-Run Income"
g8.Y_SR_prodpmax_dat$TypeLength <- "Short-Run Income"

g8.Y_SR_dat$BaselineType <- "crudep_regions"
g8.Y_SR_crudep_dat$BaselineType <- "crudep"
g8.Y_SR_crudepmax_dat$BaselineType <- "crudepmax"
g8.Y_SR_prodpmax_dat$BaselineType <- "prodpmax"

g8.Y_LR_dat$TypeLength <- "Long-Run Income"
g8.Y_LR_crudep_dat$TypeLength <- "Long-Run Income"
g8.Y_LR_crudepmax_dat$TypeLength <- "Long-Run Income"
g8.Y_LR_prodpmax_dat$TypeLength <- "Long-Run Income"

g8.Y_LR_dat$BaselineType <- "crudep_regions"
g8.Y_LR_crudep_dat$BaselineType <- "crudep"
g8.Y_LR_crudepmax_dat$BaselineType <- "crudepmax"
g8.Y_LR_prodpmax_dat$BaselineType <- "prodpmax"


g8.all.worldelast.p <- rbind(g8.P_SR_dat, g8.P_LR_dat, g8.P_SR_crudep_dat, g8.P_LR_crudep_dat, g8.P_SR_crudepmax_dat, g8.P_LR_crudepmax_dat, g8.P_SR_prodpmax_dat, g8.P_LR_prodpmax_dat)
g8.all.worldelast.p$TypeLength <- as.factor(g8.all.worldelast.p$TypeLength)
g8.all.worldelast.p$TypeLength <- factor(g8.all.worldelast.p$TypeLength, levels = c("Short-Run Price", "Long-Run Price"))
g8.all.worldelast.p$BaselineType <- as.factor(g8.all.worldelast.p$BaselineType)
 
g8.world.elast.p.plot <- ggplot(g8.all.worldelast.p, aes(x=Year, y=middle, color = BaselineType)) + facet_wrap(~TypeLength) +
                  geom_line(data=g8.all.worldelast.p, color = "black")+
                  geom_ribbon(data=g8.all.worldelast.p, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed")+
                  labs(y="Elasticity", x="Year", title = "")+ 
                  theme(axis.text.x=element_text(size=12, angle=90, hjust=1),axis.text.y=element_text(size=12), axis.title=element_text(size=12)) +
                  theme(plot.title=element_text(size=16, face="bold"))+
                  #scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
                  #ylim(-0.20, 0)+
                  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6)) 
g8.world.elast.p.plot

g8.all.worldelast.y <- rbind(g8.Y_SR_dat, g8.Y_LR_dat, g8.Y_SR_crudep_dat, g8.Y_LR_crudep_dat, g8.Y_SR_crudepmax_dat, g8.Y_LR_crudepmax_dat, g8.Y_SR_prodpmax_dat, g8.Y_LR_prodpmax_dat)
#g8.all.worldelast.y <- g8.all.worldelast.y[g8.all.worldelast.y$Year <= 2040,]
g8.all.worldelast.y$TypeLength <- as.factor(g8.all.worldelast.y$TypeLength)
g8.all.worldelast.y$TypeLength <- factor(g8.all.worldelast.y$TypeLength, levels = c("Short-Run Income", "Long-Run Income"))
g8.all.worldelast.y$BaselineType <- as.factor(g8.all.worldelast.y$BaselineType)
 
g8.world.elast.y.plot <- ggplot(g8.all.worldelast.y, aes(x=Year, y=middle, color = BaselineType)) + facet_wrap(~TypeLength) +
                  geom_line(data=g8.all.worldelast.y, color = "black")+
                  geom_ribbon(data=g8.all.worldelast.y, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed")+
                  labs(y="Elasticity", x="Year", title = "")+ 
                  theme(axis.text.x=element_text(size=12, angle=90, hjust=1),axis.text.y=element_text(size=12), axis.title=element_text(size=12)) +
                  theme(plot.title=element_text(size=16, face="bold"))
                  #scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
                  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6)) 
g8.world.elast.y.plot

#Combine price and income plots
require(gridExtra)
g8.world.elast.plot <- grid.arrange(g8.world.elast.p.plot, g8.world.elast.y.plot, ncol=2)
```

```{r g8.IncomeEffects, eval = TRUE, include = FALSE}
# Incorporating income effects into the price elasticity estimate (using a GDP price elasticity of -2.325% , which is the average coming out of the ORNL GDP elasticity meta-analysis. I put it together based on Dave's email from 2014/10/22)
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities 
GDPoilelast <- -0.02

##SHORT_RUN
g8.world_P_SR_withY <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_SR_withY[,i] = g8.world_P_SR[,i] + GDPoilelast * g8.world_Y_SR[,i]}

g8.world_P_SR_withY_crudep <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_SR_withY_crudep[,i] = g8.world_P_SR_crudep[,i] + GDPoilelast * g8.world_Y_SR_crudep[,i]}

g8.world_P_SR_withY_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_SR_withY_crudepmax[,i] = g8.world_P_SR_crudepmax[,i] + GDPoilelast * g8.world_Y_SR_crudepmax[,i]}

g8.world_P_SR_withY_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_SR_withY_prodpmax[,i] = g8.world_P_SR_prodpmax[,i] + GDPoilelast * g8.world_Y_SR_prodpmax[,i]}

##LONG_RUN
g8.world_P_LR_withY <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_LR_withY[,i] = g8.world_P_LR[,i] + GDPoilelast * g8.world_Y_LR[,i]}

g8.world_P_LR_withY_crudep <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_LR_withY_crudep[,i] = g8.world_P_LR_crudep[,i] + GDPoilelast * g8.world_Y_LR_crudep[,i]}

g8.world_P_LR_withY_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_LR_withY_crudepmax[,i] = g8.world_P_LR_crudepmax[,i] + GDPoilelast * g8.world_Y_LR_crudepmax[,i]}

g8.world_P_LR_withY_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_P_LR_withY_prodpmax[,i] = g8.world_P_LR_prodpmax[,i] + GDPoilelast * g8.world_Y_LR_prodpmax[,i]}



# Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
g8.est.world_P_SR_withY <- apply(g8.world_P_SR_withY, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_SR_withY_crudep <- apply(g8.world_P_SR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_SR_withY_crudepmax <- apply(g8.world_P_SR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_SR_withY_prodpmax <- apply(g8.world_P_SR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

g8.est.world_P_LR_withY <- apply(g8.world_P_LR_withY, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_LR_withY_crudep <- apply(g8.world_P_LR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_LR_withY_crudepmax <- apply(g8.world_P_LR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_P_LR_withY_prodpmax <- apply(g8.world_P_LR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))


# Collect the results in a data frame for plotting in ggplot2
g8.P_SR_dat_withY <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_withY[1,], middle = g8.est.world_P_SR_withY[2,], upper = g8.est.world_P_SR_withY[3,])
g8.P_SR_dat_withY_crudep <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_withY_crudep[1,], middle = g8.est.world_P_SR_withY_crudep[2,], upper = g8.est.world_P_SR_withY_crudep[3,])
g8.P_SR_dat_withY_crudepmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_withY_crudepmax[1,], middle = g8.est.world_P_SR_withY_crudepmax[2,], upper = g8.est.world_P_SR_withY_crudepmax[3,])
g8.P_SR_dat_withY_prodpmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_SR_withY_prodpmax[1,], middle = g8.est.world_P_SR_withY_prodpmax[2,], upper = g8.est.world_P_SR_withY_prodpmax[3,])

g8.P_LR_dat_withY <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_withY[1,], middle = g8.est.world_P_LR_withY[2,], upper = g8.est.world_P_LR_withY[3,])
g8.P_LR_dat_withY_crudep <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_withY_crudep[1,], middle = g8.est.world_P_LR_withY_crudep[2,], upper = g8.est.world_P_LR_withY_crudep[3,])
g8.P_LR_dat_withY_crudepmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_withY_crudepmax[1,], middle = g8.est.world_P_LR_withY_crudepmax[2,], upper = g8.est.world_P_LR_withY_crudepmax[3,])
g8.P_LR_dat_withY_prodpmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_P_LR_withY_prodpmax[1,], middle = g8.est.world_P_LR_withY_prodpmax[2,], upper = g8.est.world_P_LR_withY_prodpmax[3,])

g8.P_SR_dat_withY$TypeLength <- "SHORT RUN"
g8.P_SR_dat_withY_crudep$TypeLength <- "SHORT RUN"
g8.P_SR_dat_withY_crudepmax$TypeLength <- "SHORT RUN"
g8.P_SR_dat_withY_prodpmax$TypeLength <- "SHORT RUN"

g8.P_SR_dat_withY$BaselineType <- "CRUDE OIL_REGIONS"
g8.P_SR_dat_withY_crudep$BaselineType <- "CRUDE\nOIL"
g8.P_SR_dat_withY_crudepmax$BaselineType <- "CRUDE\nOIL\nPMAX"
g8.P_SR_dat_withY_prodpmax$BaselineType <- "PETROLEUM\nPRODUCTS\nPMAX"

g8.P_LR_dat_withY$TypeLength <- "LONG RUN"
g8.P_LR_dat_withY_crudep$TypeLength <- "LONG RUN"
g8.P_LR_dat_withY_crudepmax$TypeLength <- "LONG RUN"
g8.P_LR_dat_withY_prodpmax$TypeLength <- "LONG RUN"

g8.P_LR_dat_withY$BaselineType <- "CRUDE OIL_REGIONS"
g8.P_LR_dat_withY_crudep$BaselineType <- "CRUDE\nOIL"
g8.P_LR_dat_withY_crudepmax$BaselineType <- "CRUDE\nOIL\nPMAX"
g8.P_LR_dat_withY_prodpmax$BaselineType <- "PETROLEUM\nPRODUCTS\nPMAX"

#For final plot, I select only one year and leave out the baseline constructed out of regions
g8.all.worldelast.p.withY <- rbind(g8.P_SR_dat_withY_crudep, g8.P_LR_dat_withY_crudep, g8.P_SR_dat_withY_crudepmax, g8.P_LR_dat_withY_crudepmax, g8.P_SR_dat_withY_prodpmax, g8.P_LR_dat_withY_prodpmax)
g8.all.worldelast.p.withY$TypeLength <- factor(g8.all.worldelast.p.withY$TypeLength, levels = c("SHORT RUN", "LONG RUN"))
g8.all.worldelast.p.withY$BaselineType <- factor(g8.all.worldelast.p.withY$BaselineType, levels = c("CRUDE\nOIL", "CRUDE\nOIL\nPMAX", "PETROLEUM\nPRODUCTS\nPMAX"))
g8.all.worldelast.p.withY$middle <- round(g8.all.worldelast.p.withY$middle,3)
g8.all.worldelast.p.withY.2017 <- subset(g8.all.worldelast.p.withY, Year == "2017")

g8.world.elast.p.plot.withY <- ggplot(g8.all.worldelast.p.withY.2017, aes(x=BaselineType, y=middle)) + 
                  facet_wrap(~TypeLength) +
                  geom_point(data=g8.all.worldelast.p.withY.2017, aes(x=BaselineType, y=middle), color = "black") +
                  geom_errorbar(aes(ymin=lower,ymax=upper))+
                  geom_text(aes(label = middle),hjust = 1, vjust = 0.5, size = 3.5, angle = 0, show.legend= FALSE) +
                  #geom_ribbon(data=g8.all.worldelast.p.withY, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed") +
                  labs(y="Elasticity", x="Price Baseline Details", title = "") + 
                  theme(axis.text.x=element_text(size=10), axis.text.y=element_text(size=10), axis.title=element_text(size=10, face="bold")) +
                  theme(plot.title=element_text(size=12, face="bold", hjust=0.5)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
                  #ylim(-0.35, 0.05) +
                  #scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 8)) 
g8.world.elast.p.plot.withY

```

We construct world price and income elasticities as weighted averages of the baseline elasticities of the transportation and non-transportation sectors. The weights are based on oil consumption projections from EIA's International Energy Outlook 2013. Then, we modify the price elasticity to include changes in income as and indirect mechanism by which demand responds to price shocks according to the formula $\epsilon_{D,P}^*=\epsilon_{D,P} + \epsilon_{D,Y}*\epsilon_{GDP,P}$ where $\epsilon_{A,B}$ is the elasticity of $A$ with respect to $B$, $D$ is demand, $P$ is price, $Y$ is income, and $GDP$ is gross domestic product. Using a value of -0.02 for the elasticity of GDP with respect to oil price $\epsilon_{GDP,P}$ (DOE, 2016), this additional component does not increase the price elasticity value significantly. 
The mean and 68% confidence interval for the world oil demand price elasticities (based on results from 20,000 random draws from normal distributions truncated at mean +/- one standard deviation for each of the 8 type-sector baselines) using 2017 consumption weights (56% transportation and 44% non-transportation) are shown in Figure 4. All the elasticities in Figure 4 are evaluated at the average length of run of the elasticity data points included in the metaregression analysis. The average length of run is 0.9 and 11.3 years for the short-run and long-run elasticities respectively.  

```{r g8.worldelasts2, eval=TRUE, include = FALSE}
#Produce another version of the plot based directly on the elasticity baselines and their standard errors (rather than the standard errors of the intercept term only)

##Focus on sectoral baselines only
g8.out_summaryb <- subset(g8.out_summary, case2 == "P_1_1_0_1" | case2 == "P_1_1_1_0"| case2 == "Y_1_1_0_1" | case2 == "Y_1_1_1_0")
g8.out_summaryb$caserun <- paste(g8.out_summaryb$case2,g8.out_summaryb$run, g8.out_summaryb$BaselineType, sep = "_" )

# Simulate confidence intervals for all the baseline world oil elasticities 
g8.baseline = list()
g8.sterror = list()

for(i in 1:nrow(g8.out_summaryb)){
g8.baseline[i] <- g8.out_summaryb$baseline[i]
g8.sterror[i] <- g8.out_summaryb$sterror.baseline[i]
}

# Set seed and draw 20000 points out of each of the baseline elasticities
set.seed(14)

g8.elast.simb <- matrix(c(0), 20000, nrow(g8.out_summaryb))
colnames(g8.elast.simb) = g8.out_summaryb$caserun

for(i in 1:length(g8.baseline)){
#truncated normal distribution
  g8.elast.simb[,i] <- rtruncnorm(20000, a = as.numeric(g8.baseline[i])- 1 * as.numeric(g8.sterror[i]), b = as.numeric(g8.baseline[i])+ 1* as.numeric(g8.sterror[i]), mean = as.numeric(g8.baseline[i]), sd = as.numeric(g8.sterror[i]))
}

# For each draw, compute weighted averages to obtain the predicted baseline world elasticities

#### SHORT-RUN PRICE ELASTICITIES
#################################

##based on sectoral baselines
g8.world_PSR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PSR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_SR_crudep"] +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_SR_crudep"] 
                    
}

##based on sectoral baselines and for crude price maximum
g8.world_PSR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PSR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_SR_crudepmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_SR_crudepmax"] 
}

##based on sectoral baselines and for product price maximum
g8.world_PSR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PSR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_SR_prodpmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_SR_prodpmax"] 
}

#### LONG-RUN PRICE ELASTICITIES
################################

##based on sectoral baselines
g8.world_PLR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PLR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_LR_crudep"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_LR_crudep"]  
}

##based on sectoral baselines and for crude price maximum
g8.world_PLR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PLR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_LR_crudepmax"] +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_LR_crudepmax"] 
}

##based on sectoral baselines and for product price maximum
g8.world_PLR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_PLR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_0_1_LR_prodpmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "P_1_1_1_0_LR_prodpmax"] 
}

#### SHORT-RUN INCOME ELASTICITIES
##################################

##based on sectoral baselines
g8.world_YSR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YSR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_SR_crudep"] +
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_SR_crudep"] 
}

##based on sectoral baselines and for crude price maximum
g8.world_YSR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YSR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_SR_crudepmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_SR_crudepmax"] 
}

##based on sectoral baselines and for product price maximum
g8.world_YSR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YSR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_SR_prodpmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_SR_prodpmax"] 
}

#### LONG-RUN INCOME ELASTICITIES
##################################

##based on sectoral baselines
g8.world_YLR_crudep <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YLR_crudep[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_LR_crudep"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_LR_crudep"]
}

##based on sectoral baselines and for crude price maximum
g8.world_YLR_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YLR_crudepmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_LR_crudepmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_LR_crudepmax"] 
}

##based on sectoral baselines and for product price maximum
g8.world_YLR_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){
               g8.world_YLR_prodpmax[,i] = 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Non-transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Non-transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_0_1_LR_prodpmax"] + 
               (g8.worldelastw[g8.worldelastw$RegSect =="non_OECD_Transportation",c(i+2)] + 
                g8.worldelastw[g8.worldelastw$RegSect =="OECD_Transportation",c(i+2)])*
                 g8.elast.simb[, "Y_1_1_1_0_LR_prodpmax"]
}

#####

## Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
 g8.est.world_PSR_crudep <- apply(g8.world_PSR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_PSR_crudepmax <- apply(g8.world_PSR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_PSR_prodpmax <- apply(g8.world_PSR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_PLR_crudep <- apply(g8.world_PLR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_PLR_crudepmax <- apply(g8.world_PLR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_PLR_prodpmax <- apply(g8.world_PLR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_YSR_crudep <- apply(g8.world_YSR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_YSR_crudepmax <- apply(g8.world_YSR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_YSR_prodpmax <- apply(g8.world_YSR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
 g8.est.world_YLR_crudep <- apply(g8.world_YLR_crudep, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_YLR_crudepmax <- apply(g8.world_YLR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
 g8.est.world_YLR_prodpmax <- apply(g8.world_YLR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))
 
##collect the results in a data frame for plotting in ggplot2
 g8.PSR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_crudep[1,], middle = g8.est.world_PSR_crudep[2,], upper = g8.est.world_PSR_crudep[3,])
 g8.PSR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_crudepmax[1,], middle = g8.est.world_PSR_crudepmax[2,], upper = g8.est.world_PSR_crudepmax[3,])
 g8.PSR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_prodpmax[1,], middle = g8.est.world_PSR_prodpmax[2,], upper = g8.est.world_PSR_prodpmax[3,])
 
 g8.PLR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_crudep[1,], middle = g8.est.world_PLR_crudep[2,], upper = g8.est.world_PLR_crudep[3,])
 g8.PLR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_crudepmax[1,], middle = g8.est.world_PLR_crudepmax[2,], upper = g8.est.world_PLR_crudepmax[3,])
 g8.PLR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_prodpmax[1,], middle = g8.est.world_PLR_prodpmax[2,], upper = g8.est.world_PLR_prodpmax[3,])
 
 g8.YSR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YSR_crudep[1,], middle = g8.est.world_YSR_crudep[2,], upper = g8.est.world_YSR_crudep[3,])
 g8.YSR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YSR_crudepmax[1,], middle = g8.est.world_YSR_crudepmax[2,], upper = g8.est.world_YSR_crudepmax[3,])
 g8.YSR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YSR_prodpmax[1,], middle = g8.est.world_YSR_prodpmax[2,], upper = g8.est.world_YSR_prodpmax[3,])
 
 g8.YLR_crudep_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YLR_crudep[1,], middle = g8.est.world_YLR_crudep[2,], upper = g8.est.world_YLR_crudep[3,])
 g8.YLR_crudepmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YLR_crudepmax[1,], middle = g8.est.world_YLR_crudepmax[2,], upper = g8.est.world_YLR_crudepmax[3,])
 g8.YLR_prodpmax_dat <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_YLR_prodpmax[1,], middle = g8.est.world_YLR_prodpmax[2,], upper = g8.est.world_YLR_prodpmax[3,])
 
 
g8.PSR_crudep_dat$TypeLength <- "Short-Run Price"
g8.PSR_crudepmax_dat$TypeLength <- "Short-Run Price"
g8.PSR_prodpmax_dat$TypeLength <- "Short-Run Price"

g8.PSR_crudep_dat$BaselineType <- "crudep"
g8.PSR_crudepmax_dat$BaselineType <- "crudepmax"
g8.PSR_prodpmax_dat$BaselineType <- "prodpmax"

g8.PLR_crudep_dat$TypeLength <- "Long-Run Price"
g8.PLR_crudepmax_dat$TypeLength <- "Long-Run Price"
g8.PLR_prodpmax_dat$TypeLength <- "Long-Run Price"

g8.PLR_crudep_dat$BaselineType <- "crudep"
g8.PLR_crudepmax_dat$BaselineType <- "crudepmax"
g8.PLR_prodpmax_dat$BaselineType <- "prodpmax"

g8.YSR_crudep_dat$TypeLength <- "Short-Run Income"
g8.YSR_crudepmax_dat$TypeLength <- "Short-Run Income"
g8.YSR_prodpmax_dat$TypeLength <- "Short-Run Income"

g8.YSR_crudep_dat$BaselineType <- "crudep"
g8.YSR_crudepmax_dat$BaselineType <- "crudepmax"
g8.YSR_prodpmax_dat$BaselineType <- "prodpmax"

g8.YLR_crudep_dat$TypeLength <- "Long-Run Income"
g8.YLR_crudepmax_dat$TypeLength <- "Long-Run Income"
g8.YLR_prodpmax_dat$TypeLength <- "Long-Run Income"

g8.YLR_crudep_dat$BaselineType <- "crudep"
g8.YLR_crudepmax_dat$BaselineType <- "crudepmax"
g8.YLR_prodpmax_dat$BaselineType <- "prodpmax"


g8.worldelast.p <- rbind(g8.PSR_crudep_dat, g8.PLR_crudep_dat, g8.PSR_crudepmax_dat, g8.PLR_crudepmax_dat, g8.PSR_prodpmax_dat, g8.PLR_prodpmax_dat)
g8.worldelast.p$TypeLength <- as.factor(g8.worldelast.p$TypeLength)
g8.worldelast.p$TypeLength <- factor(g8.worldelast.p$TypeLength, levels = c("Short-Run Price", "Long-Run Price"))
g8.worldelast.p$BaselineType <- as.factor(g8.worldelast.p$BaselineType)
 
g8.world.elastp.plot <- ggplot(g8.worldelast.p, aes(x=Year, y=middle, color = BaselineType)) + facet_wrap(~TypeLength) +
                  geom_line(data=g8.worldelast.p, color = "black")+
                  geom_ribbon(data=g8.worldelast.p, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed")+
                  labs(y="Elasticity", x="Year", title = "")+ 
                  theme(axis.text.x=element_text(size=12, angle=90, hjust=1),axis.text.y=element_text(size=12), axis.title=element_text(size=12)) +
                  theme(plot.title=element_text(size=16, face="bold"))+
                  #scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
                  #ylim(-0.20, 0)+
                  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6)) 
g8.world.elastp.plot

g8.worldelast.y <- rbind(g8.YSR_crudep_dat, g8.YLR_crudep_dat, g8.YSR_crudepmax_dat, g8.YLR_crudepmax_dat, g8.YSR_prodpmax_dat, g8.YLR_prodpmax_dat)
g8.worldelast.y$TypeLength <- as.factor(g8.worldelast.y$TypeLength)
g8.worldelast.y$TypeLength <- factor(g8.worldelast.y$TypeLength, levels = c("Short-Run Income", "Long-Run Income"))
g8.worldelast.y$BaselineType <- as.factor(g8.worldelast.y$BaselineType)
 
g8.world.elasty.plot <- ggplot(g8.worldelast.y, aes(x=Year, y=middle, color = BaselineType)) + facet_wrap(~TypeLength) +
                  geom_line(data=g8.worldelast.y, color = "black")+
                  geom_ribbon(data=g8.worldelast.y, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed")+
                  labs(y="Elasticity", x="Year", title = "")+ 
                  theme(axis.text.x=element_text(size=12, angle=90, hjust=1),axis.text.y=element_text(size=12), axis.title=element_text(size=12)) +
                  theme(plot.title=element_text(size=16, face="bold"))
                  #scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
                  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6)) 
g8.world.elasty.plot

#Combine price and income plots
require(gridExtra)
g8.worldelast.plot <- grid.arrange(g8.world.elastp.plot, g8.world.elasty.plot, ncol=2)

# Incorporating income effects into the price elasticity estimate (using a GDP price elasticity of -2.325% , which is the average coming out of the ORNL GDP elasticity meta-analysis. I put it together based on Dave's email from 2014/10/22)
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities 
GDPoilelast <- -0.02

##SHORT_RUN
g8.world_PSR_withY_crudep <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PSR_withY_crudep[,i] = g8.world_PSR_crudep[,i] + GDPoilelast * g8.world_YSR_crudep[,i]}

g8.world_PSR_withY_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PSR_withY_crudepmax[,i] = g8.world_PSR_crudepmax[,i] + GDPoilelast * g8.world_YSR_crudepmax[,i]}

g8.world_PSR_withY_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PSR_withY_prodpmax[,i] = g8.world_PSR_prodpmax[,i] + GDPoilelast * g8.world_YSR_prodpmax[,i]}

##LONG_RUN
g8.world_PLR_withY_crudep <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PLR_withY_crudep[,i] = g8.world_PLR_crudep[,i] + GDPoilelast * g8.world_YLR_crudep[,i]}

g8.world_PLR_withY_crudepmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PLR_withY_crudepmax[,i] = g8.world_PLR_crudepmax[,i] + GDPoilelast * g8.world_YLR_crudepmax[,i]}

g8.world_PLR_withY_prodpmax <- matrix(c(0),20000,31)
for(i in 1:31){g8.world_PLR_withY_prodpmax[,i] = g8.world_PLR_prodpmax[,i] + GDPoilelast * g8.world_YLR_prodpmax[,i]}



# Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
g8.est.world_PSR_withY_crudep <- apply(g8.world_PSR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_PSR_withY_crudepmax <- apply(g8.world_PSR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_PSR_withY_prodpmax <- apply(g8.world_PSR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

g8.est.world_PLR_withY_crudep <- apply(g8.world_PLR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_PLR_withY_crudepmax <- apply(g8.world_PLR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
g8.est.world_PLR_withY_prodpmax <- apply(g8.world_PLR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))


# Collect the results in a data frame for plotting in ggplot2

g8.PSR_dat_withY_crudep <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_withY_crudep[1,], middle = g8.est.world_PSR_withY_crudep[2,], upper = g8.est.world_PSR_withY_crudep[3,])
g8.PSR_dat_withY_crudepmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_withY_crudepmax[1,], middle = g8.est.world_PSR_withY_crudepmax[2,], upper = g8.est.world_PSR_withY_crudepmax[3,])
g8.PSR_dat_withY_prodpmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PSR_withY_prodpmax[1,], middle = g8.est.world_PSR_withY_prodpmax[2,], upper = g8.est.world_PSR_withY_prodpmax[3,])

g8.PLR_dat_withY_crudep <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_withY_crudep[1,], middle = g8.est.world_PLR_withY_crudep[2,], upper = g8.est.world_PLR_withY_crudep[3,])
g8.PLR_dat_withY_crudepmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_withY_crudepmax[1,], middle = g8.est.world_PLR_withY_crudepmax[2,], upper = g8.est.world_PLR_withY_crudepmax[3,])
g8.PLR_dat_withY_prodpmax <- data.frame(Year = seq(2010,2040,1), lower = g8.est.world_PLR_withY_prodpmax[1,], middle = g8.est.world_PLR_withY_prodpmax[2,], upper = g8.est.world_PLR_withY_prodpmax[3,])

g8.PSR_dat_withY_crudep$TypeLength <- "SHORT RUN"
g8.PSR_dat_withY_crudepmax$TypeLength <- "SHORT RUN"
g8.PSR_dat_withY_prodpmax$TypeLength <- "SHORT RUN"

g8.PSR_dat_withY_crudep$BaselineType <- "CRUDE\nOIL"
g8.PSR_dat_withY_crudepmax$BaselineType <- "CRUDE\nOIL\nPMAX"
g8.PSR_dat_withY_prodpmax$BaselineType <- "PETROLEUM\nPRODUCTS\nPMAX"

g8.PLR_dat_withY_crudep$TypeLength <- "LONG RUN"
g8.PLR_dat_withY_crudepmax$TypeLength <- "LONG RUN"
g8.PLR_dat_withY_prodpmax$TypeLength <- "LONG RUN"

g8.PLR_dat_withY_crudep$BaselineType <- "CRUDE\nOIL"
g8.PLR_dat_withY_crudepmax$BaselineType <- "CRUDE\nOIL\nPMAX"
g8.PLR_dat_withY_prodpmax$BaselineType <- "PETROLEUM\nPRODUCTS\nPMAX"

#For final plot, I select only one year and leave out the baseline constructed out of regions# For each draw, compute weighted averages to obtain the predicted baseline world elasticities
g8.worldelast.p.withY <- rbind(g8.PSR_dat_withY_crudep, g8.PSR_dat_withY_crudepmax, g8.PSR_dat_withY_prodpmax,
                               g8.PLR_dat_withY_crudep, g8.PLR_dat_withY_crudepmax, g8.PLR_dat_withY_prodpmax)
g8.worldelast.p.withY$TypeLength <- factor(g8.worldelast.p.withY$TypeLength, levels = c("SHORT RUN", "LONG RUN"))

TypeLength <- c("SHORT RUN", "LONG RUN")
TypeLength2 <- c("SHORT RUN (~1 YEAR)", "LONG RUN (~10 YEARS)")
TypeLengthmatch <- data.frame(TypeLength, TypeLength2)

g8.worldelast.p.withY <- merge(g8.worldelast.p.withY, TypeLengthmatch, by = "TypeLength")

g8.worldelast.p.withY$BaselineType <- factor(g8.worldelast.p.withY$BaselineType, levels = c("CRUDE\nOIL", "CRUDE\nOIL\nPMAX", "PETROLEUM\nPRODUCTS\nPMAX"))
g8.worldelast.p.withY$TypeLength2 <- factor(g8.worldelast.p.withY$TypeLength2, levels = c("SHORT RUN (~1 YEAR)", "LONG RUN (~10 YEARS)"))
  
g8.worldelast.p.withY$middle <- round(g8.worldelast.p.withY$middle,3)
g8.worldelast.p.withY.2017 <- subset(g8.worldelast.p.withY, Year == "2017")

g8.world.elastp.plot.withY <- ggplot(g8.worldelast.p.withY.2017, aes(x=BaselineType, y=middle)) + 
                  facet_wrap(~TypeLength2) +
                  geom_point(data=g8.worldelast.p.withY.2017, aes(x=BaselineType, y=middle), color = "black") +
                  geom_errorbar(aes(ymin=lower,ymax=upper), width = 0.3)+
                  geom_text(aes(label = middle),hjust = -0.2, vjust = 0.5, size = 3.2, angle = 0, show.legend= FALSE) +
                  #geom_ribbon(data=g8.all.worldelast.p.withY, aes(ymin=lower, ymax=upper), alpha = 0.3) +
                  geom_hline(yintercept=0,linetype="dashed") +
                  labs(y="Elasticity", x="Price Baseline Details", title = "") + 
                  theme(axis.text.x=element_text(size=10), axis.text.y=element_text(size=10), axis.title=element_text(size=10, face="bold")) +
                  theme(plot.title=element_text(size=12, face="bold", hjust=0.5)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
                  #ylim(-0.35, 0.05) +
                  #scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 8)) 
g8.world.elastp.plot.withY
ggsave("../Output/g8.world.elastp.plot.withY.png", width=6.5, height=4.5, units="in", dpi=600)

```

```{r outworldelastplot, fig.width=6.5, fig.height=4, echo = FALSE}
g8.all.worldelast.p.withY.2017 <- g8.all.worldelast.p.withY[g8.all.worldelast.p.withY$Year == "2017" ,] 
#kable(g8.all.worldelast.p.withY.2017, digits = 3, caption="Estimated World Oil Demand Elasticities")

g8.world.elastp.plot.withY
```

**Figure 4. Estimated short-run and long-run world oil demand elasticities with respect to price (including income effect)**




```{r WorldElast.compare, eval = TRUE, include=FALSE, echo=FALSE}
#Select papers that provide world elasticity of oil demand
world.elasts <- filter(allelast.excluded, REG =="World" & REFERENCE != "BurkeNishitateno2013") %>%
  select(one_of(c("REFERENCE", "BETA", "ST_ERROR", "TYPE", "TYPE_LENGTH2", "AVGYR", "NOTES1")))
##Note: I remove Burke & Nishitateno because it computes world elasticities only for the transportation sector.

#Add column to distinguish which elasticities are elasticities in production (as defined by Killian and Murphy)
world.elasts$elast.in.prod <- ifelse (world.elasts$NOTES1 == "elasticity in use", "elasticity in use", "elasticity in production")
world.elasts <- select(world.elasts, one_of(c("REFERENCE", "BETA", "ST_ERROR", "TYPE", "TYPE_LENGTH2", "AVGYR", "elast.in.prod")))

#For the purposes of this qualitative comparison, recover observations that were dropped because they were long-run elasticities for which the length of run could not be determined.
world.elasts.NAspeed <- filter(allelast.NAspeed, REGION =="World") %>%
  select(one_of(c("REFERENCE", "BETA", "ST_ERROR", "VAR_SYMBOL", "YEAR_START", "YEAR_END")))
world.elasts.NAspeed$TYPE <- as.factor(substr(world.elasts.NAspeed$VAR_SYMBOL, 1,1))
world.elasts.NAspeed$LENGTH <- as.factor(ifelse(world.elasts.NAspeed$VAR_SYMBOL == "P"|world.elasts.NAspeed$VAR_SYMBOL == "Y", "LR", "SR"))
world.elasts.NAspeed$TYPE_LENGTH2 <- as.factor(paste0(world.elasts.NAspeed$TYPE, "_", world.elasts.NAspeed$LENGTH))
world.elasts.NAspeed$AVGYR <- as.numeric((world.elasts.NAspeed$YEAR_END + world.elasts.NAspeed$YEAR_START)/2)
world.elasts.NAspeed$elast.in.prod <- "elasticity in production"
world.elasts.NAspeed<- world.elasts.NAspeed[,c("REFERENCE", "BETA", "ST_ERROR", "TYPE", "TYPE_LENGTH2", "AVGYR", "elast.in.prod")]

world.elasts.all <- rbind(world.elasts, world.elasts.NAspeed)

g8.worldelast.p.withY
#Add rows to include the elasticitiy values (mean and standard error) from the ORNL meta-analysis 
#Note: These are all elasticities with respect to crude oil price so I will not include the baseline depicting elasticity with respect to product prices
ornl.elasts <- as.data.frame(matrix(0, ncol = 7, nrow = 2))
colnames(ornl.elasts) <- c("REFERENCE", "BETA", "ST_ERROR", "TYPE", "TYPE_LENGTH2", "AVGYR", "elast.in.prod")
ornl.elasts$REFERENCE <- c("metaregression", "metaregression")
ornl.elasts$BETA[1] <- g8.worldelast.p.withY$middle[g8.worldelast.p.withY$Year == "2017" & g8.worldelast.p.withY$TypeLength == "SHORT RUN" & g8.worldelast.p.withY$BaselineType == "CRUDE\nOIL"]
ornl.elasts$BETA[2] <- g8.worldelast.p.withY$middle[g8.worldelast.p.withY$Year == "2017" & g8.worldelast.p.withY$TypeLength == "SHORT RUN" & g8.worldelast.p.withY$BaselineType == "CRUDE\nOIL\nPMAX"]

ornl.elasts$ST_ERROR[1] <- ornl.elasts$BETA[1] - g8.worldelast.p.withY$lower[g8.worldelast.p.withY$Year == "2017" & g8.worldelast.p.withY$TypeLength == "SHORT RUN" & g8.worldelast.p.withY$BaselineType == "CRUDE\nOIL"]
ornl.elasts$ST_ERROR[2] <- ornl.elasts$BETA[1] - g8.worldelast.p.withY$lower[g8.worldelast.p.withY$Year == "2017" & g8.worldelast.p.withY$TypeLength == "SHORT RUN" & g8.worldelast.p.withY$BaselineType == "CRUDE\nOIL\nPMAX"]

ornl.elasts$TYPE <- c("P","P")
ornl.elasts$TYPE_LENGTH2 <- c("P_SR","P_SR")

ornl.elasts$REFERENCE <- as.factor(ornl.elasts$REFERENCE)
ornl.elasts$TYPE <- as.factor(ornl.elasts$TYPE)
ornl.elasts$TYPE_LENGTH2 <- as.factor(ornl.elasts$TYPE_LENGTH2)

ornl.elasts$AVGYR <- mean(allelast$AVGYR[allelast$ELASTICITY == "1" & allelast$TYPE_LENGTH2 == "P_SR"]) 
#ornl.elasts$AVGYR[2] <- mean(allelast$AVGYR[allelast$ELASTICITY == "1" & allelast$TYPE_LENGTH2 == "P_SR"]) 

ornl.elasts$elast.in.prod <- c("elasticity in use","elasticity in use")

world.elasts.with.ORNLmetareg <- rbind(world.elasts.all, ornl.elasts)
world.elasts.with.ORNLmetareg$elast.in.prod <- as.factor(world.elasts.with.ORNLmetareg$elast.in.prod)
#world.elasts.with.ORNLmetareg$elast.in.prod[world.elasts.with.ORNLmetareg$REFERENCE == "IMF2011"] <- ""

world.elasts.with.ORNLmetareg$TYPE_LENGTH3 <- ifelse(world.elasts.with.ORNLmetareg$TYPE_LENGTH2 == "P_SR", "Short-Run", "Long-Run")
world.elasts.with.ORNLmetareg$TYPE_LENGTH3 <- factor(world.elasts.with.ORNLmetareg$TYPE_LENGTH3, levels = c("Short-Run", "Long-Run"))

world.elast.compare.plot <- ggplot(world.elasts.with.ORNLmetareg[world.elasts.with.ORNLmetareg$TYPE_LENGTH2 == "P_SR",], aes(x=AVGYR, y=BETA, shape = elast.in.prod)) + 
  geom_point(aes(x=AVGYR, y=BETA), size = 2) + 
  geom_errorbar(aes(ymin=BETA - ST_ERROR, ymax=BETA + ST_ERROR, color = REFERENCE), width=.2) +
  #facet_wrap(~TYPE_LENGTH3, ncol = 1) + 
  scale_color_manual(values = c("red", "green3", "cyan","magenta", "orange","pink","black","grey")) + 
  scale_shape_manual(values = c(1,2)) + 
  scale_x_continuous(limits = c(1974,2010),breaks = pretty_breaks(n = 10)) + 
  scale_y_continuous(breaks = pretty_breaks(n = 10)) + 
  labs(x="Average Year", y="Elasticity", title="", color="Reference", shape="Elasticity Type") + 
  theme(strip.text.x = element_text(size = 10)) + 
  theme(plot.title=element_text(size=12, face="bold", hjust=0.5)) +
  theme(axis.text.x=element_text(size=10, angle=0, hjust=0.5),axis.text.y=element_text(size=10), axis.title=element_text(size=11,face="bold")) +
  theme(legend.text=element_text(size=10), legend.title=element_text(size=10, face = "bold"), legend.key=element_blank(), legend.position = "right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill=NA, size=1))  
world.elast.compare.plot
ggsave("../Output/world.elast.compare.plot.png", width=6.5, height=4.5, units="in", dpi=600)
```

4.2. Comparison to other world elasticity estimates
===================================================

Figure 5 places the world oil demand elasticities (with respect to crude oil price or a new crude oil price maximum) from the metaregression in the context of other world oil demand elasticity estimates in the literature and highlights attributes that can help understanding and, to some extent, reconciling the large differences in value. 

```{r out_elastcompare, echo = FALSE, warning = FALSE}
world.elast.compare.plot
```

**Figure 5. Short-run price elasticities of world oil demand (metaregression vs. other published results)**


First, elasticities in production tend to overstate demand responsiveness because they do not take into account the smoothing role of inventories. Except for IMF(2011), all other primary studies in Figure 5 use systems of equations: simultaneous equations (Krichene, 2002; Askari and Krichene, 2010), structural VARs (Baumeister and Peersman, 2013; Kilian and Murphy, 2014) or a dynamic stochastic general equilibrium model (Bodenstein and Guerrieri, 2011). In all those systems, the quantity variable is based on oil production data. Thus, they are elasticities-in-production because they equate change in consumption with change in oil output. Kilian and Murphy (2014) address this shortcoming by also computing a substantially smaller (-0.26 versus -0.44 for the elasticity-in-production) elasticity-in-use.^[Krichene (2002) and Askari and Krichene (2010) are exceptions to the otherwise larger elasticities-in-production summarized in Figure 5. However, their authors acknowledge the limitations of their two-stage least squares approach which takes GDP, natural gas prices, and exchange rates as exogenous. These estimates might be downward-biased due to endogeneity bias.] In contrast, the majority of studies included in the metaregression (as well as IMF(2011)) use reduced form equations with oil consumption as the dependent variable.

Second, studies that considered the possibility of time-varying elasticities find oil demand elasticity to be declining over time (e.g., Baumeister and Peersman, 2013; Askari and Krichene, 2010). The oil market has experienced structural changes since the 1970s that have reduced oil demand responsiveness: the advent of liquid spot and future markets where participants can hedge their physical positions (Baumeister & Peersman, 2013); the reduced ability of the OECD non-transportation sector to substitute or reduce oil consumption after having taken advantage of "low hanging fruit" adjustments in the wake of the oil crises of the 1970s (Dargay and Gately, 2010); a given reduction in miles traveled provides progressively smaller fuel savings as vehicle fuel efficiency improves (Hughes et al., 2008). Thus, papers that compute a single elasticity over the long time period including the 1970s and early 1980s will likely obtain a larger elasticity than those starting later or allowing elasticity to vary over time. 

Third, oil demand elasticities recovered from SVAR impulse response functions represent responses to shocks and those shocks are normalized to always result in an oil price increase. In contrast, elasticities estimated using reduced form equations typically correspond to the average responsiveness over shocked and unshocked periods and various types of shocks implying oil price increases and decreases. The strong effect of the Pmax variable in the metaregressions is consistent with a larger responsiveness during a specific type of price increase. Relatedly, IMF(2011) finds world oil elasticity for the subset of observations in which price level was above the average price level (-0.038) to be double the average elasticity for the full price history (-0.019). 

Not all authors using SVARs agree regarding the magnitude of oil demand elasticities. Imposing bounds on the value of oil demand elasticity has become a common part of the strategy for identification of structural parameters in SVAR oil market models. As shown in Caldara et al. (2016), the two observed patterns of 1) larger volatility in oil prices than oil output and 2) near-zero covariance between reduced form residuals for global oil output and oil price are consistent with a wide range of choices for supply and demand elasticity bounds. Caldara et al. (2016) show that those reduced-form covariance matrix results are consistent with any combination of supply and demand elasticities along a given non-linear curve. With many feasible combinations, the choice of bounds must rely on external information which involves either a literature review or primary estimation. The various sets of bounds proposed in Killian and Murphy (2014), Baumeister and Hamilton (2015), and Caldara et al. (2016) are all close to combinations along the curve derived in the latter paper. In some cases, the pair of bounds involve a very small supply elasticity (0.025) and larger demand elasticity (-0.8) (Killian and Murphy (2014); Baumeister and Peersman (2013)) and in other cases the bounds or, in Bayesian SVARs, priors are similar in absolute value for supply and demand (e.g., 0.10 and -0.10 respectively in Baumeister and Hamilton (2015) and Caldara et al. (2016)).^[The -0.8 bound on oil demand impulse elasticity is based on a single paper that estimates long-run price elasticity of gasoline for the United States using results from a household survey conducted in 1979 and 1988 (Hausman and Newey, 1995).] Results from this metaregression generally agree with a short-run world oil demand elasticity of approximately -0.1. 


5. Conclusions
==============  

The aggregate response in global oil demand to a price or income change is the combination of responses from multiple regions and sectors. Building on that idea, we construct a world oil demand elasticity based on a meta-analysis of elasticities for individual regions and sectors/products obtained from 75 studies published from 2000 to 2015. We then compare the metaregression results to other estimates of the world oil demand elasticity in the literature.

Global short-run elasticities with respect to crude oil price obtained from the metaregression are low (-0.08 and -0.06 for transportation and non-transportation sectors respectively). Estimated long-run elasticities reflecting decade-long adjustements are -0.18 for the transportation sector and -0.32 for other oil end-uses. All estimated elasticities increase in absolute value when they convey response to a new price or income maximum and when they reflect response to end-use product prices rather than crude oil prices. The weighted average of elasticities from both sectors using consumption weights ranges, depending on details about the price baseline, from -0.7 to -0.14 in the short-run. The long-run range is much wider (-0.26,-0.83). 

Results indicate a slightly decreasing trend in short-run transportation elasticity. The estimated coefficient on the trend variable for the other price-elasticities is consistent with them increasing over time but it is not statistically significant. For income elasticities, statistically significant trends only appear for the non-transportation sector and suggest that short-run income elasticity has been decreasing but long-run elasticity has been increasing. We find that countries with higher end-use price levels (inclusive of taxes) are more price elastic. The estimated relationship between income elasticities and a cross-section of income levels is weaker but consistent with higher-income countries being less income-elastic. 

No single study can produce an elasticity value well-suited for every empirical application. However, applied economists can benefit from systematic literature reviews and meta-analyses to select elasticity values well-suited to their specific research question. Attentiveness to key aspects of empirical aplication (e.g., duration of adjustment period being investigated, normal market conditions vs. disrupted market conditions) are important in selecting a value of oil demand elasticity. We illustrate these considerations by computing multiple elasticity baseline values. 

Even though there is an extensive body of literature on petroleum product demand elasticity estimation, it continues to be unbalanced toward study of transportation demand in high-income countries. In addition, changes in demand elasticity due to technological and policy changes are often observed in the literature with a considerable lag since most studies compute average elasticities over decades-long analysis periods. This is particularly the case for studies using time series data since they need to cover a longer time period than studies using data with a cross-sectional dimension to ensure sufficient degrees of freedom in the estimation. Thus, there continues to be room for new estimates to balance out the body of estimates from different regions and sectors and to capture evolution of elasticities over time.  

References
==========

Askari, H., & Krichene, N. (2010). An oil demand and supply model incorporating monetary policy. *Energy*, 35(5), 2013-2021.  

Balcombe, R., Mackett, R., Paulley, N., Preston, J., Shires, J., Titheridge, H., Wardman, M., & White, P. (2004). The demand for public transport: a practical guide. TRL Report TRL593.  

Basso, L. J., & Oum, T. H. (2007). Automobile fuel demand: a critical assessment of empirical methodologies. *Transport Reviews*, 27(4), 449-484. 

Baumeister, C., & Peersman, G. (2013). The role of time-varying price elasticities in accounting for volatility changes in the crude oil market. *Journal of Applied Econometrics*, 28(7), 1087-1109.  

Baumeister, C., & Hamilton, J. (2015). *Structural interpretation of vector autoregressions with incomplete identification: Revisiting the role of oil supply and demand shocks.* Manuscript, University of Notre Dame and UCSD.

Bodenstein, M., & Guerrieri, L. (2011). Oil efficiency, demand, and prices: a tale of ups and downs. Federal Reserve Board.  

Borenstein, M., Hedges, L. V., Higgins, J., & Rothstein, H. R. (2009). *Introduction to Meta-Analysis.* John Wiley & Sons, Ltd.  

Brons, M., Nijkamp, P., Pels, E., & Rietveld, P. (2008). A meta-analysis of the price elasticity of gasoline demand. A SUR approach. *Energy Economics*, 30(5), 2105-2122.  

Caldara, D., Cavallo, M., & Iacoviello, M. (2016). Oil Price Elasticities and Oil Price Fluctuations. Federal Reserve Board.  

Cameron, C.A., & Miller, D.L. (2015). A practitioner's guide to cluster-robust inference. *Journal of Human Resources* 50(2), 317-372.

Dargay, J.M., & Gately, D. (2010). World Oil Demand's Shift toward Faster Growing and Less Price-Responsive Products and Regions. *Energy Policy*, 38(10), 6261-6277.  

Dargay, J. M., Gately, D., & Huntington, H. G. (2007, August). Price and income responsiveness of world oil demand, by product. In Energy Modeling Forum Working Paper EMF OP (Vol. 61).  

Dees, S., Karadeloglou, P., Kaufmann, R. K., & Sanchez, M. (2007). Modelling the world oil market: Assessment of a quarterly econometric model. *Energy Policy*, 35(1), 178-191.  

DOE (2016). Long-Term Strategic Review of the U.S. Strategic Petroleum Reserve. Report to Congress. August 2016.

Espey, M. (1998). Gasoline demand revisited: an international meta-analysis of elasticities. *Energy Economics*, 20(3), 273-295.  

Hausman, J. A., & Newey, W. K. (1995). Nonparametric estimation of exact consumers surplus and deadweight loss. *Econometrica*, 63(6), 1445-1476.  

Havranek, T., Irsova, Z., & Janda, K. (2012). Demand for gasoline is more price-inelastic than commonly thought. *Energy Economics*, 34(1), 201-207.  

Havranek, T., & Kokes, O. (2015). "Income elasticity of gasoline demand: A meta-analysis." *Energy Economics* 47, 77-86.  

Hlavac, Marek (2015). stargazer: Well-Formatted Regression and Summary Statistics Tables. R package version 5.2. http://CRAN.R-project.org/package=stargazer  

Hughes, J. E., Knittel, C. R., & Sperling, D. (2008). Evidence of a Shift in the Short-Run Price Elasticity of Gasoline Demand. *The Energy Journal*, 29(1), 93-114.

International Monetary Fund (2011, April). Tensions from the two-speed recovery: unemployment, commodities, and capital flows. World Economic Outlook.    

Kilian, L., & Murphy, D. P. (2014). The role of inventories and speculative trading in the global market for crude oil. *Journal of Applied Econometrics*, 29(3), 454-478.  

Krichene, N. (2002). World crude oil and natural gas: a demand and supply model. *Energy Economics*, 24(6), 557-576.  

Labandeira, X., Labeaga, J.M, & Lopez-Otero, X. (2017). A meta-analysis on the price elasticity of energy demand. *Energy Policy* 102, 549-568.  

Nelson, J. P. (2014). Estimating the price elasticity of beer: Meta-analysis of data with heterogeneity, dependence, and publication bias. *Journal of Health Economics*, 33, 180-187.  

Nelson, J. P., & Kennedy, P. E. (2009). The use (and abuse) of meta-analysis in environmental and natural resource economics: an assessment. *Environmental and resource economics*, 42(3), 345-377.  

Stanley, T.D., & Doucouliagos, C. (2007). Identifying and correcting publication selection bias in the efficiency-wage literature: Heckman meta-regression. Deakin University. School of Accounting, Economics and Finance. School Working Paper. Economics Series, 11, 2007.  

Stern, D. I. (2012). Interfuel Substitution: A Meta-Analysis. *Journal of Economic Surveys*, 26(2), 307-331.  

\pagebreak

APPENDIX: LIST OF REFERENCES USED IN META-ANALYSIS
==================================================

Alves, D. C., & da Silveira Bueno, R. D. L. (2003). Short-run, long-run and cross elasticities of gasoline demand in Brazil. *Energy Economics*, 25(2), 191-199.

Arzaghi, M., & Squalli, J. (2015). How price inelastic is demand for gasoline in fuel-subsidizing economies?. *Energy Economics*, 50, 117-124.

Bakhat, M., Labeaga, J. M., Labandeira, X., & L?pez, X. (2012). Economic Crisis and Elasticities of Car Fuels: Evidence for Spain (Working Paper FA15-2012).

Baltagi, B. H., Bresson, G., Griffin, J. M., & Pirotte, A. (2003). Homogeneous, heterogeneous or shrinkage estimators? Some empirical evidence from French regional gasoline consumption. *Empirical Economics*, 28(4), 795-811.

Banaszak, S., Chakravorty, U., & Leung, P. (1999). Demand for ground transportation fuel and pricing policy in Asian tigers: a comparative study of Korea and Taiwan. *The Energy Journal*, 20(2), 145-165.

Baranzini, A., & Weber, S. (2013). Elasticities of gasoline demand in Switzerland. *Energy Policy*, 63, 674-680.

Barla, P., Gilbert-Gonthier, M., & Kuelah, J. R. T. (2014). The demand for road diesel in Canada. *Energy Economics*, 43, 316-322.

Belhaj, M. (2002). Vehicle and fuel demand in Morocco. *Energy Policy*, 30(13), 1163-1171.

Bhattacharyya, S. C., & Blake, A. (2009). Domestic demand for petroleum products in MENA countries. *Energy Policy*, 37(4), 1552-1560.

Blundell, R., Horowitz, J. L., & Parey, M. (2012). Measuring the price responsiveness of gasoline demand: Economic shape restrictions and nonparametric demand estimation. *Quantitative Economics*, 3(1), 29-51.

Boshoff, W. H. (2012). Gasoline, diesel fuel and jet fuel demand in South Africa. Studies in Economics and Econometrics, 36(1), 43-78.

Broadstock, D. C., & Hunt, L. C. (2010). Quantifying the impact of exogenous non-economic factors on UK transport oil demand. *Energy Policy*, 38(3), 1559-1565.

Chakravorty, U., Fesharaki, F., & Zhou, S. (2000). Domestic demand for petroleum in OPEC countries. *OPEC Review*, 24(1), 23-52.  

Chandrasiri, S. (2006). Demand for road-fuel in a small developing economy: The case of Sri Lanka. *Energy Policy*, 34(14), 1833-1840.

Chang, D., & Serletis, A. (2014). The demand for gasoline: evidence from household survey data. *Journal of Applied Econometrics*, 29(2), 291-313.

Cheung, K. Y., & Thomson, E. (2004). The demand for gasoline in China: a cointegration analysis. *Journal of Applied Statistics*, 31(5), 533-544.

Cho, W. G., Nam, K., & Pagan, J. A. (2004). Economic growth and interfactor/interfuel substitution in Korea. *Energy Economics*, 26(1), 31-50.

Christopoulos, D. K. (2000). The demand for energy in Greek manufacturing. *Energy Economics*, 22(5), 569-586.

Coyle, D., DeBacker, J., & Prisinzano, R. (2012). Estimating the supply and demand of gasoline using tax data. *Energy Economics*, 34(1), 195-200.

Dahl, C. (2001). Estimating oil product demand in Indonesia using a cointegrating error correction model. *OPEC Review*, 25(1), 1-25.

Danesin, A., & Linares, P. (2015). An Estimation of Fuel Demand Elasticities for Spain An Aggregated Panel Approach Accounting for Diesel Share. *Journal of Transport Economics and Policy*, 49(1), 1-16.

Dargay, J.M., & Gately, D. (2010). World Oil Demand's Shift toward Faster Growing and Less Price-Responsive Products and Regions. *Energy Policy*, 38(10), 6261-6277.  

Dargay, J. M., Gately, D., & Huntington, H. G. (2007, August). Price and income responsiveness of world oil demand, by product. In Energy Modeling Forum Working Paper EMF OP (Vol. 61).

Dees, S., Karadeloglou, P., Kaufmann, R. K., & Sanchez, M. (2007). Modelling the world oil market: Assessment of a quarterly econometric model. *Energy Policy*, 35(1), 178-191.

De Vita, G., Endresen, K., & Hunt, L. C. (2006). An empirical analysis of energy demand in Namibia. *Energy Policy*, 34(18), 3447-3463.

Eltony, M. N., & Al-Mutairi, N. H. (1995). Demand for gasoline in Kuwait: an empirical analysis using cointegration techniques. *Energy Economics*, 17(3), 249-253.

Frondel, M., Peters, J., & Vance, C. (2008). Identifying the Rebound: Evidence from a German Household Panel. *The Energy Journal*, 29(4), 145-163.

Gately, D., & Huntington, H. G. (2002). The asymmetric effects of changes in price and income on energy and oil demand. *The Energy Journal*, 23, 19-55.

Griffin, J. M., & Schulman, C. T. (2005). Price asymmetry in energy demand models: a proxy for energy-saving technical change?. *The Energy Journal*, 26, 1-21.

Hasanov, M. (2015). The demand for transport fuels in Turkey. *Energy Economics*, 51, 125-134.

Hausman, J. A., & Newey, W. K. (1995). Nonparametric estimation of exact consumers surplus and deadweight loss. *Econometrica*, 63(6), 1445-1476.

Hughes, J. E., Knittel, C. R., & Sperling, D. (2008). Evidence of a Shift in the Short-Run Price Elasticity of Gasoline Demand. *The Energy Journal*, 29(1), 93-114.

Hunt, L. C., & Ninomiya, Y. (2003). Unravelling trends and seasonality: a structural time series analysis of transport oil demand in the UK and Japan. *The Energy Journal*, 24(3), 63-96.

Huntington, H. G. (2011). Backcasting US oil demand over a turbulent decade. *Energy Policy*, 39(9), 5674-5680.

Huntington, H. G. (2010). Short-and long-run adjustments in US petroleum consumption. *Energy Economics*, 32(1), 63-72.

Ibrahim, I. B., & Hurst, C. (1990). Estimating energy and oil demand functions: A study of thirteen developing countries. *Energy Economics*, 12(2), 93-102.

International Monetary Fund (2011, April). Tensions from the two-speed recovery: unemployment, commodities, and capital flows. World Economic Outlook.  

Iootty, M., Pinto, H., & Ebeling, F. (2009). Automotive fuel consumption in Brazil: Applying static and dynamic systems of demand equations. *Energy Policy*, 37(12), 5326-5333.

Iwayemi, A., Adenikinju, A., & Babatunde, M. A. (2010). Estimating petroleum products demand elasticities in Nigeria: A multivariate cointegration approach. *Energy Economics*, 32(1), 73-85.

Kayser, H. A. (2000). Gasoline demand and car choice: estimating gasoline demand using household information. *Energy Economics*, 22(3), 331-348.

Li, Z., Rose, J. M., & Hensher, D. A. (2010). Forecasting automobile petrol demand in Australia: an evaluation of empirical models. *Transportation Research Part A: Policy and Practice*, 44(1), 16-38.

Lin, C. Y. C., & Prince, L. (2013). Gasoline price volatility and the elasticity of demand for gasoline. *Energy Economics*, 38, 111-117.

Lin, C. Y. C., & Zeng, J. J. (2013). The elasticity of demand for gasoline in China. *Energy Policy*, 59, 189-197.

Liu, W. (2014). Modeling gasoline demand in the United States: A flexible semiparametric approach. *Energy Economics*, 45, 244-253.

Liu, G. (2004). Estimating energy demand elasticities for OECD countries. A dynamic panel data approach. Statistics Norway, Research Department. Discussion Papers No. 373, March 2004.

Ma, H., Oxley, L., Gibson, J., & Kim, B. (2008). China's energy economy: Technical change, factor demand and interfactor/interfuel substitution. *Energy Economics*, 30(5), 2167-2183.

Mahmud, S. F. (2000). The energy demand in the manufacturing sector of Pakistan: some further results. *Energy Economics*, 22(6), 641-648.

Melo, P. C., & Ramli, A. R. (2014). Estimating fuel demand elasticities to evaluate CO 2 emissions: Panel data evidence for the Lisbon Metropolitan Area. *Transportation Research Part A: Policy and Practice*, 67, 30-46.

Nagata, Y. (2001). A Forecast of Energy Demand in Japan Considering Asymmetric Price Elasticities. *Energy Studies Review*, 10(1).

Nicol, C. J. (2003). Elasticities of demand for gasoline in Canada and the United States. *Energy Economics*, 25(2), 201-214.

Olivia, S., & Gibson, J. (2008). Household energy demand and the equity and efficiency aspects of subsidy reform in Indonesia. *The Energy Journal*, 29(1), 21-39.

Pock, M. (2007). Gasoline and diesel demand in Europe: new insights (No. 202). Reihe ?konomie/Economics Series, Institut f?r H?here Studien (IHS).

Polemis, M. L. (2006). Empirical assessment of the determinants of road energy demand in Greece. *Energy Economics*, 28(3), 385-403.

Ramanathan, R. (1999). Short-and long-run elasticities of gasoline demand in India: An empirical analysis using cointegration techniques. *Energy Economics*, 21(4), 321-330.

Rao, B. B., & Rao, G. (2009). Cointegration and the demand for gasoline. *Energy Policy*, 37(10), 3978-3983.

Reyes, O., Escalante, R., & Matas, A. (2010). La demanda de gasolinas en M?xico: Efectos y alternativas ante el cambio clim?tico. *Econom?a: teor?a y pr?ctica*, (32), 83-111.

Ryan, D. L., & Plourde, A. (2002). Smaller and smaller? The price responsiveness of nontransport oil demand. *The Quarterly Review of Economics and Finance*, 42(2), 285-317.

Santos, G. F. (2013). Fuel demand in Brazil in a dynamic panel data approach. *Energy Economics*, 36, 229-240.

Schmalensee, R., & Stoker, T. M. (1999). Household gasoline demand in the United States. *Econometrica*, 67(3), 645-662.

Sene, S. O. (2012). Estimating the demand for gasoline in developing countries: Senegal. *Energy Economics*, 34(1), 189-194.

Sentenac-Chemin, E. (2012). Is the price effect on fuel consumption symmetric? Some evidence from an empirical study. *Energy Policy*, 41, 59-65.

Serletis, A., Timilsina, G. R., & Vasetsky, O. (2010). International evidence on sectoral interfuel substitution. *The Energy Journal*, 31, 1-29.

Serletis, A., & Shahmoradi, A. (2008). Semi-nonparametric estimates of interfuel substitution in US energy demand. *Energy Economics*, 30(5), 2123-2133.

Sillah, B. M., & Alsheikh, H. M. (2012). Income, price, and government expenditure elasticities of oil in the gulf cooperation council countries. *International Journal of Energy Economics and Policy*, 2(4), 333-341.

Small, K. A., & Van Dender, K. (2007). Fuel efficiency and motor vehicle travel: the declining rebound effect. *The Energy Journal*, 25-51.

Su, Q. (2011). The effect of population density, road network density, and congestion on household gasoline consumption in US urban areas. *Energy Economics*, 33(3), 445-452.

Urga, G., & Walters, C. (2003). Dynamic translog and linear logit models: a factor demand analysis of interfuel substitution in US industrial energy demand. *Energy Economics*, 25(1), 1-21.

Wadud, Z., Graham, D. J., & Noland, R. B. (2010). Gasoline demand with heterogeneity in household responses. *The Energy Journal*, 31, 47-74.

West, S. E., & Williams, R. C. (2004). Estimates from a consumer demand system: implications for the incidence of environmental taxes. *Journal of Environmental Economics and Management*, 47(3), 535-558.  

Yatchew, A., & No, J. A. (2001). Household gasoline demand in Canada. *Econometrica*, 69(6), 1697-1709.

Ziramba, E. (2010). Price and income elasticities of crude oil import demand in South Africa: A cointegration analysis. *Energy Policy*, 38(12), 7844-7849.












