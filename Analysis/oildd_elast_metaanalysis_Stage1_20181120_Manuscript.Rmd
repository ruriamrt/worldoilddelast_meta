---
title: Using Meta-Analysis to Estimate World Oil Demand Elasticity  

author:  

  - Roc&#237;o Ur&#237;a-Mart&#237;nez, Oak Ridge National Laboratory   
  
  - Paul N. Leiby, Oak Ridge National Laboratory   
  
  - Gbadebo Oladosu, Oak Ridge National Laboratory  
  
  - David C. Bowman, Econotech   
  
  - Megan M. Johnson, Oak Ridge National Laboratory   
  

abstract: Crude oil demand elasticities are important behavioral parameters for assessing the effectiveness of many energy policy proposals and the economic impact of crude oil market shocks. Most of the literature on crude oil demand computes elasticities for one specific petroleum product in a country or group of countries. There are fewer published values for world crude oil demand elasticity because it requires more complex estimation methods. Since world crude oil demand and price are simultaneously determined, the reduced-form single equation approach used in much of the petroleum product demand literature leads to endogeneity bias when applied to global demand. This study uses meta-analysis techniques to compute world crude oil demand elasticity. Metaregressions are first conducted to identify sources of variation in elasticity estimates for transportation and non-transportation sectors collected from 75 studies published from 2000 to 2015 using a consistent set of explanatory variables identified in the literature. The estimated coefficients from the metaregressions are then summarized into elasticity baseline values for several combinations of explanatory variable values. Finally, a global crude oil demand elasticity is computed as the consumption-weighted average of the two sectoral elasticities. Resulting mean values for the short-run crude oil demand elasticities with respect to price range from -0.07 to -0.14 depending on the attributes selected for the price variable. As expected from theory and empirical studies, crude oil demand is more price-responsive in the long run than in the short run. Long-run mean values range from -0.26 to -0.83.


keywords: petroleum demand, elasticity, meta-analysis
  
#bibliography: mybibfile.bib
geometry: margin=2cm
output: pdf_document 

---


```{r loadLibraries, eval=TRUE, include=FALSE}
library(tidyverse)
library(broom)
library(broom.mixed)
library(readxl)
library(scales)
library(grid)
library(gridExtra)
library(stargazer) # to produce nice tables for the results
library(knitr)
library(tinytex)
library(styler)

library(car) # for computing variance inflation factors to evaluate the extent to which multicollinearity is an issue
library(truncnorm) # for truncated normal distribution
library(lmtest)
library(sandwich)
library(multiwayvcov) # to compute cluster-robust standard errors
library(lme4) # for linear mixed effects estimation
library(ICC) # for computing intraclass correlation coefficients

## clear: remove (almost) everything in the working environment.
## You will get no warning, so don't do this unless you are sure.
rm(list = ls())
```


1. Introduction 
================

Crude oil demand elasticities are important behavioral parameters for assessing the effectiveness of many energy policy proposals and the economic impact of crude oil market shocks. Estimation of these parameters became a focus of attention during the crude oil crises of the 1970s, as the governments of industrialized countries looked for ways to improve energy efficiency and advance energy security, and it has remained an active research topic ever since. Elasticities must be periodically re-estimated to incorporate the effects of changes in technology, policy, and market factors.  

With improvements in the availability and quality of energy consumption data (particularly for non-OECD countries) and the development of new econometric methods that enable better analysis of time series and panel data, demand elasticity estimation approaches have changed substantially over time. Estimation methodology also varies across petroleum products. Basso and Oum (2007) review the evolution of preferred model specifications for estimation of petroleum product demand in the light-duty transportation sector. Static demand equations and partial adjustment models were the most common choices for estimation of petroleum product demand in the transportation sector in the 1970s and 1980s. In the 1990s, econometricians introduced error correction and co-integration techniques for the analysis of time-series data and their application in transportation fuel demand elasticity estimation has steadily gained popularity (see Banerjee et al. (1993) for a detailed exposition of these techniques).^[Because researchers are typically interested in measuring demand responsiveness over a specific time period, time-series data have generally been considered more appropriate than cross-sectional data for estimating elasticities. However, crude oil demand analysis based on cross-sectional data has remained a parallel track. These studies produce long-run elasticities that summarize responses to all price and income conditions experienced by the survey respondents until the data collection period.] Even though the model specifications used to analyze vehicle fuel demand  are sometimes applied to studies of other sectors, non-transportation petroleum product demand is often explored  with distinct methodologies. For instance, interfuel substitution  models are frequently used to estimate petroleum product own-price and cross-price elasticities in the industrial sector and at the household level.  

Most of the literature on crude oil demand computes elasticities for one particular region and/or petroleum product. There are fewer published values for world crude oil demand elasticity because estimating it is more difficult. For world crude oil demand, crude oil price is not exogenous and the reduced-form single equation approach used in much of the petroleum product demand literature leads to endogeneity bias. Instead, most estimations of world crude oil demand elasticities are based on systems of equations. Within this group, recent structural vector autoregression (SVAR) models whose results challenge the prevailing view that short-run world crude oil demand elasticity is very low have garnered much attention. For instance, Kilian and Murphy (2014) find world crude oil demand elasticities in the range of -0.26 to -0.44 in the first month after a supply shock using 1973-2009 data. Baumeister and Peersman (2013) obtain an average elasticity of -0.26 for that same period, but they allow for time-varying parameters which reveal a substantial steepening of the crude oil supply and demand curves after the mid-1980s. IMF (2011) employ a different approach to correct for endogeneity bias in their exploration of world crude oil demand elasticity and find a much lower elasticity (in absolute value). Taking advantage of cross-sectional variation in a 45-country data panel, they estimate fixed-effect models of OECD and non-OECD crude oil demand and average the resulting elasticities, using consumption weights, into short-run world elasticities of -0.04 using 1965-2009 data and -0.02 for the more recent 1990-2009 subperiod.^[The authors of the IMF study contend that any remaining endogeneity bias using their approach should be small because
country-specific demand shocks will have little or no effect on the world crude oil price and common demand shocks are accounted for through inclusion of GDP as one of the explanatory variables.] Together, the three studies referenced in this paragraph result in a very wide range of world crude oil demand elasticities. Section 4.2 attempts to explain some of the reasons for these diverging findings.  

We contribute to the existing literature by constructing a “bottom-up” world crude oil demand elasticity, based on hundreds of estimates from dozens of studies focused on different portions of global crude oil demand. Several studies explore differences in crude oil demand responsiveness across uses and/or countries (Dargay and Gately, 2010; Dargay et al., 2007; Dees et al., 2007; IMF, 2011). These studies have agreed in their finding that crude oil demand elasticities in OECD countries have been higher than in other regions. As for sectors, Dargay et al. (2007) and Dargay and Gately (2010) argue that the OECD has already largely abandoned crude oil consumption in those uses where fuel switching was easier (e.g., electricity generation, space heating). Both of these studies conclude that world crude oil demand elasticity should be expected to decrease as the fraction of total oil demand originating in more inelastic regions and sectors increases. However, technology, policy, and/or behavioral changes could result in different future crude oil demand elasticity trends. For instance, elasticity in the transportation sector might increase as alternative fuels continue to be adopted and the non-OECD region might become more price responsive if price subsidies on petroleum products are phased out and economic growth sets the region in a trajectory that converges toward that of OECD countries.  

Although other researchers have used metaregressions in surveys of the demand elasticities of gasoline (Espey,1998; Brons et al., 2008; Havranek et al., 2012; Havranek and Kokes, 2015), petroleum products for industrial use (Stern, 2009), or multiple energy products (Labandeira et al., 2017), our study is the first that applies this methodology to gain insight on the value of world crude oil demand elasticity computed as a weighted average of the price responsiveness of two sectors (transportation and non-transportation). In specifying the metaregression model and selecting an econometric estimation approach, we aim to mitigate potential biases associated to the use of meta-data (Borenstein et al., 2009; Nelson and Kennedy, 2009): variance heterogeneity, publication bias, and within-study correlation of residuals. We weigh elasticity estimates by the inverse of their precision to avoid excessive influence of large, imprecise estimates. We test for publication bias—the idea that our metadata is not a random sample of the entire population of elasticity estimates due to higher likelihood of a study being published when estimate size or magnitude is consistent with economic theory and statistically significant. If publication bias is present, we add the variance of estimates as one of the explanatory variables in the metaregression to control for the relationship between the magnitude of an elasticity estimate and its variance. Finally, we use two alternative approaches to account for the lack of independence of residuals corresponding to elasticity estimates obtained from the same study: cluster-robust standard errors or addition of study-level random intercepts. Our choice of explanatory variables is driven by the objective of identifying sources of variation that are important to produce adequate elasticity values for specific empirical applications. For instance, a model exploring multi-year period responses to a policy (e.g., international carbon tax) and a model that depicts short-run responses to a crude oil supply shock require different elasticity inputs. We also pay attention to the relationship between elasticities and cross-sectional differences in price and income levels and assess the specific length of run (number of years) of long-run elasticity estimates.  

```{r LoadData, eval = TRUE, include=FALSE}
load(file = "../Data/allelast_v1")
load(file = "../Data/allelast_v1_NAspeed")

# Convert from tibble to data.frame so that row.names can be reset as needed
allelast <- as.data.frame(allelast)

# Change spelling of references using non-English characters to avoid errors when they are used as input in plots
allelast$REFERENCE[allelast$REFERENCE == "GundimedaK\xf6hlin2008"] <- "GundimedaKohlin2008"

# Drop studies published before year 2000 and implausibly large elasticities
allelast <- subset(allelast, STUDY_YR > 1999 & abs(BETA) < 5)
rownames(allelast) <- seq_len(nrow(allelast)) # reset row.names so that it matches the current length of the allelast dataframe

allelast <- allelast %>%
  mutate(
    RoadTransp = ifelse(PROD_SECT %in% c("Gasoline", "Diesel", "Transportation"), 1, 0),
    OtherSector = ifelse(PROD_SECT != "Total_oil" & RoadTransp != 1, 1, 0),
    OECD = ifelse(REG %in% c("US", "OECD"), 1, 0),
    nonOECD = ifelse(REG != "US" & REG != "OECD" & REG != "World", 1, 0)
  )

# Drop observations for which the relevant cross section variables (PRICE.1998 for price elasts or rgdpecap.1998 for income elasts) are NAs
allelast.P.NA <- subset(allelast, TYPE == "P" & RoadTransp == "1" & is.na(PRICE.1998))
allelast.GDP.NA <- subset(allelast, TYPE == "Y" & REGION != "World" & is.na(rgdpe_cap.1998))

allelast <- allelast[!rownames(allelast) %in% rownames(allelast.P.NA) &
  !rownames(allelast) %in% rownames(allelast.GDP.NA), ]
rownames(allelast) <- seq_len(nrow(allelast))

# Construct separate data.frame for estimates that will not be used in the metaregression analysis because they cannot be allocated to OECD-nonOECD regions or Transportation-nonTransportation sectors (most of these are world elasticity estimates) and remove those rows from allelast dataframe

allelast.metareg <- subset(allelast, OECD == "1" & RoadTransp == "1" | OECD == "1" & OtherSector == "1" |
  nonOECD == "1" & RoadTransp == "1" | nonOECD == "1" & OtherSector == "1")
allelast.excluded <- anti_join(allelast, allelast.metareg, by = c("OECD", "nonOECD", "RoadTransp", "OtherSector"))

allelast <- allelast[rownames(allelast) %in% rownames(allelast.metareg), ]
rownames(allelast) <- seq_len(nrow(allelast))

# Drop observations where the length of run is negative (because the estimated coefficient on lagged demand is greater than 1 or the estimated coefficient on the error correction term is positive)
allelast <- subset(allelast, SPEEDYRS > 0)
rownames(allelast) <- seq_len(nrow(allelast))

# Drop observations where the standard error was estimated
# allelast <- subset(allelast, CALC_STERROR =="0")
# rownames(allelast) <- seq_len( nrow(allelast))
```

2. Meta-Analysis Database Description
=====================================

We performed queries in Google Scholar and Econlit as well as snowball searches to identify peer-reviewed journal articles and working papers published between 2000 and 2015 containing primary estimates of crude oil or petroleum product demand elasticities. We discarded studies that did not provide standard errors or other related information (t-statistic, p-value or confidence intervals) to infer the precision of the elasticity estimates. We excluded estimates with an absolute value outside of (-5,5) interval as well as observations that cannot be assigned to OECD/nonOECD regions or transportation/non-transportation sectors. Finally, we dropped observations for which the value of any of the explanatory variables to be included in the metaregression analysis are not available. The resulting dataset to be used in the metaregression analysis consists of 1983 observations from the 75 papers listed in Appendix A. Figure 1 shows the initial and final year of the data period considered in each of the papers in our database.   

Figure 1 shows the initial and final year of the data period considered in each of the papers in our database. 

``` {r plotTimeRange, eval = TRUE, include=FALSE}
### Explore papers in terms of citation count and range of years covered in data
allelast.TS <- subset(allelast, DATA_TYPE == "TS")
allelast.CSTS <- subset(allelast, DATA_TYPE == "CS-TS")

summstats_reference <- allelast %>%
  group_by(REFERENCE) %>%
  summarise(count = length(CITATIONS), average = round(mean(CITATIONS), 3), STUDY_YR = round(mean(STUDY_YR), 3), minyrstart = min(YEAR_START), maxyrend = max(YEAR_END), pubdatalag = STUDY_YR - maxyrend, yrlength = maxyrend - minyrstart)
print(summstats_reference)

# Plot showing number of citations of each paper versus publication year
paper.citations <-
  ggplot(summstats_reference, aes(x = STUDY_YR, y = average)) +
  geom_point(shape = 16, size = 3, colour = "blue") +
  geom_text(aes(label = REFERENCE), hjust = -0.1, vjust = 0, size = 4) +
  xlim(-5 + min(summstats_reference$STUDY_YR), max(summstats_reference$STUDY_YR) + 10) +
  labs(x = "Initial Year", y = "Number of citations", title = "Citations versus Publication Year") +
  theme(plot.title = element_text(size = 14, face = "bold", hjust = 0.5)) +
  theme(axis.text.x = element_text(size = 10, angle = 90, hjust = 1), axis.text.y = element_text(size = 10), axis.title = element_text(size = 12, face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
paper.citations


# Plot showing beginning and end years for each paper
paper.periods <-
  ggplot(summstats_reference, aes(x = minyrstart, y = maxyrend)) +
  geom_point(shape = 16, size = 3, colour = "blue") +
  geom_text(aes(label = REFERENCE), hjust = -0.1, vjust = 0, size = 2.5) +
  scale_x_continuous(limits = c(min(summstats_reference$minyrstart), max(summstats_reference$minyrstart) + 5), breaks = pretty_breaks(n = 12)) +
  scale_y_continuous(limits = c(min(summstats_reference$maxyrend), max(summstats_reference$maxyrend)), breaks = pretty_breaks(n = 12)) +
  # xlim(min(summstats_reference$minyrstart),max(summstats_reference$maxyrend)+5)+
  geom_hline(yintercept = max(summstats_reference$maxyrend), linetype = "dashed") +
  geom_vline(xintercept = min(summstats_reference$minyrstart), linetype = "dashed") +
  labs(x = "Initial Year", y = "Final Year", title = "") +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(axis.text.x = element_text(size = 10, angle = 65, hjust = 1), axis.text.y = element_text(size = 10), axis.title = element_text(size = 10, face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
paper.periods

ggsave("../Output/paper.periods.png", width = 6.5, height = 4.5, units = "in", dpi = 600)
```

```{r out_paperperiods, echo = FALSE, warning =FALSE, message=FALSE }
paper.periods
```

**Figure 1. Periods of analysis in studies included in elasticity meta-analysis database**

Even though 40 of the 75 papers in the database were published after 2009, only 12 contain data for 2010 or later. The average lag between publication year and end of analysis period is approximately 5 years. Studies based on time series data tend to analyze longer periods and result in an average elasticities that might be less representative of recent conditions than those from studies using more recent data panels.^[The average length of data period covered by papers in our database using time series and panel data is 28 and 17 years respectively.] The average years in this database are 1989, 1994, and 2004 for subsets of studies using time series, panel, and cross-sectional data respectively.

Beyond the usual segmentations by type (price or income) and length of run (short or long run), we also segment the database by sector (transportation or non-transportation) because the data sources and estimation methods used for generating these two elasticities tend to be different.^[Gasoline or diesel demand elasticities were assigned to the transportation sector unless the study mentioned explicitly that its consumption data corresponded to a different sector. Elasticities in the non-transportation category include elasticities for petroleum demand in the industrial sector, residential sector (for uses other than transportation) or petroleum products used in those sectors (industrial use of diesel and gas oil, fuel oil, kerosene, liquefied petroleum gas, residual fuel oil, other petroleum products). Even though aviation is a transportation activity, jet fuel demand elasticities were assigned to the non-transportation category.] Segmentation by sector also enables a more tailored selection of moderator variables for the metaregression. We considered further segmenting the data by region (OECD versus non-OECD) but some of the resulting 16 groupings contained few observations making the validity of a metaregression analysis approach questionable. Instead, to control for regional differences, we include regional dummies and cross-sections of price and income levels as moderator variables in the metaregressions.

Accounting for response period is important when comparing elasticity estimates across studies. All else equal, demand responsiveness is expected to increase with the period over which the response is measured. We consider short-run elasticities as those that convey a first-period response: one year, one quarter, or one month depending on the data frequency used in each study. In addition, whenever possible, we assign long-run estimates a specific response length (in years). Dynamic demand specifications typically include a variable (lagged demand for partial adjustement models or error correction term in error correction models) whose estimated coefficient can be used to estimate the length of run implied by the long-run elasticities.^[Balcombe et al. (2004) show that the number of periods to achieve 90% of the long-run elasticity estimated using an autoregressive distributed lag (ARDL) specification can be calculated as $ln(1-0.9)/ln(\theta)$. $\theta$ is the estimated coefficient on lagged demand if the model specification is a partial adjustment model; for error correction models the formula is $ln(1-0.9)/ln(\theta)+1$] To our knowledge, this is the first meta-analysis that extracts this more detailed information on length of run from long-run elasticities. We classified most of the elasticities from cross sectional studies as long-run and assigned them a length of run in years equal to the average adjustment period for long-run elasticities in the same grouping (i.e., type-sector combination).^[The only cross-sectional elasticities classified as short-run come from 3 studies that used data from household surveys where the same household is interviewed multiple times at intervals equal or less than one year (e.g., Frondel et al.,(2008)). Alternatively, data from these studies could have been categorized as a (very unbalanced) panel.]

As an initial exploratory step, Figure 2 displays unweighted means (alongside the fixed effect and random effects means typically computed in meta-analyses) for the 8 elasticity groupings being analyzed: 2 types (price and income) times 2 lengths of run (short and long) times two sectors (transportation and non-transportation). Fixed effect means are appropriate when all elasticities in a given group originate from the same population and the only reason why they differ is sampling error. In that case, estimates with lowest standard errors should be weighted more heavily and vice versa. On the other hand, random effects means assume that variability in a given set of elasticities is partly due to inherent differences in the true effect sizes (e.g., the true population mean is different across countries, over time and/or based on other attributes). The weights applied to random effects mean include an extra component to account for between-estimate variation (Borenstein et al., 2009). As in most social sciences applications of meta-analysis, the random effects model seems most appropriate to describe our dataset.


```{r MetaAnalysisMeans, eval = TRUE, include = FALSE}
# Unweighted, fixed effect, and random effects means for each of the subset of elasticities to be used in the metaregressions
#-----------------------------------------------------------------------------------------------------------------------------

# Elasticity subsets are combinations of elasticity types (price or income), length of run (short-run or long-run) and sector (transportation or nontransportation)
allelast <- mutate(allelast, Type_Sector = as.factor(paste(TYPE_LENGTH2, RoadTransp, OtherSector, sep = "_")))

## Unweighted means
avg_ALL <- allelast %>%
  group_by(Type_Sector) %>%
  summarise(unweighted_mean = mean(BETA), n.obs = length(BETA))

## Fixed effect means and associated 95% confidence intervals (following Chapter 11 in Borenstein et al. 2009)
allelast$weights.FE <- 1 / ((allelast$ST_ERROR)**2) ## fixed effect weights
FE_avg_ALL <- allelast %>%
  group_by(Type_Sector) %>%
  summarise(
    numerator = round(sum(BETA * weights.FE), 4),
    denominator = round(sum(weights.FE), 4),
    mean = round(numerator / denominator, 4),
    ## The variance of the summary effect is estimated as the reciprocal of the sum of weights
    se = round(sqrt(1 / denominator), 4),
    n.obs = length(BETA),
    lo.CI95 = round(mean - (1.96 * se), 4),
    up.CI95 = round(mean + (1.96 * se), 4)
  )
FE_avg_ALL$Type <- "Fixed Effect Means"


## Random effects means (following Chapter 12 in Borenstein et al. 2009)
### Compute between-estimates variance
interstudy_var <- allelast %>%
  group_by(Type_Sector) %>%
  ### Q is the total amount of study-to-study variation actually observed (where each observation is interepreted as an independent study)
  summarise(
    Q = sum(BETA * BETA * (weights.FE)) - (sum(BETA * (weights.FE) * sum(BETA * (weights.FE))) / sum(weights.FE)),
    C = sum(weights.FE) - (sum((weights.FE) * (weights.FE)) / sum((weights.FE))),
    df = length(BETA) - 1,
    ### Q-df indicates how much the observed effects would be expected to vary from each other if the true effect was actually the same in all studies. The excess variation is assumed to reflect real differences in effect size
    tau = (Q - df) / C,
    ### I2 can be interpreted as the proportion of the observed variance that reflects real heterogeneity in effect size
    I2 = (Q - df) / Q
  )
### Large I2 implies large effect size heterogeneity and can be used as justification for metaregression analysis as a way to explain the heterogeneity

### Assign appropriate between-estimates variance to each observation
for (i in levels(allelast$Type_Sector))
{
  allelast$tau[allelast$Type_Sector == i] <- interstudy_var$tau[interstudy_var$Type_Sector == i]
}

### Compute random effects weights
allelast <- allelast %>%
  mutate(
    weights.RE = 1 / (ST_ERROR**2 + tau),
    tau.frac = tau / weights.RE
  )

### Compute random effects means and associated 95% confidence intervals
RE_avg_ALL <- allelast %>%
  group_by(Type_Sector) %>%
  summarise(
    numerator = round(sum(BETA * weights.RE), 4),
    denominator = round(sum(weights.RE), 4),
    mean = round(numerator / denominator, 4),
    tau.frac.summ = round(mean(tau.frac), 4),
    ## The variance of the summary effect is estimated as the reciprocal of the sum of weights
    se = round(sqrt(1 / denominator), 4),
    n.obs = length(BETA),
    lo.CI95 = round(mean - (1.96 * se), 4),
    up.CI95 = round(mean + (1.96 * se), 4)
  )
RE_avg_ALL$Type <- "Random Effects Means"


# Combine raw, fixed effect and random effects means and standard errors into a single data.frame
avg.summary <- rbind(FE_avg_ALL, RE_avg_ALL[, c("Type_Sector", "Type", "numerator", "denominator", "mean", "se", "n.obs", "lo.CI95", "up.CI95")]) %>%
  select(Type_Sector, Type, n.obs, mean, se, lo.CI95, up.CI95)


Type_Sector <- c("P_SR_1_0", "P_SR_0_1", "P_LR_1_0", "P_LR_0_1", "Y_SR_1_0", "Y_SR_0_1", "Y_LR_1_0", "Y_LR_0_1")
ElastID <- c(
  "ShortRun-\nTransportation", "ShortRun-\nnonTransportation", "LongRun-\nTransportation", "LongRun-\nnonTransportation",
  "ShortRun-\nTransportation", "ShortRun-\nnonTransportation", "LongRun-\nTransportation", "LongRun-\nnonTransportation"
)
ElastIDmatch <- data.frame(Type_Sector, ElastID)


avg.summary <- avg.summary %>%
  left_join(ElastIDmatch, by = c("Type_Sector")) %>%
  left_join(avg_ALL[, c("Type_Sector", "unweighted_mean")], by = c("Type_Sector")) %>%
  mutate(
    ElastID = as.factor(ElastID),
    Length_Run = as.factor(substr(Type_Sector, 3, 4)),
    Elast_Type = ifelse(substr(Type_Sector, 1, 1) == "P", "Price", "Income")
  )

print(avg.summary)

# Forest plots

forest.plot <-
  ggplot(avg.summary, aes(x = mean, y = ElastID)) +
  geom_point(aes(fill = Elast_Type, shape = Length_Run, color = Elast_Type), size = 2) +
  geom_point(aes(x = unweighted_mean, y = ElastID), colour = "black", size = 2) +
  geom_errorbarh(aes(xmin = lo.CI95, xmax = up.CI95), height = 0.667) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  xlim(-1, 1) +
  facet_wrap(~Type, ncol = 1) +
  scale_shape_manual(values = c(22, 21)) +
  scale_fill_manual(values = c("orange", "turquoise")) +
  scale_color_manual(values = c("orange", "turquoise")) +
  labs(x = "Elasticity", y = "Category", title = "", hjust = 0.5, fill = "Elasticity \nType", color = "Elasticity \nType", shape = "Length \nof \nRun") +
  theme(axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 11)) +
  theme(plot.title = element_text(size = 11, face = "bold")) +
  theme(
    legend.text = element_text(size = 10), legend.title = element_text(size = 10), legend.key = element_blank(),
    legend.position = "right"
  ) +
  theme(
    panel.grid.major.x = element_line(colour = "grey"), panel.grid.minor.x = element_line(colour = "grey"), panel.background = element_blank(),
    axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1)
  )
forest.plot
ggsave("../Output/forest.plot.png", width = 6.5, height = 4.5, units = "in", dpi = 600)

# Plot elasticity values against their standard errors
elastsubset <- subset(allelast, TYPE_LENGTH2 == "Y_LR" & RoadTransp == "0")
elastsubset.plot <- ggplot(elastsubset, aes(x = BETA, y = ST_ERROR, color = as.factor(CALC_STERROR))) +
  geom_point(size = 1) +
  ylim(0, 1) +
  labs(x = "Elasticity", y = "Variance", title = "") +
  theme(strip.text.x = element_text(size = 12)) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(axis.text.x = element_text(size = 10, angle = 65, hjust = 1), axis.text.y = element_text(size = 10), axis.title = element_text(size = 10, face = "bold")) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 10, face = "bold"), legend.key = element_blank(), legend.position = "right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
elastsubset.plot
```

```{r out_forestplot, echo = FALSE, warning =FALSE, message=FALSE }
forest.plot
```
Note: The black dots represent the unweighted means against which fixed effect and random effects means are compared. The error bars represent the 95% confidence interval around the fixed effect and random effects means.

**Figure 2. Forest plot of demand elasticities with respect to price and income**

All weighted and unweighted means are less than one in absolute value (i.e., inelastic). For both types of elasticity and both lengths of run, the unweighted average elasticities are greater for the transportation sector than for other sectors. The same result is true for the random effects means but not for the long-run fixed effect means. For all elasticity groupings except long-run non-transportation, the random effects mean is an intermediate value between the unweighted and fixed effect means. This result is consistent with a data set where the smaller effect sizes (elasticities in this case) are the most precisely measured. For long-run, nontransportation elasticities, fixed effect means are the largest. This result indicates that the relationship between effect size and precision of the estimate is weaker for that elasticity grouping.   


```{r CreateVars, eval = TRUE, include=FALSE}
# This chunk creates moderator variables to be used in the metaregression

## Brent price source: http://www.eia.gov/dnav/pet/pet_pri_spt_s1_a.htm
literspergal <- 3.78
galsperbbl <- 42
Brentp.1998 <- 12.76 / (literspergal * galsperbbl) # Average crude oil price for 1998 (in $/liter)

allelast <- mutate(allelast,
  Ones = 1, # (to be used for inspecting correlation across explanatory variables)
  YrLength = YEAR_END - YEAR_START, # Analysis period length (Years)
  INV_SPEEDYRS = 1 / SPEEDYRS, # transformation to reflect non-linear elasticity increase with length of run
  # Data Region variables
  World = ifelse(REG == "World", 1, 0), # World
  NETEXP = ifelse(EXPCONS.ratio > 0, 1, 0), # Net Importer/Exporter
  # Data Product/Sector variables
  DslTransp = ifelse(PROD_SECT == "Diesel", 1, 0), # Diesel
  ElecGen = ifelse(PROD_SECT == "ElecGen", 1, 0), # Electricity Generation
  Residential = ifelse(PROD_SECT == "Residential", 1, 0), # Residential
  FuelSwitch = ifelse(Residential == 1 | ElecGen == 1, 1, 0), # Fuel Switching (as in Dargay&Gately2010)
  Industrial = ifelse(PROD_SECT == "Industrial", 1, 0), # Industrial
  # Data Frequency variables
  Annual = ifelse(FREQUENCY == "annual" | FREQUENCY == "biennial", 1, 0), # Annual
  Quarterly = ifelse(FREQUENCY == "quarterly", 1, 0), # Quarterly
  Monthly = ifelse(FREQUENCY == "monthly", 1, 0), # Data Monthly
  # Data Type variables
  TS = ifelse(DATA_TYPE == "TS", 1, 0), # Time Series
  CSTS = ifelse(DATA_TYPE == "CS-TS", 1, 0), # Panel data
  CS = ifelse(DATA_TYPE == "CS" | DATA_TYPE == "CS " | DATA_TYPE == "CS-TS (mostly CS)", 1, 0), # Cross Sectional
  Logarithmic = ifelse(LOGS == "1", 1, 0), # Logarithmic
  PerCapita = ifelse(PER_CAPITA == "1", 1, 0), # PerCapita variables
  # Price Elasticity Characteristics (only relevant for price elasticities)
  EndUserP = ifelse(PRICE_POINT == "1", 1, 0), # End-user Price
  Pmax = ifelse(substr(VAR_SYMBOL, 1, 4) == "Pmax", 1, 0), # Price Component_ Pmax
  Pcut = ifelse(substr(VAR_SYMBOL, 1, 4) == "Pcut", 1, 0), # Price Component_ Pcut
  Prec = ifelse(substr(VAR_SYMBOL, 1, 4) == "Prec", 1, 0), # Price Component_ Precovery
  Psubmax = ifelse(substr(VAR_SYMBOL, 1, 4) == "Psub", 1, 0), # Price Component_ Psubmax
  # Income Elasticity Characteristics (only relevant for income elasticities)
  Ymax = ifelse(substr(VAR_SYMBOL, 1, 4) == "Ymax", 1, 0), # Income Component_ Ymax
  Ycut = ifelse(substr(VAR_SYMBOL, 1, 4) == "Ycut", 1, 0), # Income Component_ Ycut
  Yrec = ifelse(substr(VAR_SYMBOL, 1, 4) == "Yrec", 1, 0), # Income Component_ Yrec
  # Model Specification variables
  DynamicP = ifelse(P_DYNAMIC == "1", 1, 0), # DynamicP
  StaticP = ifelse(P_DYNAMIC == "0", 1, 0), # StaticP
  DynamicY = ifelse(Y_DYNAMIC == "1", 1, 0), # DynamicY
  StaticY = ifelse(Y_DYNAMIC == "0", 1, 0), # StaticY
  ARDL = ifelse(MODEL_TYPE2 == "ARDL", 1, 0), # ARDL model family
  Coint = ifelse(MODEL_TYPE2 == "cointegration", 1, 0), # Cointegration model
  FlexForm = ifelse(MODEL_TYPE2 == "flex_form", 1, 0), # Flexible Functional Form
  SysEq = ifelse(MODEL_TYPE2 == "system", 1, 0), # System of Equations
  GenEQ = ifelse(MODEL_TYPE2 == "DSGE" | MODEL_TYPE2 == "SVAR", 1, 0), # General Equilibrium
  nonARDLcomb = ifelse(MODEL_TYPE2 == "ARDL" | MODEL_TYPE2 == "cointegration" |
    MODEL_TYPE2 == "linear_static", 0, 1), # not from ARDL model family
  OtherLagsP = ifelse(P_LAGS == "1", 1, 0), # Additional Lags P
  OtherLagsY = ifelse(Y_LAGS == "1", 1, 0), # Additional Lags Y
  Psubst = ifelse(grepl("price_substitutes", OTH_VAR_CAT), 1, 0), # model w/ price of substitutes regressor
  VehStk = ifelse(grepl("vehicle_stock", OTH_VAR_CAT), 1, 0), # model w/ vehicle stock regressor

  PRICE.1998.cent = PRICE.1998 - Brentp.1998, # normalize Price cross section to be 0 for the Brent price level
  VARIANCE = ST_ERROR * ST_ERROR,
  PRECISION = 1 / abs(ST_ERROR),
  TSTAT = BETA / ST_ERROR,
  SQ.NOBS = sqrt(N_SIZE),
  # Interaction variables
  StaticP.CS = StaticP * CS,
  StaticY.CS = StaticY * CS
)


## Centering continuous variables to avoid very large estimated intercepts and to give the estimated intercept a meaningful interpretation.

for (i in 1:nrow(allelast)) {
  ## YrAvg
  allelast$YrAvg.avg[i] <- mean(allelast$AVGYR
  [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] &
      allelast$RoadTransp == allelast$RoadTransp[i]])
  allelast$YrAvg.cent[i] <- allelast$AVGYR[i] - allelast$YrAvg.avg[i]
  ## SPEEDYRS (only matters for long-run elasticities because this moderator variable only enters the short-run metaregressions)
  allelast$SPEEDYRS.avg[i] <- mean(allelast$SPEEDYRS
  [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] &
      allelast$RoadTransp == allelast$RoadTransp[i] &
      allelast$CS == "0"])
  allelast$SPEEDYRS.cent[i] <- ifelse(allelast$CS[i] == "0", allelast$SPEEDYRS[i] - allelast$SPEEDYRS.avg[i], allelast$SPEEDYRS.avg[i])
  ## rgdpecap.1998
  allelast$rgdpe_cap.1998.avg[i] <- mean(allelast$rgdpe_cap.1998
  [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] &
      allelast$RoadTransp == allelast$RoadTransp[i]])
  allelast$rgdpe_cap.1998.cent[i] <- allelast$rgdpe_cap.1998[i] - allelast$rgdpe_cap.1998.avg[i]

  ## PRICE1998
  # allelast$PRICE.1998.avg[i] <-  mean(allelast$PRICE.1998
  #                              [allelast$TYPE_LENGTH2 == allelast$TYPE_LENGTH2[i] &
  #                               allelast$RoadTransp == allelast$RoadTransp[i]]
  #                                )
  # allelast$PRICE.1998.cent[i] <- allelast$PRICE.1998[i]- allelast$PRICE.1998.avg[i]
}
```

<!--
Key steps in metaregression analysis
- Select the set of moderator variables to use for the metaregression of each of the elasticity subsets
- Looping over the elasticity subsets:  
	- Perform WLS estimation  
	- Conduct outlier analysis based on the residuals from the initial WLS estimation  
	- Classify as outliers the observations whose studentized residuals are outside the (-2,2) interval and remove them from the dataset  
	- Post-outlier analysis metaregression estimation:   
		- Weighted least squares  
			- Compute clustered standard errors using REFERENCE as the clustering variable 
		- Linear mixed effects  
		- OLS
	- Compute baseline elasticities and their standard errors from the estimated coefficients from the metaregression and their standard errors   
	- Perform likelihood ratio test to choose the best performing specification (WLS or LME) for reporting the results in the paper  
-->

```{r Metareg, eval = TRUE, include = FALSE}
# Metaregression estimation
#------------------------------

selectorVarList <- c("TYPE_LENGTH2", "RoadTransp", "OtherSector")
selectorSets <- rbind(
  c("P_SR", "1", "0"),
  c("P_LR", "1", "0"),
  c("Y_SR", "1", "0"),
  c("Y_LR", "1", "0"),
  c("P_SR", "0", "1"),
  c("P_LR", "0", "1"),
  c("Y_SR", "0", "1"),
  c("Y_LR", "0", "1")
)

printf <- function(...) invisible(print(sprintf(...))) # formatted printing

# given selection values in passed array sv, construct a string for the subset argument in the estimation command
selectorSubsetString <- function(sv = c("P_SR", "1", "0")) {
  return(paste0(
    "TYPE_LENGTH2 ==", sv[1], "&",
    "RoadTransp   ==", sv[2], "&",
    "OtherSector  ==", sv[3]
  ))
}

# given selection values in passed array sv, construct a logical vector to select (subset) desired observations from the dataset
selectorLogicalVec <- function(sv = c("P_SR", "1", "0")) {
  return(allelast$TYPE_LENGTH2 == sv[1] &
    allelast$RoadTransp == sv[2] &
    allelast$OtherSector == sv[3])
}

selectorLogicalVecs <- matrix(ncol = nrow(selectorSets), nrow = nrow(allelast))
for (i in 1:nrow(selectorSets)) {
  selectorLogicalVecs[, i] <- selectorLogicalVec(selectorSets[i, ])
}


# Select moderator variable sets
all_varList_P_SR.Transp <- c("YrAvg.cent", "Quarterly", "Monthly", "CSTS", "Pmax", "OECD", "StaticP", "StaticP.CS", "PRICE.1998.cent", "DslTransp", "VehStk", "VARIANCE", "CALC_STERROR")
all_varList_P_LR.Transp <- c("YrAvg.cent", "SPEEDYRS.cent", "CS", "CSTS", "Pmax", "OECD", "StaticP", "PRICE.1998.cent", "DslTransp", "VehStk", "VARIANCE", "CALC_STERROR")
all_varList_P_SR.nonTransp <- c("YrAvg.cent", "Quarterly", "Monthly", "CSTS", "OECD", "Pmax", "StaticP", "StaticP.CS", "EndUserP", "FuelSwitch", "VARIANCE", "CALC_STERROR")
all_varList_P_LR.nonTransp <- c("YrAvg.cent", "SPEEDYRS.cent", "CSTS", "OECD", "Pmax", "EndUserP", "VARIANCE", "CALC_STERROR")
all_varList_Y_SR.Transp <- c("YrAvg.cent", "Monthly", "CSTS", "Ymax", "StaticY", "StaticY.CS", "rgdpe_cap.1998.cent", "DslTransp", "VehStk", "VARIANCE", "CALC_STERROR")
all_varList_Y_LR.Transp <- c("YrAvg.cent", "SPEEDYRS.cent", "CSTS", "Ymax", "rgdpe_cap.1998.cent", "DslTransp", "VehStk", "VARIANCE", "CALC_STERROR")
all_varList_Y_SR.nonTransp <- c("YrAvg.cent", "Quarterly", "Monthly", "CSTS", "Ymax", "StaticY", "StaticY.CS", "rgdpe_cap.1998.cent", "FuelSwitch", "VARIANCE", "CALC_STERROR")
all_varList_Y_LR.nonTransp <- c("YrAvg.cent", "SPEEDYRS.cent", "CSTS", "Ymax", "rgdpe_cap.1998.cent", "CALC_STERROR")

# Create lists to store elements/results of interest from each metaregression

# Store intraclass correlation coefficients for effect sizes
ICC.all <- list()
ICC.all2 <- list()

# Store results from publication bias test
pubbias.test <- list()

# Store data subsets used for final set of metaregressions
obsSel2 <- list()

## (WLS) weighted least squares estimation
modelsEstimated <- list() # saves results from WLS metaregressions
modelsEstimated2 <- list() # saves tidy results from WLS metaregressions (post outlier analysis)
modelsEstimated2.raw <- list() # saves untidy results from WLS metaregressions (post outlier analysis)
WLS.elastID <- list() # saves elasticity type-regions-sector ID for WLS metaregressions
coeffsEstimated <- list() # saves estimated coefficients with their cluster-robust standard errors
coeffsEstimated2 <- list() # saves estimated coefficients with their cluster-robust standard errors (post outlier analysis)
vifEstimated <- list() # saves variance inflation factors associated to WLS metaregressions
vifEstimated2 <- list() # saves variance inflation factors associated to WLS metaregressions (post outlier analysis)
ICC_resid.all <- list() # saves intraclass coefficients for WLS residuals
ICC_resid.all2 <- list() # saves intraclass coefficients for WLS residuals (post outlier analysis)

## (LME)linear mixed effects estimation
modelsEstimated.LME <- list() # saves results from LME metaregressions
modelsEstimated2.LME <- list() # saves tidy results from LME metaregressions (post outlier analysis)
modelsEstimated2.LME.raw <- list() # saves untidy results from LME metaregressions (post outlier analysis)
LME.elastID <- list() # saves elasticity type-regions-sector ID for LME metaregressions

## Likelihood ratio tests to select WLS or LME as a preferred model specification
LRT <- list()

## (OLS)estimation (only to be used post-outlier analysis with Huber-White standard errors as an alternative to the use of precision-based weights in addressing heteroskedasticity; this specification would not include VARIANCE as a moderator variable either so it would not be correcting for publication bias)
modelsEstimated2.OLS <- list() # saves results from OLD metaregressions
coeffsEstimated2.OLS <- list() # saves estimated coefficients with their heteroskedasticity-consistent standard errors (post outlier analysis)
modelsEstimated2.OLS.raw <- list() # saves untidy results from LME metaregressions (post outlier analysis)
OLS.elastID <- list() # saves elasticity type-regions-sector ID for OLS metaregressions

## Baselines elasticities
baseline.comps <- list() # saves components needed to compute baseline (WLS and LME, post outlier analysis)
baselinesEstimated <- list() # saves baseline elasticities and other results (WLS and LME, post outlier analysis)


for (i in 1:nrow(selectorSets)) {
  print(i)

  curr_varList <- ifelse(selectorSets[i, 1] == "P_SR" & selectorSets[i, 2] == "1" & selectorSets[i, 3] == "0", list(all_varList_P_SR.Transp),
    ifelse(selectorSets[i, 1] == "P_SR" & selectorSets[i, 2] == "0" & selectorSets[i, 3] == "1", list(all_varList_P_SR.nonTransp),
      ifelse(selectorSets[i, 1] == "P_LR" & selectorSets[i, 2] == "1" & selectorSets[i, 3] == "0", list(all_varList_P_LR.Transp),
        ifelse(selectorSets[i, 1] == "P_LR" & selectorSets[i, 2] == "0" & selectorSets[i, 3] == "1", list(all_varList_P_LR.nonTransp),
          ifelse(selectorSets[i, 1] == "Y_SR" & selectorSets[i, 2] == "1" & selectorSets[i, 3] == "0", list(all_varList_Y_SR.Transp),
            ifelse(selectorSets[i, 1] == "Y_SR" & selectorSets[i, 2] == "0" & selectorSets[i, 3] == "1", list(all_varList_Y_SR.nonTransp),
              ifelse(selectorSets[i, 1] == "Y_LR" & selectorSets[i, 2] == "1" & selectorSets[i, 3] == "0", list(all_varList_Y_LR.Transp),
                ifelse(selectorSets[i, 1] == "Y_LR" & selectorSets[i, 2] == "0" & selectorSets[i, 3] == "1", list(all_varList_Y_LR.nonTransp), NA)
              )
            )
          )
        )
      )
    )
  )


  curr_varList <- c(do.call("cbind", curr_varList))
  curr_obsSel <- selectorLogicalVec(selectorSets[i, ]) # logical vec for selection of desired observations

  # Create a second list of variables that excludes VARIANCE in order to compute number of "unique" observations providing added information to the metaregression
  curr_varList_minusVARIANCE <- curr_varList[curr_varList != "VARIANCE"]

  printf("Subset selection: %s", selectorSubsetString(selectorSets[i, ]))

  # Drop variables for which there is no variability within the set of observations curr_obsSel
  mydf <- matrix(0, 1, length(curr_varList))
  colnames(mydf) <- curr_varList
  for (j in 1:length(curr_varList)) {
    mydf[1, j] <- max(allelast[curr_obsSel, curr_varList[j]]) - min(allelast[curr_obsSel, curr_varList[j]])
  }
  curr_varList <- curr_varList[mydf[1, ] != 0]
  printf("Variables: %s", curr_varList)

  curr_formula <- paste("BETA", paste(curr_varList, collapse = "+"), sep = "~")
  printf("Formula estimated: %s", curr_formula)

  curr_formula.lme <- paste(paste("BETA", paste(curr_varList, collapse = "+"), sep = "~"), "(1|REFERENCE)", sep = "+")
  print(summary(allelast[curr_obsSel, c("BETA", curr_varList)])) # review dataset for this regression

  curr_formula.ols <- paste("BETA", paste(curr_varList[curr_varList != "VARIANCE" & curr_varList != "CALC_STERROR"], collapse = "+"), sep = "~")

  curr_cor <- round(cor(allelast[curr_obsSel, c("BETA", "Ones", curr_varList)], use = "pairwise.complete.obs", method = "spearman"), 2)
  print(curr_cor)

  ## Compute intraclass correlation coefficient
  curr_elast.by.REF <- allelast[curr_obsSel, c("REFERENCE", "BETA")]
  curr_ICC <- ICCest(REFERENCE, BETA, curr_elast.by.REF, alpha = 0.05, CI.type = c("THD"))
  ICC.all[[i]] <- curr_ICC


  curr_model <- lm(
    formula = curr_formula, data = allelast,
    subset = curr_obsSel,
    weights = PRECISION
  )
  # compute clustered standard errors using REFERENCE as the clustering variable
  clust.vcov <- cluster.vcov(curr_model, subset(allelast, curr_obsSel)$REFERENCE)
  # clust.vcov <- coef_test(curr_model, vcov="CR1", cluster = unlist(subset(allelast, curr_obsSel)$REFERENCE), test = "Satterthwaite")

  # Note: The weights need to be normalized to facilitate comparison of the residual standard error from the various metaregressions
  # http://stats.stackexchange.com/questions/73966/in-weighted-least-squares-how-do-i-weight-the-residuals-to-get-an-accurate-z-s
  subsetString <- selectorSubsetString(selectorSets[i, ])
  subsetString2 <- paste(selectorSets[i, 1], selectorSets[i, 2], selectorSets[i, 3], sep = "_")
  printf("Subset selection: %s", selectorSubsetString(selectorSets[i, ]))
  printf("Formula estimated: %s", curr_formula)
  # print output from lm regression
  print(summary(curr_model, robust = F))
  # print coefficient tests using the clustered standard errors
  print(coeftest(curr_model, clust.vcov))

  ## Compute intraclass correlation coefficient of the residuals
  curr_resid.by.REF <- cbind(curr_elast.by.REF, curr_model$residuals)
  curr_resid.by.REF$RESIDUAL <- curr_resid.by.REF[, 3]
  curr_resid_ICC <- ICCest(REFERENCE, RESIDUAL, curr_resid.by.REF, alpha = 0.05, CI.type = c("THD"))
  ICC_resid.all[[i]] <- curr_resid_ICC

  # if needed, re-do analysis dropping vars for which coeff is "NA"
  if (NA %in% coefficients(curr_model)) {
    curr_varList <- curr_varList[!is.na(coefficients(curr_model)[-1])] # drop first coefficient (for constant) from coefficient list
    curr_formula <- paste("BETA", paste(curr_varList, collapse = "+"), sep = "~") # construct text string for formula (apparently required)
    curr_model <- lm(
      formula = curr_formula, data = allelast,
      subset = curr_obsSel,
      weights = PRECISION
    )

    # compute clustered standard errors using REFERENCE as the clustering variable
    clust.vcov <- cluster.vcov(curr_model, subset(allelast, curr_obsSel)$REFERENCE)
    # clust.vcov <- coef_test(curr_model, vcov = "CR2", cluster = subset(allelast, curr_obsSel)$REFERENCE, test = "Satterthwaite")

    printf("Subset selection: %s", selectorSubsetString(selectorSets[i, ]))
    printf("Formula estimated: %s", curr_formula)
  } else {
    (varinflation <- vif(curr_model))
  }
  print(varinflation)

  modelsEstimated[[i]] <- curr_model

  # Outlier analysis based on http://polisci.msu.edu/jacoby/icpsr/regress3/lectures/week3/11.Outliers.pdf (see, especially, slide 33)
  plot(hatvalues(curr_model), rstudent(curr_model),
    type = "n",
    main = "Influence Plot", xlab = "Hat Values", ylab = "Studentized Residuals"
  )
  cook <- sqrt(cooks.distance(curr_model))
  points(hatvalues(curr_model), rstudent(curr_model), cex = 10 * cook / max(cook))
  leverage_threshold <- 3 * ((length(curr_model$coefficients) + 1) / length(curr_model$fitted.values))
  abline(v = leverage_threshold, lty = 2) # line for hatvalues
  abline(h = c(-2, 0, 2), lty = 2) # lines for standardized residuals
  # Identify the outliers (we classify as outliers those obs whose studentized residuals are outside of the (-2,2) interval)
  curr_outliers <- curr_model$fitted.values[rstudent(curr_model) > 2 | rstudent(curr_model) < -2]
  rows_outliers <- as.numeric(names(curr_outliers))
  curr_obsSel2 <- curr_obsSel
  curr_obsSel2[rows_outliers] <- "FALSE"
  curr_obsSel2 <- as.logical(curr_obsSel2)

  ## Compute intraclass correlation coefficient
  curr_elast.by.REF2 <- allelast[curr_obsSel2, c("REFERENCE", "BETA")]
  curr_ICC2 <- ICCest(REFERENCE, BETA, curr_elast.by.REF2, alpha = 0.05, CI.type = c("THD"))
  ICC.all2[[i]] <- curr_ICC2

  ## MODEL ESTIMATION (POST-OUTLIER ANALYSIS)
  if (length(curr_obsSel2[curr_obsSel2 == "TRUE"]) < length(curr_obsSel[curr_obsSel == "TRUE"])) {
    currFAT2 <- lm(formula = BETA ~ ST_ERROR, data = allelast, subset = curr_obsSel2, weights = PRECISION)
    # Regression of st.error on effect size and dummy variable indicating whether standard error has been obtained directly from the paper or estimated
    currSEbias <- lm(formula = ST_ERROR ~ BETA + CALC_STERROR - 1, data = allelast, subset = curr_obsSel2)

    curr_model2 <- lm(
      formula = curr_formula, data = allelast,
      subset = curr_obsSel2,
      weights = PRECISION
    )

    curr_model2.lme <- lmer(
      formula = curr_formula.lme, data = allelast,
      subset = curr_obsSel2,
      weights = PRECISION, REML = FALSE
    )

    curr_model2.ols <- lm(
      formula = curr_formula.ols, data = allelast,
      subset = curr_obsSel2
    )

    # if needed, re-do analysis dropping vars for which coeff is "NA"
    if (NA %in% coefficients(curr_model2)) {
      curr_varList <- curr_varList[!is.na(coefficients(curr_model2)[-1])] # drop first coefficient (for constant) from coefficient list

      curr_formula <- paste("BETA", paste(curr_varList, collapse = "+"), sep = "~") # construct text string for formula (apparently required)
      curr_formula.lme <- paste(paste("BETA", paste(curr_varList, collapse = "+"), sep = "~"), "(1|REFERENCE)", sep = "+")
      curr_formula.ols <- paste("BETA", paste(curr_varList[curr_varList != "VARIANCE" & curr_varList != "CALC_STERROR"], collapse = "+"), sep = "~")

      curr_model2 <- lm(
        formula = curr_formula, data = allelast,
        subset = curr_obsSel2,
        weights = PRECISION
      )
      curr_model2.lme <- lmer(
        formula = curr_formula.lme, data = allelast,
        subset = curr_obsSel2,
        weights = PRECISION, REML = FALSE
      )
      curr_model2.ols <- lm(
        formula = curr_formula.ols, data = allelast,
        subset = curr_obsSel2
      )
    }

    # compute clustered standard errors for the WLS model using REFERENCE as the clustering variable
    clust.vcov.2 <- cluster.vcov(curr_model2, subset(allelast, curr_obsSel2)$REFERENCE)
    # substitute heteroskedasticity-consistent standard errors for default standard errors in OLS regressions
    # HC.vcov.2 <- sqrt(diag(vcovHC(curr_model2.ols)))
    HC.vcov.2 <- vcovHC(curr_model2.ols)

    ## Compute intraclass correlation coefficient of the residuals
    curr_resid.by.REF2 <- cbind(curr_elast.by.REF2, curr_model2$residuals)
    curr_resid.by.REF2$RESIDUAL <- curr_resid.by.REF2[, 3]
    curr_resid_ICC2 <- ICCest(REFERENCE, RESIDUAL, curr_resid.by.REF2, alpha = 0.05, CI.type = c("THD"))
    ICC_resid.all2[[i]] <- curr_resid_ICC2


    # End of Estimation
    # ==================

    # Print Results
    # =============
    printf("Subset selection: %s", selectorSubsetString(selectorSets[i, ]))
    printf("Formula estimated: %s", curr_formula)

    # Pre-model estimation tests
    plot(allelast[curr_obsSel2, "BETA"], allelast[curr_obsSel2, "PRECISION"],
      type = "p",
      main = "Funnel Plot", xlab = "Elasticity Values", ylab = "Precision (1/standard error)"
    )
    print(summary(currFAT2)) # print results from funnel asymmetry test
    print(summary(currSEbias)) # print results from testing whether there is bias in the standard errors that have been calculated

    # Results from WLS estimation
    print(summary(curr_model2, robust = F)) # print summary of WLS regression
    print(coeftest(curr_model2, clust.vcov.2)) # print coefficient tests of WLS regression based on clustered standard errors
    # Model diagnostics
    ## Model Fit
    plot(subset(allelast, curr_obsSel2)$BETA, curr_model2$fitted.values) # plot observed values versus fitted values
    abline(0, 1)
    ## Multicolinearity
    print(vif(curr_model2)) # print variance inflation factors
    ## Normality of residuals
    print(shapiro.test(curr_model2$residuals)) # Shapiro-Wilk normality test (null hypothesis: residuals are normally distributed)
    ## Heteroskedasticity
    plot(curr_model2$fitted.values, curr_model2$residuals, main = "Residuals vs. Fitted Values")
    print(bptest(curr_model2)) # print results from Breusch-Pagan test

    # Results from LME estimation
    print(summary(curr_model2.lme)) # print summary of linear mixed effect model

    # Likelihood-ratio test to compare the fit of the lme and ols model (null hypothesis: restricted model (OLS in this case) is better)
    print(lrtest(curr_model2.lme, curr_model2))

    # Results from OLS estimation
    print(summary(curr_model2.ols)) # print summary of OLS regression
    print(coeftest(curr_model2.ols, HC.vcov.2)) # print coefficient tests of OLS regression based on heteroskedasticity-consistent standard errors
    # print(summaryw(curr_model2.ols)) #print summary of OLS regression based on heteroskedasticity-consistent standard errors


    # Compute baseline elasticity and associated standard error
    # =========================================================

    # Create dataframe with as many rows as unique moderator variable names across the 8 metaregressions
    curr.baseline <- as.data.frame(Reduce(union, list(c("(Intercept)"), all_varList_P_SR.Transp, all_varList_P_LR.Transp, all_varList_P_SR.nonTransp, all_varList_P_LR.nonTransp, all_varList_Y_SR.Transp, all_varList_Y_LR.Transp, all_varList_Y_SR.nonTransp, all_varList_Y_LR.nonTransp)))

    colnames(curr.baseline)[1] <- "Varname"
    # Create a column that contains the values to be used for each variable in estimating elasticity baselines. Start with zeros as a placeholder and adjust as desired for each specific variable
    ## Note: 5 alternative baselines are computed for elasticity with respect to crude oil price, to a new price/income maximum, and to a new price/income maximum in petroleum product prices
    curr.baseline$Baseline.Value <- 0
    curr.baseline$Baseline.Value.OECD <- 0
    curr.baseline$Baseline.Value.nonOECD <- 0
    curr.baseline$Baseline.Value.Max <- 0
    curr.baseline$Baseline.Value.ProdPMax <- 0

    ## Baseline elasticity with respect to crude oil price
    eval.one <- c("(Intercept)")
    eval.mean <- c("YrAvg.cent", "rgdpe_cap.1998.cent", "DslTransp", "FuelSwitch", "SPEEDYRS.cent", "CS", "CSTS", "OECD", "Monthly", "Quarterly")
    eval.mixed <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") # These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
    eval.mixed2 <- c("VehStk") # These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
    curr.baseline$Baseline.Value[curr.baseline$Varname %in% eval.one] <- 1

    ## Baseline elasticity with respect to crude oil price in OECD
    eval.one.OECD <- c("(Intercept)", "OECD")
    # eval.mean.OECD <- c("YrAvg.cent","DslTransp","FuelSwitch","SPEEDYRS.cent","CS","CSTS")
    eval.region.OECD <- c("rgdpe_cap.1998.cent", "YrAvg.cent", "DslTransp", "FuelSwitch", "SPEEDYRS.cent", "CS", "CSTS", "Monthly", "Quarterly")
    eval.mixed.OECD <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") # These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
    eval.mixed2.OECD <- c("VehStk") # These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
    curr.baseline$Baseline.Value.OECD[curr.baseline$Varname %in% eval.one.OECD] <- 1

    ## Baseline elasticity with respect to crude oil price in non-OECD
    eval.one.nonOECD <- c("(Intercept)")
    # eval.mean.nonOECD <- c("YrAvg.cent","DslTransp","FuelSwitch","SPEEDYRS.cent","CS","CSTS")
    eval.region.nonOECD <- c("rgdpe_cap.1998.cent", "YrAvg.cent", "DslTransp", "FuelSwitch", "SPEEDYRS.cent", "CS", "CSTS", "Monthly", "Quarterly")
    eval.mixed.nonOECD <- c("StaticP", "StaticY", "StaticP.CS", "StaticY.CS") # These variables are evaluated at 0 for short-run elasts and at the mean for long-run elasts.
    eval.mixed2.nonOECD <- c("VehStk") # These variables are evaluated at the mean for short-run elasts and at zero for long-run elasts.
    curr.baseline$Baseline.Value.nonOECD[curr.baseline$Varname %in% eval.one.nonOECD] <- 1

    ## Baseline elasticity with respect to a new max in crude oil price
    eval.one.max <- c("(Intercept)", "Pmax", "Ymax")
    curr.baseline$Baseline.Value.Max[curr.baseline$Varname %in% eval.one.max] <- 1

    ## Baseline elasticity with respect to a new max in petroleum product prices
    eval.one.prodpmax <- c("(Intercept)", "Pmax", "Ymax", "EndUserP")
    eval.mean.prodpmax <- c("YrAvg.cent", "rgdpe_cap.1998.cent", "DslTransp", "FuelSwitch", "SPEEDYRS.cent", "CS", "CSTS", "OECD", "Monthly", "Quarterly", "PRICE.1998.cent")
    curr.baseline$Baseline.Value.ProdPMax[curr.baseline$Varname %in% eval.one.prodpmax] <- 1


    for (j in 1:nrow(curr.baseline)) {
      # Adjust value of moderator variables to be used in estimating elasticity baselines for members of the sets defined above to take values different from 0 or 1
      curr.baseline$Baseline.Value[j] <-
        ifelse(curr.baseline$Varname[j] %in% eval.mixed & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
          ifelse(curr.baseline$Varname[j] %in% eval.mixed & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
            ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
              ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                ifelse(curr.baseline$Varname[j] %in% eval.mean & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                  curr.baseline$Baseline.Value[j]
                )
              )
            )
          )
        )


      curr.baseline$Baseline.Value.OECD[j] <-
        ifelse(curr.baseline$Varname[j] %in% eval.mixed.OECD & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
          ifelse(curr.baseline$Varname[j] %in% eval.mixed.OECD & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])) / sum(allelast[curr_obsSel2, "OECD"]),
            ifelse(curr.baseline$Varname[j] %in% eval.mixed2.OECD & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])) / sum(allelast[curr_obsSel2, "OECD"]),
              ifelse(curr.baseline$Varname[j] %in% eval.mixed2.OECD & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                ifelse(curr.baseline$Varname[j] %in% eval.region.OECD & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * allelast[curr_obsSel2, "OECD"])) / sum(allelast[curr_obsSel2, "OECD"]),
                  curr.baseline$Baseline.Value.OECD[j]
                )
              )
            )
          )
        )


      curr.baseline$Baseline.Value.nonOECD[j] <-
        ifelse(curr.baseline$Varname[j] %in% eval.mixed.nonOECD & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
          ifelse(curr.baseline$Varname[j] %in% eval.mixed.nonOECD & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))) / ((-1) * (sum(allelast[curr_obsSel2, "OECD"] - 1))),
            ifelse(curr.baseline$Varname[j] %in% eval.mixed2.nonOECD & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))) / ((-1) * (sum(allelast[curr_obsSel2, "OECD"] - 1))),
              ifelse(curr.baseline$Varname[j] %in% eval.mixed2.nonOECD & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                ifelse(curr.baseline$Varname[j] %in% eval.region.nonOECD & !is.na(sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))), (sum(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))] * (-1) * (allelast[curr_obsSel2, "OECD"] - 1))) / ((-1) * (sum(allelast[curr_obsSel2, "OECD"] - 1))),
                  curr.baseline$Baseline.Value.nonOECD[j]
                )
              )
            )
          )
        )


      curr.baseline$Baseline.Value.Max[j] <- ifelse(curr.baseline$Varname[j] %in% eval.mixed & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
        ifelse(curr.baseline$Varname[j] %in% eval.mixed & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
          ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
            ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
              ifelse(curr.baseline$Varname[j] %in% eval.mean & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                curr.baseline$Baseline.Value.Max[j]
              )
            )
          )
        )
      )

      curr.baseline$Baseline.Value.ProdPMax[j] <- ifelse(curr.baseline$Varname[j] %in% eval.mixed & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
        ifelse(curr.baseline$Varname[j] %in% eval.mixed & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
          ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "SR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
            ifelse(curr.baseline$Varname[j] %in% eval.mixed2 & "LR" %in% substr(selectorSets[i, 1], 1, 4) & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), 0 * mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
              ifelse(curr.baseline$Varname[j] %in% eval.mean.prodpmax & !is.na(mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))])), mean(allelast[curr_obsSel2, c(as.character(curr.baseline$Varname[j]))]),
                curr.baseline$Baseline.Value.ProdPMax[j]
              )
            )
          )
        )
      )



      curr.baseline$include[j] <- ifelse(curr.baseline$Varname[j] %in% names(coefficients(curr_model2)), 1, 0)
      ## extract info from WLS estimation
      curr.baseline$coef.est[j] <- ifelse(curr.baseline$include[j] == "1", coef(summary(curr_model2))[as.character(curr.baseline$Varname[j]), 1], 0)
      curr.baseline$st.error[j] <- ifelse(curr.baseline$include[j] == "1", coef(summary(curr_model2))[as.character(curr.baseline$Varname[j]), 2], 0)
      curr.baseline$clust.error[j] <- ifelse(curr.baseline$include[j] == "1", coeftest(curr_model2, clust.vcov.2)[as.character(curr.baseline$Varname[j]), 2], 0)
      ## extract info from LME estimation
      curr.baseline$coef.est.LME[j] <- ifelse(curr.baseline$include[j] == "1", coef(summary(curr_model2.lme))[as.character(curr.baseline$Varname[j]), 1], 0)
      curr.baseline$st.error.LME[j] <- ifelse(curr.baseline$include[j] == "1", coef(summary(curr_model2.lme))[as.character(curr.baseline$Varname[j]), 2], 0)
      ## extract info from OLS estimation
      curr.baseline$include.ols[j] <- ifelse(curr.baseline$Varname[j] %in% names(coefficients(curr_model2.ols)), 1, 0)
      curr.baseline$coef.est.OLS[j] <- ifelse(curr.baseline$include.ols[j] == "1", coef(summary(curr_model2.ols))[as.character(curr.baseline$Varname[j]), 1], 0)
      curr.baseline$st.error.OLS[j] <- ifelse(curr.baseline$include.ols[j] == "1", coef(summary(curr_model2.ols))[as.character(curr.baseline$Varname[j]), 2], 0)
      # curr.baseline$HC.error[j]  <-  ifelse(curr.baseline$include[j] == "1", coef(summaryw(curr_model2.ols))[as.character(curr.baseline$Varname[j]),2], 0)
      curr.baseline$HC.error[j] <- ifelse(curr.baseline$include.ols[j] == "1", coeftest(curr_model2.ols, HC.vcov.2)[as.character(curr.baseline$Varname[j]), 2], 0)
    }

    # Compute baseline and standard error
    curr.baseline <- mutate(curr.baseline,
      comp.mean = include * Baseline.Value * coef.est,
      comp.sterror = (include * Baseline.Value * st.error)**2,
      comp.clusterror = (include * Baseline.Value * clust.error)**2,
      comp.mean.LME = include * Baseline.Value * coef.est.LME,
      comp.sterror.LME = (include * Baseline.Value * st.error.LME)**2,
      comp.mean.ols = include * Baseline.Value * coef.est.OLS,
      comp.sterror.ols = (include * Baseline.Value * st.error.OLS)**2,
      comp.HCerror = (include * Baseline.Value * HC.error)**2,
      comp.mean.OECD = include * Baseline.Value.OECD * coef.est,
      comp.sterror.OECD = (include * Baseline.Value.OECD * st.error)**2,
      comp.clusterror.OECD = (include * Baseline.Value.OECD * clust.error)**2,
      comp.mean.LME.OECD = include * Baseline.Value.OECD * coef.est.LME,
      comp.sterror.LME.OECD = (include * Baseline.Value.OECD * st.error.LME)**2,
      comp.mean.ols.OECD = include * Baseline.Value.OECD * coef.est.OLS,
      comp.sterror.ols.OECD = (include * Baseline.Value.OECD * st.error.OLS)**2,
      comp.HCerror.OECD = (include * Baseline.Value.OECD * HC.error)**2,
      comp.mean.nonOECD = include * Baseline.Value.nonOECD * coef.est,
      comp.sterror.nonOECD = (include * Baseline.Value.nonOECD * st.error)**2,
      comp.clusterror.nonOECD = (include * Baseline.Value.nonOECD * clust.error)**2,
      comp.mean.LME.nonOECD = include * Baseline.Value.nonOECD * coef.est.LME,
      comp.sterror.LME.nonOECD = (include * Baseline.Value.nonOECD * st.error.LME)**2,
      comp.mean.ols.nonOECD = include * Baseline.Value.nonOECD * coef.est.OLS,
      comp.sterror.ols.nonOECD = (include * Baseline.Value.nonOECD * st.error.OLS)**2,
      comp.HCerror.nonOECD = (include * Baseline.Value.nonOECD * HC.error)**2,
      comp.mean.max = include * Baseline.Value.Max * coef.est,
      comp.sterror.max = (include * Baseline.Value.Max * st.error)**2,
      comp.clusterror.max = (include * Baseline.Value.Max * clust.error)**2,
      comp.mean.LME.max = include * Baseline.Value.Max * coef.est.LME,
      comp.sterror.LME.max = (include * Baseline.Value.Max * st.error.LME)**2,
      comp.mean.ols.max = include * Baseline.Value.Max * coef.est.OLS,
      comp.sterror.ols.max = (include * Baseline.Value.Max * st.error.OLS)**2,
      comp.HCerror.max = (include * Baseline.Value.Max * HC.error)**2,
      comp.mean.prodpmax = include * Baseline.Value.ProdPMax * coef.est,
      comp.sterror.prodpmax = (include * Baseline.Value.ProdPMax * st.error)**2,
      comp.clusterror.prodpmax = (include * Baseline.Value.ProdPMax * clust.error)**2,
      comp.mean.LME.prodpmax = include * Baseline.Value.ProdPMax * coef.est.LME,
      comp.sterror.LME.prodpmax = (include * Baseline.Value.ProdPMax * st.error.LME)**2,
      comp.mean.ols.prodpmax = include * Baseline.Value.ProdPMax * coef.est.OLS,
      comp.sterror.ols.prodpmax = (include * Baseline.Value.ProdPMax * st.error.OLS)**2,
      comp.HCerror.prodpmax = (include * Baseline.Value.ProdPMax * HC.error)**2
    )

    baseline.comps[[i]] <- curr.baseline

    base_elast <- sum(curr.baseline$comp.mean)
    stdv_base_elast <- sqrt(sum(curr.baseline$comp.sterror))
    stdv_base_elast.clustse <- sqrt(sum(curr.baseline$comp.clusterror))
    base_elast.LME <- sum(curr.baseline$comp.mean.LME)
    stdv_base_elast.LME <- sqrt(sum(curr.baseline$comp.sterror.LME))
    base_elast.OLS <- sum(curr.baseline$comp.mean.ols)
    stdv_base_elast.OLS <- sqrt(sum(curr.baseline$comp.sterror.ols))
    stdv_base_elast.HCse <- sqrt(sum(curr.baseline$comp.HCerror))

    base_elast.OECD <- sum(curr.baseline$comp.mean.OECD)
    stdv_base_elast.OECD <- sqrt(sum(curr.baseline$comp.sterror.OECD))
    stdv_base_elast.clustse.OECD <- sqrt(sum(curr.baseline$comp.clusterror.OECD))
    base_elast.LME.OECD <- sum(curr.baseline$comp.mean.LME.OECD)
    stdv_base_elast.LME.OECD <- sqrt(sum(curr.baseline$comp.sterror.LME.OECD))
    base_elast.OLS.OECD <- sum(curr.baseline$comp.mean.ols.OECD)
    stdv_base_elast.OLS.OECD <- sqrt(sum(curr.baseline$comp.sterror.ols.OECD))
    stdv_base_elast.HCse.OECD <- sqrt(sum(curr.baseline$comp.HCerror.OECD))

    base_elast.nonOECD <- sum(curr.baseline$comp.mean.nonOECD)
    stdv_base_elast.nonOECD <- sqrt(sum(curr.baseline$comp.sterror.nonOECD))
    stdv_base_elast.clustse.nonOECD <- sqrt(sum(curr.baseline$comp.clusterror.nonOECD))
    base_elast.LME.nonOECD <- sum(curr.baseline$comp.mean.LME.nonOECD)
    stdv_base_elast.LME.nonOECD <- sqrt(sum(curr.baseline$comp.sterror.LME.nonOECD))
    base_elast.OLS.nonOECD <- sum(curr.baseline$comp.mean.ols.nonOECD)
    stdv_base_elast.OLS.nonOECD <- sqrt(sum(curr.baseline$comp.sterror.ols.nonOECD))
    stdv_base_elast.HCse.nonOECD <- sqrt(sum(curr.baseline$comp.HCerror.nonOECD))

    base_elast.max <- sum(curr.baseline$comp.mean.max)
    stdv_base_elast.max <- sqrt(sum(curr.baseline$comp.sterror.max))
    stdv_base_elast.clustse.max <- sqrt(sum(curr.baseline$comp.clusterror.max))
    base_elast.LME.max <- sum(curr.baseline$comp.mean.LME.max)
    stdv_base_elast.LME.max <- sqrt(sum(curr.baseline$comp.sterror.LME.max))
    base_elast.OLS.max <- sum(curr.baseline$comp.mean.ols.max)
    stdv_base_elast.OLS.max <- sqrt(sum(curr.baseline$comp.sterror.ols.max))
    stdv_base_elast.HCse.max <- sqrt(sum(curr.baseline$comp.HCerror.max))

    base_elast.prodpmax <- sum(curr.baseline$comp.mean.prodpmax)
    stdv_base_elast.prodpmax <- sqrt(sum(curr.baseline$comp.sterror.prodpmax))
    stdv_base_elast.clustse.prodpmax <- sqrt(sum(curr.baseline$comp.clusterror.prodpmax))
    base_elast.LME.prodpmax <- sum(curr.baseline$comp.mean.LME.prodpmax)
    stdv_base_elast.LME.prodpmax <- sqrt(sum(curr.baseline$comp.sterror.LME.prodpmax))
    base_elast.OLS.prodpmax <- sum(curr.baseline$comp.mean.ols.prodpmax)
    stdv_base_elast.OLS.prodpmax <- sqrt(sum(curr.baseline$comp.sterror.ols.prodpmax))
    stdv_base_elast.HCse.prodpmax <- sqrt(sum(curr.baseline$comp.HCerror.prodpmax))

    raw_mean <- mean(allelast[curr_obsSel2, c("BETA")])
    raw_stdev <- sd(allelast[curr_obsSel2, c("BETA")])
    npapers <- length(unique(subset(allelast, curr_obsSel2)$REFERENCE))
    product.p.obs <- sum(allelast[curr_obsSel2, c("EndUserP")])
    speedyrs.mean <- round(mean(allelast[curr_obsSel2, c("SPEEDYRS")]), 4)
    speedyrs.mean.OECD <- round((sum(allelast[curr_obsSel2, c("SPEEDYRS")] * allelast[curr_obsSel2, c("OECD")]) / sum(allelast[curr_obsSel2, c("OECD")])), 4)
    speedyrs.mean.nonOECD <- round((sum(allelast[curr_obsSel2, c("SPEEDYRS")] * (-1) * (allelast[curr_obsSel2, c("OECD")] - 1)) / ((-1) * sum(allelast[curr_obsSel2, c("OECD")] - 1))), 4)
    yravg.mean <- round(mean(allelast[curr_obsSel2, c("YrAvg.avg")]), 4)
    rgdpe1998.mean <- round(mean(allelast[curr_obsSel2, c("rgdpe_cap.1998.avg")]), 4)
    adj_r_sq.wls <- summary(curr_model2)$adj.r.squared
    adj_r_sq.ols <- summary(curr_model2.ols)$adj.r.squared
    uniqueobs <- nrow(allelast[curr_obsSel2, c("REFERENCE", curr_varList_minusVARIANCE)][!duplicated(allelast[curr_obsSel2, c("REFERENCE", curr_varList_minusVARIANCE)]), ])

    pubbias.test[[i]] <- cbind(as.data.frame(rep(subsetString2, 2)), tidy(currFAT2))
    obsSel2[[i]] <- allelast[curr_obsSel2, ]
    modelsEstimated2[[i]] <- tidy(curr_model2)
    modelsEstimated2.raw[[i]] <- curr_model2
    coeffsEstimated2[[i]] <- coeftest(curr_model2, clust.vcov.2)
    WLS.elastID[[i]] <- data.frame(ElastID = rep(subsetString2, nrow(coeffsEstimated2[[i]])))

    modelsEstimated2.LME[[i]] <- tidy(curr_model2.lme)
    modelsEstimated2.LME.raw[[i]] <- curr_model2.lme
    LME.elastID[[i]] <- data.frame(ElastID = rep(subsetString2, nrow(modelsEstimated2.LME[[i]])))
    vifEstimated2[[i]] <- vif(curr_model2)

    LRT[[i]] <- lrtest(curr_model2.lme, curr_model2)

    modelsEstimated2.OLS[[i]] <- tidy(curr_model2.ols)
    coeffsEstimated2.OLS[[i]] <- coeftest(curr_model2.ols, HC.vcov.2)
    modelsEstimated2.OLS.raw[[i]] <- curr_model2.ols
    OLS.elastID[[i]] <- data.frame(ElastID = rep(subsetString2, nrow(coeffsEstimated2.OLS[[i]])))


    baselinesEstimated[[i]] <- c(
      subsetString2,
      round(raw_mean, 4),
      round(raw_stdev, 4),
      ## WLS-related results
      round(mean(curr_model2$fitted.values), 4),
      as.numeric(round(glance(curr_model2)$sigma, 4)),
      round(adj_r_sq.wls, 2),
      as.numeric(round(base_elast, 6)),
      as.numeric(round(stdv_base_elast, 6)),
      as.numeric(round(stdv_base_elast.clustse, 6)),
      as.numeric(round(base_elast.OECD, 6)),
      as.numeric(round(stdv_base_elast.OECD, 6)),
      as.numeric(round(stdv_base_elast.clustse.OECD, 6)),
      as.numeric(round(base_elast.nonOECD, 6)),
      as.numeric(round(stdv_base_elast.nonOECD, 6)),
      as.numeric(round(stdv_base_elast.clustse.nonOECD, 6)),
      as.numeric(round(base_elast.max, 6)),
      as.numeric(round(stdv_base_elast.max, 6)),
      as.numeric(round(stdv_base_elast.clustse.max, 6)),
      as.numeric(round(base_elast.prodpmax, 6)),
      as.numeric(round(stdv_base_elast.prodpmax, 6)),
      as.numeric(round(stdv_base_elast.clustse.prodpmax, 6)),

      ## LME-related results
      round(mean(pull(augment(curr_model2.lme)[, ".fitted"])), 4),
      as.numeric(round(glance(curr_model2.lme)$sigma, 4)),
      as.numeric(round(base_elast.LME, 6)),
      as.numeric(round(stdv_base_elast.LME, 6)),
      as.numeric(round(base_elast.LME.OECD, 6)),
      as.numeric(round(stdv_base_elast.LME.OECD, 6)),
      as.numeric(round(base_elast.LME.nonOECD, 6)),
      as.numeric(round(stdv_base_elast.LME.nonOECD, 6)),
      as.numeric(round(base_elast.LME.max, 6)),
      as.numeric(round(stdv_base_elast.LME.max, 6)),
      as.numeric(round(base_elast.LME.prodpmax, 6)),
      as.numeric(round(stdv_base_elast.LME.prodpmax, 6)),

      # Likelihood ratio test
      round(lrtest(curr_model2.lme, curr_model2)[nrow(lrtest(curr_model2.lme, curr_model2)), 5], 4),
      ## OLS-related results
      round(mean(curr_model2.ols$fitted.values), 4),
      as.numeric(round(glance(curr_model2.ols)$sigma, 4)),
      round(adj_r_sq.ols, 2),
      as.numeric(round(base_elast.OLS, 6)),
      as.numeric(round(stdv_base_elast.OLS, 6)),
      as.numeric(round(stdv_base_elast.HCse, 6)),
      as.numeric(round(base_elast.OLS.OECD, 6)),
      as.numeric(round(stdv_base_elast.OLS.OECD, 6)),
      as.numeric(round(stdv_base_elast.HCse.OECD, 6)),
      as.numeric(round(base_elast.OLS.nonOECD, 6)),
      as.numeric(round(stdv_base_elast.OLS.nonOECD, 6)),
      as.numeric(round(stdv_base_elast.HCse.nonOECD, 6)),
      as.numeric(round(base_elast.OLS.max, 6)),
      as.numeric(round(stdv_base_elast.OLS.max, 6)),
      as.numeric(round(stdv_base_elast.HCse.max, 6)),
      as.numeric(round(base_elast.OLS.prodpmax, 6)),
      as.numeric(round(stdv_base_elast.OLS.prodpmax, 6)),
      as.numeric(round(stdv_base_elast.HCse.prodpmax, 6)),

      # Other summary metrics
      length(curr_model2$residuals),
      uniqueobs,
      npapers,
      product.p.obs,
      speedyrs.mean,
      speedyrs.mean.OECD,
      speedyrs.mean.nonOECD,
      yravg.mean,
      rgdpe1998.mean
    )
  }
}
### End of metaregression loop
```

```{r metareg.store, echo = FALSE, warning =FALSE, message=FALSE }
# Store metaregression coefficients and metaregression id strings from WLS, LME, and OLS specifications into data.frames to be bound and exported to a .csv file

## WLS
metareg.results2 <- do.call("rbind", modelsEstimated2) ## store metaregression coefficients into a dataframe
## WLS with clustered standard errors
coefs.clust.se <- function(x) {
  round(x[, c(1:4)], 8)
}
metareg.results.clust.se <- lapply(coeffsEstimated2, coefs.clust.se)
coefs.all.clust.se <- (do.call("rbind", metareg.results.clust.se))
coefs.all.clust.se <- rownames_to_column(as.data.frame(coefs.all.clust.se), "variable")
WLS.elastIDs <- (do.call("rbind", WLS.elastID))
coefs.all.clust.se.ID <- cbind(WLS.elastIDs, coefs.all.clust.se)
coefs.all.clust.se.ID <- as.data.frame(coefs.all.clust.se.ID)

## LME
LME.elastIDs <- (do.call("rbind", LME.elastID))
modelsEstimated2.LME.all <- do.call(rbind, modelsEstimated2.LME)
coefs.all.LME.ID <- cbind(LME.elastIDs, modelsEstimated2.LME.all)

## OLS
metareg.results2.OLS <- do.call("rbind", modelsEstimated2.OLS) ## store metaregression coefficients into a dataframe
## OLS with heteroskedasticity-consistent standard errors
coefs.hc.se <- function(x) {
  round(x[, c(1:4)], 8)
}
metareg.results.hc.se <- lapply(coeffsEstimated2.OLS, coefs.hc.se)
# metareg.results.hc.se <- lapply(summaryw(modelsEstimated2.OLS), coefs.hc.se)
coefs.all.hc.se <- (do.call("rbind", metareg.results.hc.se))
coefs.all.hc.se <- rownames_to_column(as.data.frame(coefs.all.hc.se), "variable")
OLS.elastIDs <- (do.call("rbind", OLS.elastID))
coefs.all.hc.se.ID <- cbind(OLS.elastIDs, coefs.all.hc.se)
coefs.all.hc.se.ID <- as.data.frame(coefs.all.hc.se.ID)

write.csv(coefs.all.clust.se.ID, "../Output/coefs.WLS.csv")
write.csv(coefs.all.LME.ID, "../Output/coefs.LME.csv")
write.csv(coefs.all.hc.se.ID, "../Output/coefs.OLS.csv")

## Store variance inflation factors into a data.frame
vifs.all.df2 <- data.frame(matrix(unlist(vifEstimated2)))
colnames(vifs.all.df2) <- "VIF"

all_baselinesEstimated <- do.call(rbind, baselinesEstimated) %>%
  as.data.frame() %>%
  mutate_at(c("V1"), as.factor) %>%
  mutate_if(is.character, as.numeric)

colnames(all_baselinesEstimated) <- c(
  "subsetString", "raw.mean", "raw.stdev",
  "fittedmean.WLS", "sigma.WLS", "R2adj.WLS",
  "baseline.WLS", "sterror.baseline.WLS", "clust.sterror.baseline.WLS",
  "baseline.WLS.OECD", "sterror.baseline.WLS.OECD", "clust.sterror.baseline.WLS.OECD",
  "baseline.WLS.nonOECD", "sterror.baseline.WLS.nonOECD", "clust.sterror.baseline.WLS.nonOECD",
  "baseline.WLS.max", "sterror.baseline.WLS.max", "clust.sterror.baseline.WLS.max",
  "baseline.WLS.prodpmax", "sterror.baseline.WLS.prodpax", "clust.sterror.baseline.WLS.prodpmax",
  "fittedmean.LME", "sigma.LME",
  "baseline.LME", "sterror.baseline.LME",
  "baseline.LME.OECD", "sterror.baseline.LME.OECD",
  "baseline.LME.nonOECD", "sterror.baseline.LME.nonOECD",
  "baseline.LME.max", "sterror.baseline.LME.max",
  "baseline.LME.prodpmax", "sterror.baseline.LME.prodpmax",
  "LRT_pvalue",
  "fittedmean.OLS", "sigma.OLS", "R2adj.OLS",
  "baseline.OLS", "sterror.baseline.OLS", "hc.sterror.baseline.OLS",
  "baseline.OLS.OECD", "sterror.baseline.OLS.OECD", "hc.sterror.baseline.OLS.OECD",
  "baseline.OLS.nonOECD", "sterror.baseline.OLS.nonOECD", "hc.sterror.baseline.OLS.nonOECD",
  "baseline.OLS.max", "sterror.baseline.OLS.max", "hc.sterror.baseline.OLS.max",
  "baseline.OLS.prodpmax", "sterror.baseline.OLS.prodpmax", "hc.sterror.baseline.OLS.prodpmax",
  "n.obs", "unique.obs", "n.papers", "product.p.obs", "mean.SPEEDYRS", "mean.SPEEDYRS.OECD", "mean.SPEEDYRS.nonOECD", "mean.YrAvg", "mean.rgdpe1998"
)


all_baselinesEstimated <- all_baselinesEstimated %>%
  mutate(
    raw.coeffvar = raw.mean / raw.stdev,
    WLS.coeffvar = baseline.WLS / clust.sterror.baseline.WLS,
    OLS.coeffvar = baseline.OLS / hc.sterror.baseline.OLS,
    LME.coeffvar = baseline.LME / sterror.baseline.LME,
  )

# For each elasticity grouping, select the baseline to be used for computing world oil demand elasticities out of the three model specifications estimated: WLS with clustered standard errors, OLS with heteroskedasticity-consistent standard errors, or linear mixed effects (LME)
all_baselinesEstimated <- all_baselinesEstimated %>%
  mutate(
    fittedmean = ifelse(LRT_pvalue < 0.05, fittedmean.LME, fittedmean.WLS),
    sigma = ifelse(LRT_pvalue < 0.05, sigma.LME, sigma.WLS),
    baseline = ifelse(LRT_pvalue < 0.05, baseline.LME, baseline.WLS),
    sterror.baseline = ifelse(LRT_pvalue < 0.05, sterror.baseline.LME, clust.sterror.baseline.WLS),
    baseline.OECD = ifelse(LRT_pvalue < 0.05, baseline.LME.OECD, baseline.WLS.OECD),
    sterror.baseline.OECD = ifelse(LRT_pvalue < 0.05, sterror.baseline.LME.OECD, clust.sterror.baseline.WLS.OECD),
    baseline.nonOECD = ifelse(LRT_pvalue < 0.05, baseline.LME.nonOECD, baseline.WLS.nonOECD),
    sterror.baseline.nonOECD = ifelse(LRT_pvalue < 0.05, sterror.baseline.LME.nonOECD, clust.sterror.baseline.WLS.nonOECD),
    baseline.max = ifelse(LRT_pvalue < 0.05, baseline.LME.max, baseline.WLS.max),
    sterror.baseline.max = ifelse(LRT_pvalue < 0.05, sterror.baseline.LME.max, clust.sterror.baseline.WLS.max),
    baseline.prodpmax = ifelse(LRT_pvalue < 0.05, baseline.LME.prodpmax, baseline.WLS.prodpmax),
    sterror.baseline.prodpmax = ifelse(LRT_pvalue < 0.05, sterror.baseline.LME.prodpmax, clust.sterror.baseline.WLS.prodpmax)
  )

# print(all_baselinesEstimated)
write.csv(all_baselinesEstimated, file = "../Output/baselines.csv")
```


3. Metaregression analysis: methods and explanatory variables
===========================================================  

Our model specification and estimation method choices address the econometric issues that are typically present in energy and resource economics meta-analyses applications (e.g., Bel and Gradus (2016); Havranek and Kokes (2015); Ma et al. (2015); Daniel et al. (2009)). The starting point for metaregression specification is a linear relationship between a set of elasticity estimates $\beta_i$, an intercept $\alpha_0$, the set of explanatory variables $X$ associated to the elasticity estimates, and a residual for each elasticity estimate $e_i$.
$$\beta_i = \alpha_0 + \sum_{k=1}^K \alpha_i*X_{i,k} + e_i$$ 

**a) Variance heterogeneity (heteroskedasticity)**  
When variances of the elasticity estimates $\beta_i$ are known, Borenstein et al.(2009) and Nelson and Kennedy(2009) recommend giving more weight to the more precise ones. We follow that approach to address the issue of variance heterogeneity and estimate the model using weighted least squares with the inverse of standard error of each estimate $(1/se_i)$ as weights.
$$\frac{\beta_i}{se_i} = \frac{\alpha_0}{se_i} + \sum_{k=1}^K \alpha_i*\frac{X_{i,k}}{se_i} + \epsilon_i$$    

**b) Publication bias**  
Publication bias arises when the sample of published estimates is not a random sample of the full population of estimates. The bias results from researchers being more likely to submit, and journals being more likely to publish, studies finding larger effect sizes and/or estimates conforming to the theoretically expected sign. The panels in Figure 3 are funnel plots showing the relationship between the inverse of the standard error (i.e., precision) on the y-axis and the effect size on the x-axis for each of the 8 elasticity groupings. The more asymmetric a funnel plot is around the most precise estimate, the stronger publication bias there is (Havranek et al., 2012). Funnel asymmetry tests confirmed statistically significant asymmetry at the 10% confidence level in 7 of the 8 metaregressions. Long-run income elasticities in non-transportation sector is the only grouping for which funnel asymmetry can be rejected at the 10% confidence level.

```{r outFunnelPlots, echo = FALSE, warning =FALSE, message=FALSE }
ElastID2 <- c(
  "Price \nShortRun-\nTransportation", "Price \nShortRun-\nnonTransportation", "Price \nLongRun-\nTransportation", "Price \nLongRun-\nnonTransportation",
  "Income \nShortRun-\nTransportation", "Income \nShortRun-\nnonTransportation", "Income \nLongRun-\nTransportation", "Income \nLongRun-\nnonTransportation"
)
ElastIDmatch2 <- data.frame(Type_Sector, ElastID2)
ElastIDmatch2$ElastID2 <- factor(ElastIDmatch2$ElastID2, levels = c(
  "Price \nShortRun-\nTransportation", "Price \nShortRun-\nnonTransportation", "Price \nLongRun-\nTransportation", "Price \nLongRun-\nnonTransportation",
  "Income \nShortRun-\nTransportation", "Income \nShortRun-\nnonTransportation", "Income \nLongRun-\nTransportation", "Income \nLongRun-\nnonTransportation"
))

obsSel2.df <- do.call("rbind", obsSel2) %>%
  mutate(Type_Sector = as.factor(paste(TYPE_LENGTH2, RoadTransp, OtherSector, sep = "_"))) %>%
  left_join(ElastIDmatch2, by = "Type_Sector")

funnel.plots <- ggplot(obsSel2.df, aes(x = BETA, y = PRECISION, label = sprintf("%0.2f", round(BETA, digits = 1)))) +
  geom_point(size = 1) +
  facet_wrap(~ElastID2, ncol = 4, scales = "free") +
  scale_x_continuous(labels = comma_format(), breaks = pretty_breaks(n = 8)) +
  scale_y_continuous(labels = comma_format(), breaks = pretty_breaks(n = 6)) +
  labs(x = "Elasticity", y = "Precision", title = "") +
  theme(strip.text.x = element_text(size = 9)) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(axis.text.x = element_text(size = 10, angle = 65, hjust = 1), axis.text.y = element_text(size = 10), axis.title = element_text(size = 10, face = "bold")) +
  theme(legend.text = element_text(size = 10), legend.title = element_blank(), legend.key = element_blank(), legend.position = "right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
funnel.plots
ggsave("../Output/funnel.plots.png", width = 6.5, height = 4.5, units = "in", dpi = 600)

pub.bias.test <- do.call("rbind", pubbias.test) %>%
  rename(Type_Sector = `rep(subsetString2, 2)`) %>%
  left_join(ElastIDmatch, by = "Type_Sector") %>%
  mutate(
    Type = as.factor(ifelse(substr(Type_Sector, 1, 1) == "P", "Price", "Income")),
    Length.of.Run = as.factor(ifelse(grepl("Long", ElastID) == T, "Long Run", "Short Run")),
    Sector = as.factor(ifelse(grepl("non", ElastID), "nonTransportation", "Transportation"))
  ) %>%
  mutate_if(is.numeric, round, 3) %>%
  select(Type, Length.of.Run, Sector, estimate, std.error, statistic, ElastID)

# kable(pub.bias.test, digits = 3, caption = "Table 1. Results from Funnel Asymmetry Tests")
```

**Figure 3. Funnel plots by elasticity grouping**

To correct for publication bias, we implement the _precision-effect estimate with standard error_ (PEESE) method outlined in Stanley and Doucouliagos (2007) in which the variance of the effect sizes is included as one of the moderator variables in a weighted least squares estimation. PEESE is a modified version of the Heckman regression used to address sample selection bias. PEESE uses the heteroscedastic nature of standard errors in a meta-analysis database to capture the relationship between the precision of elasticity estimates and their probability of being published.  
$$\frac{\beta_i}{se_i} = \frac{\alpha_0}{se_i} +\eta_0*se_i+ \sum_{k=1}^K \alpha_i*\frac{X_{i,k}}{se_i} + \epsilon_i$$  

**c) Within-study correlation of residuals**  
Most primary studies produce more than one elasticity estimate. In our database, we find that multiple effect sizes from the same paper typically result from authors reporting results from multiple estimation methods or segmenting their datasets by household characteristics, geographical units, or time periods. Each additional estimate from the same study provides less additional information that an estimate from a different study and should be weighted accordingly in the metaregression.^[We argue that overweighting will be less severe if the metaregression includes moderator variables to capture the various data segments and estimation methods in each paper. We computed the number of "unique" observations in each grouping as those for which at least one of the moderator variables (other than VARIANCE) differs from all the other observations in the grouping. Standard error clustering should be strongest for the subgroups with the lowest fraction of unique observations out of their total number of observations: short-run nontransportation price (23%) and short-run transportation income (38%) elasticities.] Nelson and Kennedy (2009) advise researchers to control for the clustering of standard errors that results from having multiple effect sizes from the same study. Depending on the sample size and number of papers, it sometimes is advisable to just pick the mean estimate from each paper or select a a preferred estimate. Here, such approach would result in very small sample sizes for some of the metaregressions. 

We apply two alternative approaches to control for within-study correlation of residuals. The first approach adds a correction to the standard errors of parameter estimates to control for the correlation among residuals from each study.^[The cluster-robust standard errors were computed using the cluster.vcov function from the _multiwaycov_ package in R. They incorporate degree of freedom corrections to mitigate over-rejection of the null hypothesis in coefficient tests when small number of clusters prevents application of asymptotic theory assumptions. The number of clusters in our database ranges between 13 for short-run income elasticities in non-transportation sectors and 58 for transportation short-run price elasticities.] In what follows, we refer to that specification as weighted-least squares (WLS) with cluster-robust standard errors. Without correction, WLS would tend to underestimate the variance of the estimated model coefficients (Cameron and Miller, 2015). The second variant is a linear mixed effects (LME) specification which acknowledges the presence of study-level clusters in the database more explicitly. In the LME specification, model variables and their standard errors have an extra index $j$ that indicates the study (i.e., cluster) to which it belongs and the residual has a study-level component $\nu_j$ and an observation-level component $u_{ij}$ where $i$ represents a study and $j$ an elasticity estimate.


$$\frac{\beta_{ij}}{se_{ij}} = \frac{\alpha_0}{se_{ij}} +\eta_0*se_{ij}+ \sum_{k=1}^K \alpha_i*\frac{X_{ij,k}}{se_{ij}} + \nu_j+ u_{ij}$$
For each of the 8 metaregressions, we report results from both approaches and perform likelihood ratio tests to select the one providing the best fit. The likelihood ratio tests find that the linear mixed effects estimation is generally preferred except in the 3 metaregressions with less than 20 clusters.  

3.1 Explanatory variables
=======================

We use a general-to-specific approach to select explanatory variables for the metaregressions. The most general specification includes the subset of the explanatory variables listed below that are applicable to each elasticity grouping. In order to alleviate multicollinearity concerns, when the variance inflation factors (VIFs) of the estimated metaregressions are above 5 for any of the variables, we drop one explanatory variable at a time until all the VIFs are below 5.^[The VIF for estimated coefficient $\beta_k$ is calculated as $VIF_k = 1/(1-R^2_k)$ where $R^2_k$ is the proportion of variability in the independent variable $X_k$ explained by a regression of $X_k$ on the rest of independent variables in the model. VIF thresholds used in the literature as indicative of serious multicollinearity range from 5 to 10 (Menard, 1995; Hair et al., 1995).]

- *YrAvg.cent* (all metaregressions): average year of the period of analysis in the study that produced the elasticity estimate.  

- *SPEEDYRS.cent* (long-run elasticity metaregressions): length of adjustment period (in years). 

- *Quarterly* (short-run elasticity metaregressions): indicator variable that takes the value 1 for elasticity estimates obtained from quarterly data.  

- *Monthly* (short-run elasticity metaregressions): indicator variable that takes the value 1 for elasticity estimates obtained from monthly data.  

- *CS* (long-run metaregressions): indicator variable that takes the value 1 for elasticity estimates from cross-sectional studies. 

- *CSTS* (all metaregressions): indicator variable that takes the value 1 for elasticity estimates from panel data analyses.  

- *Pmax* (price elasticity metaregressions) : indicator variable that takes the value 1 if the elasticity is with respect to a new historical price maximum in the country or region being studied rather than an average elasticity over the full period of analysis.  

- *Ymax* (income elasticity metaregressions) : indicator variable that takes the value 1 if the elasticity is with respect to a new historical income maximum rather than an average elasticity over the full period of analysis.^[Dargay (2007) and Dargay and Gately (2010) are the only two studies in the dataset that estimate multiple income elasticities for periods of income increases, income decreases, and new income maxima to detect asymmetries and nonlinearities in crude oil demand responsiveness to changes in income. They only apply this decomposition to explain crude oil demand decisions of oil exporting countries.]  

- *StaticP* (price elasticity metaregressions) : indicator variable that takes the value 1 for elasticities estimated using static demand equations (in long-run metaregressions, all cointegration equations are codified with StaticP = 1).  

- *StaticY* (income elasticity metaregressions) : indicator variable that takes the value 1 for elasticities estimated using static demand equations (in long-run metaregressions, all cointegration equations are codified with StaticY = 1).  

- *StaticP.CS* (short-run price elasticity metaregressions) : interaction dummy that takes the value 1 for elasticities from cross-sectional studies estimated using static demand specifications.  

- *StaticY.CS* (short-run income elasticity metaregressions) : interaction dummy that takes the value 1 for elasticities from cross-sectional studies estimated using static demand specifications.  

- *PRICE.1998.cent* (transportation sector price elasticity metaregressions): average 1998 price for crude oil (Brent) or the relevant petroleum product in the country/region to which the elasticity refers.^[The cross section of 1998 price data comes from the GIZ survey (https://www.giz.de/expertise/html/4317.html). Although the survey also includes prices for non-transportation related oil consumption, the number of countries with missing observations was large and would have severely cut the sample size for those metaregressions. The year 1998 was chosen because it is close to the average year in our dataset (1992) and covered the most countries out of all the available versions of the GIZ survey conducted in the mid to late 1990s.]  

- *rgdpe_cap.1998.cent* (income elasticity metaregressions): 1998 GDP per capita in real terms for the country or group of countries to which the elasticity estimate refers.^[The data source for the 1998 GDP per capita is the Penn World Table, version 9.0 (www.ggdc.net/pwt)]  

- *EndUserP* (price, non-transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate is measured with respect to a petroleum product price and 0 if it is an elasticity with respect to the crude oil price.  

- *DslTransp* (transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate corresponds to diesel consumption.  

- *VehStk* (transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate comes from a study that includes a measure of vehicle stock as one of the explanatory variables for fuel demand.^[Havranek and Kokes(2015) found that studies of gasoline demand omitting this variable result in significantly larger income elasticity values.]  

- *FuelSwitch* (non-transportation sector metaregressions): indicator variable that takes the value 1 if the elasticity estimate refers to a product or sector with abundant fuel switching options (residential or electricity generation sectors following the categorization in Dargay and Gately(2010)).  

- *VARIANCE* (included in all metaregressions that require a correction for publication bias): the variance of the elasticity estimate.  

- *CALC_STERROR* (all metaregressions): indicator variable that takes the value 1 if the study did not report the standard error or t-statistic of the elasticity estimate but was calculated instead as a function of the standard error of other estimated coefficients using the Gaussian error propagation formula.^[Given random variables $x$ and $y$ measured with standard errors $\delta(x)$ and $\delta(y)$ and assuming that $x$ and $y$ are uncorrelated, the Gaussian error propagation formula for the standard error of $q=f(x,y)$ is $\delta(q) = \sqrt{(\frac{\partial q}{\partial x}*\delta(x))^2 +(\frac{\partial q}{\partial y}*\delta(y))^2}$] In his meta-analysis of the price elasticity of beer, Nelson (2014) finds that  calculated standard errors tend to be larger than those directly reported in the papers.^[We conducted two tests to evaluate whether calculated standard errors appear to be biased. First, as recommended in Nelson (2014), we regressed standard errors on the elasticities and a dummy that takes the value 1 for calculated standard errors. The estimated coefficients were positive in most cases but only statistically significant for the short-run, transportation income elasticity and the long-run, nontransportation price elasticity. Second, we calculated standard errors for a subset of long-run elasticities for which directly reported standard errors were also available. The ratio of reported to calculated standard errors in that subset was 0.946 for price elasticities and 0.877 for income elasticities. These results suggest that calculated standard errors tend to be larger although not by a large amount.] To correct for possible bias, Nelson (2014) introduces a dummy variable in the metaregression that takes the value 1 for calculated standard errors. We use the same approach.  

The .cent suffix for continuous variables _PRICE.1998.cent_, _YrAvg.cent_, _SPEEDYRS.cent_, and _rgdpe_cap.1998.cent_ indicates that they are centered around the average value within their grouping. For PRICE.1998.cent, centering is around the Brent crude oil price. With centered variables, the metaregression intercept has a straightforward interpretation as the elasticity evaluated at the average values of the continuous variables and zero values for the indicator variables. 

4. Results from metaregression analysis
=======================================

For each of the 8 elasticity groupings considered in this analysis, we estimate metaregressions using both the WLS and LME approaches described in Section 3 and conduct likelihood ratio tests to select which of the two model specifications provides the best fit. The null hypothesis tested by the likelihood ratio test is that the more parsimonious model (WLS) is the "true" model.^[The likelihood ratio test statistic follows a chi-squared distribution with degrees of freedom equal to the difference in degrees of freedom between the two models compared.] Table 1 shows the results from the tests. 

**Table 1. Likelihood Ratio Tests Comparing Fit of Linear Mixed Effects and Weighted Least Squares Metaregression Specifications**

```{r out.table.lrt, echo = FALSE, warning = FALSE, message = FALSE, comment = NA}
# Create table summarizing results from the likelihood ratio tests to select the best performing estimation option for each elasticity subset
LRT.table <- matrix(NA, 8, 7)
for (i in 1:length(LRT)) {
  LRT.table[i, 1] <- paste(selectorSets[i, 1], selectorSets[i, 2], selectorSets[i, 3], sep = "_")
  LRT.table[i, 2] <- LRT[[i]][1, "LogLik"] # log likelihood of the full model
  LRT.table[i, 3] <- LRT[[i]][2, "LogLik"] # log likelihood of the restricted model
  LRT.table[i, 4] <- LRT[[i]][2, "Chisq"] # value of the statistic
  LRT.table[i, 5] <- LRT[[i]][2, "Df"] # difference in degrees of freedom
  LRT.table[i, 6] <- LRT[[i]][2, "Pr(>Chisq)"] # p-value of the statistic
  LRT.table[i, 7] <- all_baselinesEstimated$n.papers[[i]] # number of clusters
}

ElastID3 <- c("Price-SR-Transport", "Price-SR-NonTransport", "Price-LR-Transport", "Price-LR-NonTransport", "Income-SR-Transport", "Income-SR-NonTransport", "Income-LR-Transport", "Income-LR-NonTransport")
ElastIDmatch3 <- data.frame(Type_Sector, ElastID3)
ElastIDmatch3$ElastID3 <- factor(ElastIDmatch3$ElastID3, levels = c("Price-SR-Transport", "Price-SR-NonTransport", "Price-LR-Transport", "Price-LR-NonTransport", "Income-SR-Transport", "Income-SR-NonTransport", "Income-LR-Transport", "Income-LR-NonTransport"))

LRT.table <- as.data.frame(LRT.table, row.names = FALSE) %>%
  left_join(ElastIDmatch3, by = c("V1" = "Type_Sector")) %>%
  select(ElastID3, V2, V3, V4, V5, V6, V7)

LRT.table <- LRT.table %>%
  mutate_at((c(2:7)), as.numeric) %>%
  mutate_at((c(2:6)), round, 2) %>%
  mutate_at((c(5)), abs) %>%
  slice(1, 5, 2, 6, 3, 7, 4, 8)

colnames(LRT.table) <- c("Grouping", "Log.Lik.MLE", "Log.Lik.WLS", "Statistic", "Degrees.of.Freedom", "p.value", "number.clusters")

kable(LRT.table, digits = 2, col.names = c("Grouping", "Log Likelihood LME", "Log Likelihood WLS", "Statistic", "Degrees of Freedom", "p value", "Number of Clusters"))
```

Based on the likelihood ratio test results, we conclude that the LME estimation is preferred for all the price elasticity metaregressions—except short-run, non-transportation—as well as for the transportation income elasticity metaregressions. For the remaining 3 metaregressions (short-run, nontransportation price, short-run nontransportation income, and long-run nontransportation income), the addition of a random intercept for each within-study cluster of elasticity estimates does not lead to a statistically significant improvement in model fit and the simpler WLS specification is preferred. The number of clusters (i.e., number of studies) in each metaregression are also included in Table 1. The discussion of estimated metaregression coefficients in Table 2 through Table 9 focuses on the preferred specification in each case, but the results of the alternative specification are also shown in the tables for reference.

```{r out.Tables_PSRTransp, echo = FALSE, warning = FALSE, message = FALSE, comment = NA}
out.tbl.PSR.Transp <- stargazer(modelsEstimated2.raw[[1]], modelsEstimated2.LME.raw[[1]],
  se = list(coeffsEstimated2[[1]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  dep.var.labels.include = FALSE,
  colnames = TRUE, notes = NULL,
  title = "Table 2: Results from Short-Run Price Elasticity Metaregressions (Transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
Table 1 indicated that LME is the preferred model for explaining short-run transportation price elasticities. The estimated intercept (`r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "(Intercept)"],4)`) in Table 2 can be interpreted as the baseline elasticity. The baseline is the value of the elasticity when all indicator variables are zero and all continuous variables are equal to their sample means. 

Table 2 shows that the estimated coefficient on the _YrAvg.cent_ variable is `r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "YrAvg.cent"],4)`. This can be interpreted as a decreasing trend (i.e., smaller absolute over time) on the short-run price responsiveness of the transportation sector. The baseline elasticity corresponds to 1993—the average year of the datasets in the studies that produced the elasticity estimates being explained by this metaregression. All else equal, the baseline elasticity for 1994 would be `r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "(Intercept)"] - modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "YrAvg.cent"],4)`.

In agreement with results from previous meta-analyses of gasoline demand, static model specifications yield larger (in absolute value) short-run price elasticities of transportation demand (Espey, 1998; Brons et al., 2008). The combination of static specification and cross-sectional data leads to even larger elasticities. Relative to the baseline elasticity of `r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "(Intercept)"],4)`, elasticities from models using cross-sectional data and a static specification are, on average, more than 4 times larger (`r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "(Intercept)"] + modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "StaticP.CS"],4)`).

The estimated coefficient on _VehStk_ is `r round(modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "VehStk"],4)` almost doubling price responsiveness relative to the baseline. The sign of this coefficient is contrary to the argument that elasticities from models accounting for changes in vehicle stock should be smaller (in absolute value) because they do not conflate demand responses to price with demand changes due to the evolution of average fleet attributes. However, since changes in stock are almost negligible within the length of period (one-year or less) considered in short-run elasticities, the argument for smaller elasticities resulting from models including that variable seems more relevant for the long-run elasticity metaregressions.  

Short-run transportation fuel demand responsiveness to price is positively correlated with price level both when we compare price levels across countries at one point in time (_PRICE.1998.cent_) and when we compare responsiveness to a new price maximum versus average price responsiveness (_Pmax_). All else equal, estimated price responsiveness increases by `r round(-100 * modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "PRICE.1998.cent"],2)` percentage points with each additional dollar in the 1998 price level (in \$ per liter) in the country or region of study relative to the price of Brent.^[The values of the _PRICE.1998.cent_ variable range from -\$0.07/liter for Iran and Iraq to \$1.11/liter for Italy. Differences among the prices of most countries or regions are in the order of cents or tenths of dollars.] In addition, estimated price responsiveness is `r round(-100 * modelsEstimated2.LME[[1]]$estimate[modelsEstimated2.LME[[1]]$term == "Pmax"],2)` percentage points larger when the observed price level is a new price maximum for the country or region being studied.  

Based on the estimated coefficients for the _Quarterly_, _Monthly_, _CSTS_, and _DslTransp_ variables, estimated elasticities from studies using quarterly, monthly, panel, or diesel data are larger (in absolute value) than the baseline of annual, time series, non-diesel demand data. However, these four effects are not statistically significant. Also statistically insignificant is the estimated coefficient on _OECD_ which indicates that, all else equal, short-term price responsiveness is smaller in studies using data for OECD countries than non-OECD countries. Finally, neither _VARIANCE_ nor _CALC_STERROR_ display a statistically significant coefficient meaning that 1) publication bias does not remain a concern after controlling for the effect of all other explanatory variables and 2) elasticity estimates for which the standard error was not displayed in the study and had to be calculated based on other parameters are not introducing bias into the metaregression. 


```{r out.Tables_PSROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}
out.tbl.PSR.Other <- stargazer(modelsEstimated2.raw[[5]], modelsEstimated2.LME.raw[[5]],
  se = list(coeffsEstimated2[[5]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 3: Results from short-run price elasticity metaregressions (non-transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
As indicated by Table 1, the LME estimation approach does not improve the fit of the short-run nontransportation price elasticity metaregression. Thus, the WLS model with cluster-robust standard errors is the preferred specification to be discussed next.  

Table 3 displays 4 statistically significant effects as well as a statistically significant baseline short-run non-transportation price elasticity of `r round(modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "(Intercept)"],4)`. All else equal, elasticities from the subset of studies using panel data are `r round( 100 * modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "CSTS"],2)` percentage points smaller in absolute value than the time-series baseline. The effect of _Monthly_, studies based on monthly rather than annual data, is even larger (`r round(modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "Monthly"],4)`) such that keeping all other attributes from the baseline elasticity constant, it would result in a positive price elasticity.^[V&#225;squez-Cordano(2005) is the only study in the dataset that uses monthly data to estimate price elasticities outside of the transportation sector. The two elasticity estimates from that study going into this metaregression are for kerosene (0.269) and liquefied petroleum gas (-0.333) in Peru.] The estimated coefficient for _EndUserP_ (`r round(modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "EndUserP"],4)`) indicates that, all else equal, the demand response to an increase in the end user price of a petroleum product is `r round(-100*modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "(Intercept)"],2)` percentage points larger than the response to the same percentage increase in the price of crude oil. In addition, all else equal, elasticity with respect to a new price maximum is `r round(100*modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "Pmax"],2)` percentage points larger (in absolute value) than the average elasticity across all price levels in the period of analysis.

The rest of estimated coefficients shown in Table 3 are not statistically significant. Lack of statistical significance and very small magnitude of the estimated coefficient on _YrAvg.cent_ mean that there is no visible trend in short-run non-transportation elasticities over time in these metadata. All else equal, estimated elasticities are `r round(-100*modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "OECD"],2)` percentage points larger (i.e., more negative) for the subset of OECD elasticities than for the rest of the world. Contrary to the negative estimated coefficient for the _StaticP_ variable for the transportation sector discussed in Table 2, using static model specifications to explain non-transportation crude oil demand leads to elasticities that are `r round(100*modelsEstimated2[[5]]$estimate[modelsEstimated2[[5]]$term == "StaticP"],2)` percentage points smaller (less negative) than those from dynamic models. According to the estimated coefficient on _FuelSwitch_, the elasticities for petroleum products whose uses present more opportunities for fuel switching (residential, electricity generation) were not significantly different than those in other non-transportation activities during the period covered by the studies in this metaregression. Finally, the lack of statistical significance on the VARIANCE variable suggests that publication bias is not of key concern in this metaregression.

```{r out.Tables_PLRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}
out.tbl.PLR.Transp <- stargazer(modelsEstimated2.raw[[2]], modelsEstimated2.LME.raw[[2]],
  se = list(coeffsEstimated2[[2]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 4: Results from long-run price elasticity metaregressions (transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
Table 1 showed that the LME estimation method is preferred for transportation sector long-run price elasticities. According to the estimated intercept in Table 4, the baseline value for this elasticity grouping is `r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "(Intercept)"],4)`. The estimated coefficient on _SPEEDYRS.cent_ indicates that, for every extra year of adjustment, the estimated elasticity increases in absolute value by `r round(-100*modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "SPEEDYRS.cent"],2)` percentage points. To place that number into context, the baseline elasticity of `r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "(Intercept)"],4)` is for the sample mean adjustment period length (9.3 years); all else equal, the estimated elasticity would become `r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "(Intercept)"] + modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "SPEEDYRS.cent"] ,4)` if the adjustment period were 10.3 years instead. Based on the estimated coefficient on _CS_, elasticities from studies using cross sectional data are, on average, `r round(-100*modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "CS"],2)` percentage points larger (more negative) than those based on time series data.  

The estimated _Pmax_ coefficient implies that responsiveness to a new price maximum is `r round(-100*modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "Pmax"], 2)` percentage points larger than the average price responsiveness and the estimated coefficient on _PRICE.1998.cent_ means that for each dollar per liter the 1998 price of transportation fuel increases relative to the price of Brent, demand responsiveness increases by `r round(-100*modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "PRICE.1998.cent"],2)` percentage points. OECD countries tend to have higher transportation fuel prices than the rest of the world, mostly due to higher taxes. However, for OECD countries, the effect of high price level on elasticity embodied in the _PRICE.1998.cent_ variable is partly offset by the estimated coefficient on _OECD_ which is of the opposite sign (`r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "OECD"],4)`). The estimated coefficient on _VARIANCE_ (`r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "VARIANCE"],4)`) is indicative of publication bias as it means that elasticity estimates with larger variances tend to also be larger in absolute value. However, the effect is small. Without controlling for this effect, the estimated baseline would be `r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "(Intercept)"] + modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "VARIANCE"] ,4)` instead of `r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "(Intercept)"],4)`.  

The remaining estimated coefficients are not statistically significant. Those on _YrAvg.cent_ (`r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "YrAvg.cent"], 4)`) and _CSTS_ (`r round(modelsEstimated2.LME[[2]]$estimate[modelsEstimated2.LME[[2]]$term == "CSTS"], 4)`) are also small in magnitude suggesting no clear trend in long-run price responsiveness in the transportation sector and no significant differences in elasticity estimates from studies using panel (_CSTS_) versus time series data. Estimated coefficients on _StaticP_, _DslTransp_, and _VehStk_ all imply decreases in price responsiveness in the 2–3 percentage point range associated with the use of static models, diesel (versus other transportation fuel) data, and the inclusion of vehicle stock as an explanatory variable. The lack of statistical significance of the _CALC_STERROR_ variable indicates that elasticity estimates for which the standard error was not displayed in the study and had to be calculated based on other parameters are not introducing bias into the metaregression.


```{r out.Tables_PLROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }
out.tbl.PLR.Other <- stargazer(modelsEstimated2.raw[[6]], modelsEstimated2.LME.raw[[6]],
  se = list(coeffsEstimated2[[6]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 5: Results from long-run price elasticity metaregressions (non-transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
Based on the likelihood ratio test p-value discussed in Table 1, LME is the preferred specification for this elasticity grouping. Table 5 displays the baseline elasticity (`r round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "(Intercept)"], 4)`) and estimated effects of the explanatory variables. Similar to the transportation sector findings in Table 4, each additional year of response period (_SPEEDYRS.cent_) leads to an increase of elasticity (in absolute value) of `r -100*round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "SPEEDYRS.cent"], 2)` percentage point. Long-run price elasticities outside of the transportation sector are, on average, `r 100*round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "CSTS"], 2)` percentage points smaller in studies that use panel data rather than time series. Responsiveness to a new price maximum (_Pmax_) is `r -100*round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "Pmax"], 2)` percentage points larger than the average price responsiveness. The estimated coefficient for _EndUserP_ indicates that for a same percentage increase in the price of crude oil versus the end user price of a petroleum product, the demand response is `r -100*round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "EndUserP"], 2)` percentage points larger in the latter case.  

The estimated coefficients on _YrAvg.cent_ (`r round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "YrAvg.cent"], 4)`) and _OECD_ (`r round(modelsEstimated2.LME[[6]]$estimate[modelsEstimated2.LME[[6]]$term == "OECD"], 4)`) imply slight increase in price responsiveness over time and greater responsiveness in the OECD region versus the rest of the world, but neither of these two effects are statistically significant. Finally, the coefficients on _VARIANCE_ and _CALC_STERROR_ are not statistically significant either which means that publication bias does not appear of grave concern within the set of studies considered in this metaregression and no sizable bias results from using error propagation methods to compute the standard errors of elasticity estimates in cases when those numbers are not directly published in the study.

```{r out.Tables_YSRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }
out.tbl.YSR.Transp <- stargazer(modelsEstimated2.raw[[3]], modelsEstimated2.LME.raw[[3]],
  se = list(coeffsEstimated2[[3]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 6: Results from short-run income elasticity metaregressions (transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
As discussed in Table 1, the likelihood ratio test indicates that inclusion of a study-level random effect is appropriate for the metaregression of short-run income elasticities in the transportation sector. Thus, the discussion of results from Table 6 focuses on the LME specification. According to the estimated intercept, the baseline income elasticity for the transportation sector demand is `r round(modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "(Intercept)"], 4)`. One of the attributes of that baseline elasticity value is that it corresponds to income elasticities of gasoline demand or overall transportation fuel demand. For studies of diesel demand, the estimated coefficient on _DslTransp_ indicates that income elasticities are `r round(100*modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "DslTransp"], 2)` percentage points larger. Studies based on panel data (_CSTS_) yield income elasticities `r round(-100*modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "CSTS"], 2)` percentage points lower than those from studies using time series data. More than 80% of elasticities from panel data studies in this metaregression are for OECD countries. Thus, the _CSTS_ variable might be partly reflecting lower income elasticities for that set of countries. Static model specifications (_StaticY_) result in `r round(100*modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "StaticY"], 2)` percentage points greater estimated income elasticities. For gasoline demand, Espey (1998) found a similarly large effect for this variable. However, for the subset of elasticities obtained from static models using cross sectional data, the effect of _StaticY_ is largely offset by the opposite effect of the interaction dummy _StaticY.CS_.  

The GDP per capita cross-sectional variable (_rgdpe_cap.1998.cent_) suggests this elasticity is largely flat across income levels. For every additional thousand dollars of GDP per capita relative to the sample mean, income elasticity becomes `r round(-100*modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "rgdpe_cap.1998.cent"], 2)` percentage points lower.^[The sample mean of 1998 real GDP per capita is \$27,173 and the range spans from \$408 for Nigeria to \$76,100 for the United Arab Emirates.] Within a given country or region, responsiveness to a new maximum income level (_Ymax_) is `r round(100*modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "Ymax"], 2)` percentage points larger than the average responsiveness. However, neither of the two estimated coefficients related to income levels (_Ymax_ and _rgdpe_cap.1998.cent_) are statistically significant at the 10% level in the preferred LME specification. As found in previous meta-analyses of gasoline demand (e.g., Espey, 1998; Havranek and Kokes, 2015), including vehicle stock in the demand model (_VehStk_) results in smaller estimates of income elasticity. However, the magnitude of this coefficient is small (`r round(modelsEstimated2.LME[[3]]$estimate[modelsEstimated2.LME[[3]]$term == "VehStk"], 4)`) and it is not statistically significant. Finally, the lack of statistical significance on the _VARIANCE_ variable suggests that, after controlling for the rest of explanatory variables, publication bias is not significantly affecting the estimated baseline for this elasticity.

```{r out.Tables_YSROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA}
out.tbl.YSR.Other <- stargazer(modelsEstimated2.raw[[7]], modelsEstimated2.LME.raw[[7]],
  se = list(coeffsEstimated2[[7]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 7: Results from short-run income elasticity metaregressions (non-transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
The results of likelihood ratio tests in Table 1 showed that the WLS model specification with standard errors clustered at the study level is preferred to the LME specification for analyzing the variability in short-run income elasticities outside of the transportation sector. The strongest effect revealed by the WLS metaregression in Table 7 is that of static versus dynamic model specifications. The estimated coefficient on _StaticY_ indicates that using a static model results in `r round(100*modelsEstimated2[[7]]$estimate[modelsEstimated2[[7]]$term == "StaticY"], 2)` percentage points larger income elasticities for this portion of crude oil demand. This large effect is consistent with the interpretation of elasticities from static models as medium run rather than short-run (Espey, 1998). The only other statistically significant effect in the WLS specification in Table 7 is the one from the use of monthly data (_Monthly_) which results in an increase in income elasticity of `r round(100*modelsEstimated2[[7]]$estimate[modelsEstimated2[[7]]$term == "Monthly"], 2)` percentage points. However, this result should not be viewed as general or extrapolated outside of this specific metadata sample because it is based on only two elasticity estimates from a single study.^[As for the counterpart price elasticities, V&#225;squez-Cordano(2005) is the only study in the dataset that uses monthly data to estimate income elasticities outside the transportation sector. The two elasticity estimates from that study going into this metaregression are for kerosene (0.702) and liquefied petroleum gas (0.101) in Peru.]  

The rest of estimated effects—increasing trend over time, larger elasticities from studies using panel data, larger responsiveness to a new GDP per capita maximum than other income levels, smaller income elasticities for higher income countries, smaller elasticities from studies of crude oil demand in the residential and electricity generation sectors, and direct relationship between elasticity estimates and their variance—are not statistically significant.

```{r out.Tables_YLRTransp, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }
out.tbl.YLR.Transp <- stargazer(modelsEstimated2.raw[[4]], modelsEstimated2.LME.raw[[4]],
  se = list(coeffsEstimated2[[4]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 8: Results from long-run income elasticity metaregressions (transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```
For long-run income elasticities in the transportation sector, the likelihood ratio test in Table 1 indicates that the LME specification is preferred. Results from that preferred specification in Table 8 indicate that the long-run responsiveness of transportation fuel demand to income is almost double for diesel versus other petroleum-based transportation fuels. The baseline elasticity value indicated by the intercept (`r round(modelsEstimated2.LME[[4]]$estimate[modelsEstimated2.LME[[4]]$term == "(Intercept)"], 4)`) corresponds to studies using gasoline or aggregate transportation fuel demand data. All else equal, diesel demand studies find elasticities of `r round(modelsEstimated2.LME[[4]]$estimate[modelsEstimated2.LME[[4]]$term == "(Intercept)"] + modelsEstimated2.LME[[4]]$estimate[modelsEstimated2.LME[[4]]$term == "DslTransp"], 4)`. None of the studies on long-run income elasticity of diesel demand are for the United States. Most elasticity estimates in this category are for European countries or low-income countries. Higher elasticities for diesel in Europe can be partly explained by the policy shift toward diesel consumption in that region in the 1990s and 2000s. As for high income elasticities for diesel in low-income countries, this result is consistent with the negative coefficient on 1998 income level (_rgdpe_cap.1998.cent_). Contrary to the idea of larger demand responses over longer adjustment periods, within the set of studies included in this metaregression, long-run income elasticity in the transportation sector slightly decreases, by `r 100*round(modelsEstimated2.LME[[4]]$estimate[modelsEstimated2.LME[[4]]$term == "SPEEDYRS.cent"], 2)` percentage points, for each additional year of adjustment. The large negative effect of calculated standard errors (_CALC_STERROR_) on effect size is indicative of bias in the calculated standard errors relative to those directly reported in the studies.  

The rest of estimated effects—decreasing trend over time, smaller elasticities from studies using panel data, larger responsiveness to a new GDP per capita maximum than other income levels, smaller income elasticities for higher income countries, smaller elasticities from studies including vehicle stock as one of their explanatory variables, and direct relationship between elasticity estimates and their variance—are not statistically significant.

```{r out.Tables_YLROther, echo = FALSE, warning =FALSE, message=FALSE, comment = NA }
out.tbl.YLR.Other <- stargazer(modelsEstimated2.raw[[8]], modelsEstimated2.LME.raw[[8]],
  se = list(coeffsEstimated2[[8]][, 2], NULL),
  column.labels = c("WLS cluster-robust.se", "LME"),
  column.sep.width = "2pt",
  colnames = TRUE, notes = NULL,
  title = "Table 9: Results from long-run income elasticity metaregressions (non-transportation)",
  align = TRUE, digits = 4, multicolumn = FALSE, rownames = FALSE, model.names = FALSE,
  type = "text", model.numbers = FALSE, style = "aer"
)
```

For long-run, income elasticities outside the transportation sector, the likelihood ratio test displayed in Table 1 indicates that the WLS specification is preferred. Table 9 shows that the baseline elasticity value implied by the intercept (`r round(modelsEstimated2[[8]]$estimate[modelsEstimated2[[8]]$term == "(Intercept)"], 4)`) is similar to the one for the transportation sector (`r round(modelsEstimated2.LME[[4]]$estimate[modelsEstimated2.LME[[4]]$term == "(Intercept)"], 4)`) as is the magnitude of the _CALC_STERROR_ coefficient—indicative of bias from the calculated standard errors that were not reported in the studies.^[ _VARIANCE_ was not included as an explanatory variable in this metaregression because the funnel asymmetry test did not find a statistically significant relationship between effect size and precision of the estimate.] The estimated coefficient on _YrAvg.cent_ is indicative of an increasing trend—`r round(100*modelsEstimated2[[8]]$estimate[modelsEstimated2[[8]]$term == "YrAvg.cent"], 2)` percentage points increase per year—in income elasticity for the demand of petroleum products outside of the transportation sector. Income elasticities in response to a new GDP per capita maximum (_Ymax_) are `r round(100*modelsEstimated2[[8]]$estimate[modelsEstimated2[[8]]$term == "Ymax"], 2)` percentage points larger than for other income levels. The estimated coefficient on _rgdpe_cap.1998.cent_ means that long-run income elasticity outside of the transportation sector decreases by `r round(-100*modelsEstimated2[[8]]$estimate[modelsEstimated2[[8]]$term == "rgdpe_cap.1998.cent"], 2)` percentage points for each additional thousand dollars 1998 GDP per capita. The other two estimated effects—decreasing elasticity as length of adjustment period increases and larger elasticities from studies using panel data—are not statistically significant.

\pagebreak


4.1. World oil elasticity demand estimation  
===========================================  

To translate the metaregression results into an estimate of world crude oil demand elasticity, a further processing step is required. Table 10 displays multiple summary metrics for each of the 8 metaregressions. Fitted means result from computing the sumproduct of the estimated coefficients and the sample mean values of the explanatory variables. The fitted means are generally smaller but not much different from the raw mean elasticities for each grouping. The remaining columns in Table 10 display alternative estimated baselines and their standard errors. Each baseline is constructed as the sumproduct of the estimated coefficients and a value of either 0,1, or the sample mean for each of the explanatory variables.^[ _YrAvg.cent_, _rgdpe_cap.1998.cent_, _DslTransp_, _FuelSwitch_, _SPEEDYRS.cent_, _CS_, _CSTS_, _OECD_, _Monthly_, and _Quarterly_ are evaluated at their mean values. _StaticP_, _StaticY_, _StaticP.CS_, _StaticY.CS_ are evaluated at 0 for short-run elasticities and at their mean for long-run elasticities. _VehStk_ is evaluated at the mean for short-run elasticities and at zero for long-run elasticities. The rest of the explanatory variables are evaluated at zero.] The 3 alternative baselines differ on the values at which price level-related explanatory variables are evaluated. The first baseline bsl should be interpreted as the demand elasticity with respect to the average crude oil price (_PRICE.1998_ and _EndUserP_ evaluated at zero in the transportation and non-transportation metaregressions respectively and _Pmax_ and _Ymax_ also evaluated at zero). The second baseline bsl.max is the demand elasticity with respect to a new crude oil price maximum or income maximum; it differs from the first in that _Pmax_ and _Ymax_ are assigned a value of 1 for the multiplication by their estimated coefficients. Finally, the third baseline bsl.prodpmax evaluates _Pmax_, _Ymax_ at one, _PRICE.1998.cent_ at the mean, and _EndUserP_ at 1 and it conveys the demand responsiveness with respect to a new observed maximum in the petroleum product prices paid by final customers. The standard errors of the three alternative baselines are calculated using the Gaussian error propagation formula.

**Table 10. Estimated Elasticities (fitted means and baselines)**

```{r out.tbl.baselines, echo=FALSE}
all_baselinesEstimated.2 <- all_baselinesEstimated %>%
  select(subsetString, fittedmean, baseline, sterror.baseline, baseline.max, sterror.baseline.max, baseline.prodpmax, sterror.baseline.prodpmax) %>%
  rename(Type_Sector = subsetString, bsl = baseline, st.err = sterror.baseline, bsl.max = baseline.max, st.err.max = sterror.baseline.max, bsl.prodpmax = baseline.prodpmax, st.err.prodpmax = sterror.baseline.prodpmax) %>%
  left_join(ElastIDmatch3, by = "Type_Sector") %>%
  rename(Grouping = ElastID3) %>%
  slice(1, 5, 2, 6, 3, 7, 4, 8)


all_baselinesEstimated.2 <- all_baselinesEstimated.2[, c(9, 2:8)]

kable(all_baselinesEstimated.2, digits = 3)
```

```{r elast_20000, eval=TRUE, include = FALSE}
# Read IEO 2016 data on petroleum consumption by end-use and fuel to compute transportation and non-transportation weights
# Only two rows of data are needed corresponding to api.keys 15-IEO2016.26.Reference-d021916a (liquids consumption in transportation sector) and 15-IEO2016.55.Reference-d021916a (total liquids consumption)
# worldelastw <- read_excel("../Data/auxiliary_inputs_20170829.xlsx", sheet = "cons.weights_IEO2016", col_names = TRUE, skip=4) %>%
#   rename(api.key=`api key`) %>%
#   filter(api.key =="15-IEO2016.26.Reference-d021916a"|api.key=="15-IEO2016.55.Reference-d021916a") %>%
#   select(c(3,5:35)) %>%
#   pivot_longer(cols = c(-api.key), names_to = "YEAR", values_to = "VALUE") %>%
#   pivot_wider(names_from = "api.key", values_from = "VALUE") %>%
#   mutate(Transportation = `15-IEO2016.26.Reference-d021916a`/`15-IEO2016.55.Reference-d021916a`,
#          Nontransportation = 1 - Transportation) %>%
#   select(YEAR, Transportation, Nontransportation)
#
#  avg.transp.weight <- mean(worldelastw.l$Transportation)
#  avg.other.weight <- mean(worldelastw.l$Nontransportation)
#
#  worldelastw2 <- worldelastw %>%
#    pivot_longer(cols = c(-YEAR), names_to = "Sector", values_to = "VALUE") %>%
#    pivot_wider(names_from = "YEAR", values_from = "VALUE")


## These weights combine regional weights from AEO2014 with sectoral weights from IEO2013.
worldelastw <- read_excel("../Data/auxiliary_inputs_20170829.xlsx", sheet = "cons.weights_IEO2013", col_names = TRUE) %>%
  mutate(RegSect = paste(Region, Sector, sep = "_")) %>%
  as.data.frame()


# Compute slope and intercept for lines relating elasticity to length of run
out_summary <- all_baselinesEstimated %>%
  select(subsetString, baseline, sterror.baseline, mean.SPEEDYRS) %>%
  mutate(
    Region = "1_1_",
    BaselineType = "crudep"
  )

out_summary.OECD <- all_baselinesEstimated %>%
  select(subsetString, baseline.OECD, sterror.baseline.OECD, mean.SPEEDYRS.OECD) %>%
  mutate(
    Region = "1_0_",
    BaselineType = "crudep"
  ) %>%
  rename(baseline = baseline.OECD, sterror.baseline = sterror.baseline.OECD, mean.SPEEDYRS = mean.SPEEDYRS.OECD)

out_summary.nonOECD <- all_baselinesEstimated %>%
  select(subsetString, baseline.nonOECD, sterror.baseline.nonOECD, mean.SPEEDYRS.nonOECD) %>%
  mutate(
    Region = "0_1_",
    BaselineType = "crudep"
  ) %>%
  rename(baseline = baseline.nonOECD, sterror.baseline = sterror.baseline.nonOECD, mean.SPEEDYRS = mean.SPEEDYRS.nonOECD)

out_summary.max <- all_baselinesEstimated %>%
  select(subsetString, baseline.max, sterror.baseline.max, mean.SPEEDYRS) %>%
  mutate(
    Region = "1_1_",
    BaselineType = "crudepmax"
  ) %>%
  rename(baseline = baseline.max, sterror.baseline = sterror.baseline.max)

out_summary.prodpmax <- all_baselinesEstimated %>%
  select(subsetString, baseline.prodpmax, sterror.baseline.prodpmax, mean.SPEEDYRS) %>%
  mutate(
    Region = "1_1_",
    BaselineType = "prodpmax"
  ) %>%
  rename(baseline = baseline.prodpmax, sterror.baseline = sterror.baseline.prodpmax)


out_summary1 <- rbind(out_summary, out_summary.OECD, out_summary.nonOECD, out_summary.max, out_summary.prodpmax) %>%
  mutate(
    run = as.factor(substr(subsetString, 3, 4)),
    case2 = as.factor(paste0(substr(subsetString, 1, 2), Region, substr(subsetString, 6, 8)))
  ) %>%
  select(baseline, sterror.baseline, mean.SPEEDYRS, BaselineType, run, case2)


out_summary2 <- out_summary1 %>%
  pivot_longer(cols = c(-case2, -run, -BaselineType), names_to = "variable", values_to = "value") %>%
  unite(var.run, run, variable, sep = "_") %>%
  pivot_wider(names_from = "var.run", values_from = "value") %>%
  mutate(full.label = paste(case2, BaselineType, sep = "_"))


# Linear curve parameters and associated standard errors based on error propagation formula http://courses.washington.edu/phys431/propagation_errors_UCh.pdf
out_summary3 <- out_summary2 %>%
  mutate(
    slope = (LR_baseline - SR_baseline) / (LR_mean.SPEEDYRS - SR_mean.SPEEDYRS),
    intercept = LR_baseline - (slope * LR_mean.SPEEDYRS),
    slope.sd = (1 / (LR_mean.SPEEDYRS - SR_mean.SPEEDYRS)) * sqrt(LR_sterror.baseline**2 + ((-1 * SR_sterror.baseline)**2)),
    intercept.sd = sqrt(SR_sterror.baseline**2 + ((-SR_mean.SPEEDYRS * slope.sd)**2)),
    intercept.minus.sd = intercept - 1 * intercept.sd,
    intercept.plus.sd = intercept + 1 * intercept.sd,
    elast = intercept + (slope * 1 / 12),
    elast.minus.sd = intercept.minus.sd + (slope * 1 / 12),
    elast.plus.sd = intercept.plus.sd + (slope * 1 / 12)
  ) %>%
  select(-full.label)


out_summary4 <- out_summary3 %>%
  mutate(
    type = substr(case2, 1, 1),
    region = ifelse(substr(case2, 3, 5) == "0_1", "nonOECD",
      ifelse(substr(case2, 3, 5) == "1_0", "OECD", "world")
    ),
    sector = ifelse(substr(case2, 7, 9) == "0_1", "nontransp", "transp"),
    baselinetype = BaselineType,
    case_label = paste(type, region, sector, sep = "_")
  ) %>%
  select(c(22, 21, 3:17)) %>%
  rename(
    LR_est.baseline = LR_baseline,
    LR_baseline.sd = LR_sterror.baseline,
    LR_lengthrun.yrs = LR_mean.SPEEDYRS,
    SR_est.baseline = SR_baseline,
    SR_baseline.sd = SR_sterror.baseline,
    SR_lengthrun.yrs = SR_mean.SPEEDYRS
  )

write.csv(out_summary4, "../Output/elast_line_coeffs.csv")

# Simulate confidence intervals for all the baseline world oil elasticities resulting from the preferred (WLS or LME) model estimations. Alternatively, we could construct confidence intervals based on either of the two estimations choosing the appropriate columns for elasticiy baseline and standard error from the all_baselinesEstimated table
intercept <- list()
st_error <- list()

for (i in 1:nrow(out_summary3)) {
  intercept[i] <- out_summary3$intercept[i]
  st_error[i] <- out_summary3$intercept.sd[i]
}

# Set seed and draw 20000 points out of each of the baseline elasticities
ndraws <- 20000
set.seed(14)

elast.sim <- matrix(c(0), ndraws, nrow(out_summary3))
colnames(elast.sim) <- paste(out_summary3$case2, out_summary3$BaselineType, sep = "_")

for (i in 1:length(intercept)) {
  # truncated normal distribution
  elast.sim[, i] <- rtruncnorm(ndraws,
    a = as.numeric(intercept[i]) - 1 * as.numeric(st_error[i]),
    b = as.numeric(intercept[i]) + 1 * as.numeric(st_error[i]),
    mean = as.numeric(intercept[i]),
    sd = as.numeric(st_error[i])
  )
}


# Add rows with more descriptive titles for the simulated elasticities
elast.sim_out <- as.data.frame(rbind(
  c(rep("Price", 6), rep("Income", 6), rep("Price", 2), rep("Income", 2), rep("Price", 2), rep("Income", 2)),
  c(rep("nonOECD", 2), rep("OECD", 2), rep("world", 2), rep("nonOECD", 2), rep("OECD", 2), rep("world", 10)),
  rep(c("Non-transportation", "Transportation"), times = 10),
  c(rep("crudep", 12), rep("crudepmax", 4), rep("prodpmax", 4)),
  out_summary3$slope, out_summary3$intercept, elast.sim
))

rownames(elast.sim_out) <- c("Type", "Region", "Sector", "BaselineType", "Mean_Slope", "Mean_Intercept", seq(1, nrow(elast.sim), 1))


# Export simulated price elasticities for use in BenEStock into .csv
# write.csv(elast.sim_out[,c(1:4,7:10)], "../Output/sim_DDElasts_Out.csv")
```

```{r worldelasts, eval=TRUE, include = FALSE}
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities

#### SHORT-RUN PRICE ELASTICITIES
#################################
nyears <- 31 # 2010-2040

## based on regional-sectoral baselines
world_P_SR <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR[, i] <-
    worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] *
    (elast.sim[, "P_0_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "P_0_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_0_1_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] *
      (elast.sim[, "P_0_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_0_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_0_1_1_0_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)] *
      (elast.sim[, "P_1_0_0_1_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_0_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_0_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)] *
      (elast.sim[, "P_1_0_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_0_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_0_1_0_crudep"])
}

## based on sectoral baselines
world_P_SR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_crudep"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_crudep"])
}

## based on sectoral baselines and for crude price maximum
world_P_SR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_crudepmax"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "crudepmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_crudepmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_crudepmax"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "crudepmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_crudepmax"])
}

## based on sectoral baselines and for product price maximum
world_P_SR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_prodpmax"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "prodpmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_prodpmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_prodpmax"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "prodpmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_prodpmax"])
}

#### LONG-RUN PRICE ELASTICITIES
################################

## based on regional-sectoral baselines
world_P_LR <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR[, i] <-
    worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] *
    (elast.sim[, "P_0_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "P_0_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_0_1_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] *
      (elast.sim[, "P_0_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_0_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_0_1_1_0_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)] *
      (elast.sim[, "P_1_0_0_1_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_0_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_0_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)] *
      (elast.sim[, "P_1_0_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_0_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_0_1_0_crudep"])
}

## based on sectoral baselines
world_P_LR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_crudep"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_crudep"])
}

## based on sectoral baselines and for crude price maximum
world_P_LR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_crudepmax"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "crudepmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_crudepmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_crudepmax"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "crudepmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_crudepmax"])
}

## based on sectoral baselines and for product price maximum
world_P_LR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "P_1_1_0_1_prodpmax"] +
      out_summary3$slope[out_summary3$case2 == "P_1_1_0_1" & out_summary3$BaselineType == "prodpmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_0_1_prodpmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "P_1_1_1_0_prodpmax"] +
        out_summary3$slope[out_summary3$case2 == "P_1_1_1_0" & out_summary3$BaselineType == "prodpmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "P_1_1_1_0_prodpmax"])
}

#### SHORT-RUN INCOME ELASTICITIES
##################################

## based on regional-sectoral baselines
world_Y_SR <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_SR[, i] <-
    worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] *
    (elast.sim[, "Y_0_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "Y_0_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_0_1_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] *
      (elast.sim[, "Y_0_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_0_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_0_1_1_0_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)] *
      (elast.sim[, "Y_1_0_0_1_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_0_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_0_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)] *
      (elast.sim[, "Y_1_0_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_0_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_0_1_0_crudep"])
}

## based on sectoral baselines
world_Y_SR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_SR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_crudep"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_crudep"])
}

## based on sectoral baselines and for crude price maximum
world_Y_SR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_SR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_crudepmax"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "crudepmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_crudepmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_crudepmax"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "crudepmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_crudepmax"])
}

## based on sectoral baselines and for product price maximum
world_Y_SR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_SR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_prodpmax"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "prodpmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_prodpmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_prodpmax"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "prodpmax"] * out_summary2$SR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_prodpmax"])
}

#### LONG-RUN INCOME ELASTICITIES
##################################

## based on regional-sectoral baselines
world_Y_LR <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_LR[, i] <-
    worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] *
    (elast.sim[, "Y_0_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "Y_0_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_0_1_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] *
      (elast.sim[, "Y_0_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_0_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_0_1_1_0_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)] *
      (elast.sim[, "Y_1_0_0_1_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_0_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_0_0_1_crudep"]) +

    worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)] *
      (elast.sim[, "Y_1_0_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_0_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_0_1_0_crudep"])
}

## based on sectoral baselines
world_Y_LR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_LR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_crudep"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_crudep"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_crudep"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "crudep"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_crudep"])
}

## based on sectoral baselines and for crude price maximum
world_Y_LR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_LR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_crudepmax"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "crudepmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_crudepmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_crudepmax"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "crudepmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_crudepmax"])
}

## based on sectoral baselines and for product price maximum
world_Y_LR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_Y_LR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    (elast.sim[, "Y_1_1_0_1_prodpmax"] +
      out_summary3$slope[out_summary3$case2 == "Y_1_1_0_1" & out_summary3$BaselineType == "prodpmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_0_1_prodpmax"]) +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      (elast.sim[, "Y_1_1_1_0_prodpmax"] +
        out_summary3$slope[out_summary3$case2 == "Y_1_1_1_0" & out_summary3$BaselineType == "prodpmax"] * out_summary2$LR_mean.SPEEDYRS[out_summary2$full.label == "Y_1_1_1_0_prodpmax"])
}

#####

## Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
est.world_P_SR <- apply(world_P_SR, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_crudep <- apply(world_P_SR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_crudepmax <- apply(world_P_SR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_prodpmax <- apply(world_P_SR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_P_LR <- apply(world_P_LR, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_crudep <- apply(world_P_LR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_crudepmax <- apply(world_P_LR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_prodpmax <- apply(world_P_LR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_Y_SR <- apply(world_Y_SR, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_SR_crudep <- apply(world_Y_SR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_SR_crudepmax <- apply(world_Y_SR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_SR_prodpmax <- apply(world_Y_SR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_Y_LR <- apply(world_Y_LR, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_LR_crudep <- apply(world_Y_LR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_LR_crudepmax <- apply(world_Y_LR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_Y_LR_prodpmax <- apply(world_Y_LR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

## collect the results in a data frame for plotting in ggplot2
P_SR_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR[1, ], middle = est.world_P_SR[2, ], upper = est.world_P_SR[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "crudep_regions"
  )

P_SR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_crudep[1, ], middle = est.world_P_SR_crudep[2, ], upper = est.world_P_SR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "crudep"
  )

P_SR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_crudepmax[1, ], middle = est.world_P_SR_crudepmax[2, ], upper = est.world_P_SR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "crudepmax"
  )

P_SR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_prodpmax[1, ], middle = est.world_P_SR_prodpmax[2, ], upper = est.world_P_SR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "prodpmax"
  )

P_LR_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR[1, ], middle = est.world_P_LR[2, ], upper = est.world_P_LR[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "crudep_regions"
  )

P_LR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_crudep[1, ], middle = est.world_P_LR_crudep[2, ], upper = est.world_P_LR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "crudep"
  )

P_LR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_crudepmax[1, ], middle = est.world_P_LR_crudepmax[2, ], upper = est.world_P_LR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "crudepmax"
  )

P_LR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_prodpmax[1, ], middle = est.world_P_LR_prodpmax[2, ], upper = est.world_P_LR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "prodpmax"
  )

Y_SR_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_SR[1, ], middle = est.world_Y_SR[2, ], upper = est.world_Y_SR[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "crudep_regions"
  )

Y_SR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_SR_crudep[1, ], middle = est.world_Y_SR_crudep[2, ], upper = est.world_Y_SR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "crudep"
  )

Y_SR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_SR_crudepmax[1, ], middle = est.world_Y_SR_crudepmax[2, ], upper = est.world_Y_SR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "crudepmax"
  )

Y_SR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_SR_prodpmax[1, ], middle = est.world_Y_SR_prodpmax[2, ], upper = est.world_Y_SR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "prodpmax"
  )

Y_LR_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_LR[1, ], middle = est.world_Y_LR[2, ], upper = est.world_Y_LR[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudep_regions"
  )

Y_LR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_LR_crudep[1, ], middle = est.world_Y_LR_crudep[2, ], upper = est.world_Y_LR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudep"
  )

Y_LR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_LR_crudepmax[1, ], middle = est.world_Y_LR_crudepmax[2, ], upper = est.world_Y_LR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudepmax"
  )

Y_LR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_Y_LR_prodpmax[1, ], middle = est.world_Y_LR_prodpmax[2, ], upper = est.world_Y_LR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "prodpmax"
  )

all.worldelast.p <- rbind(P_SR_dat, P_LR_dat, P_SR_crudep_dat, P_LR_crudep_dat, P_SR_crudepmax_dat, P_LR_crudepmax_dat, P_SR_prodpmax_dat, P_LR_prodpmax_dat) %>%
  mutate_at(c("TypeLength", "BaselineType"), as.factor)

all.worldelast.p$TypeLength <- factor(all.worldelast.p$TypeLength, levels = c("Short-Run Price", "Long-Run Price"))

world.elast.p.plot <- ggplot(all.worldelast.p, aes(x = Year, y = middle, color = BaselineType)) +
  facet_wrap(~TypeLength) +
  geom_line(data = all.worldelast.p, color = "black") +
  geom_ribbon(data = all.worldelast.p, aes(ymin = lower, ymax = upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Year", title = "") +
  theme(axis.text.x = element_text(size = 12, angle = 90, hjust = 1), axis.text.y = element_text(size = 12), axis.title = element_text(size = 12)) +
  theme(plot.title = element_text(size = 16, face = "bold")) +
  # scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6))
world.elast.p.plot

all.worldelast.y <- rbind(Y_SR_dat, Y_LR_dat, Y_SR_crudep_dat, Y_LR_crudep_dat, Y_SR_crudepmax_dat, Y_LR_crudepmax_dat, Y_SR_prodpmax_dat, Y_LR_prodpmax_dat) %>%
  mutate_at(c("TypeLength", "BaselineType"), as.factor)

all.worldelast.y$TypeLength <- factor(all.worldelast.y$TypeLength, levels = c("Short-Run Income", "Long-Run Income"))


world.elast.y.plot <- ggplot(all.worldelast.y, aes(x = Year, y = middle, color = BaselineType)) +
  facet_wrap(~TypeLength) +
  geom_line(data = all.worldelast.y, color = "black") +
  geom_ribbon(data = all.worldelast.y, aes(ymin = lower, ymax = upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Year", title = "") +
  theme(axis.text.x = element_text(size = 12, angle = 90, hjust = 1), axis.text.y = element_text(size = 12), axis.title = element_text(size = 12)) +
  theme(plot.title = element_text(size = 16, face = "bold"))
# scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6))
world.elast.y.plot

# Combine price and income plots
require(gridExtra)
world.elast.plot <- grid.arrange(world.elast.p.plot, world.elast.y.plot, ncol = 2)
```

```{r IncomeEffects, eval = TRUE, include = FALSE}
# Incorporating income effects into the price elasticity estimate (using a GDP price elasticity of -2.325% , which is the average coming out of the ORNL GDP elasticity meta-analysis)
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities
GDPoilelast <- -0.02

## SHORT_RUN
world_P_SR_withY <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_withY[, i] <- world_P_SR[, i] + GDPoilelast * world_Y_SR[, i]
}

world_P_SR_withY_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_withY_crudep[, i] <- world_P_SR_crudep[, i] + GDPoilelast * world_Y_SR_crudep[, i]
}

world_P_SR_withY_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_withY_crudepmax[, i] <- world_P_SR_crudepmax[, i] + GDPoilelast * world_Y_SR_crudepmax[, i]
}

world_P_SR_withY_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_SR_withY_prodpmax[, i] <- world_P_SR_prodpmax[, i] + GDPoilelast * world_Y_SR_prodpmax[, i]
}

## LONG_RUN
world_P_LR_withY <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_withY[, i] <- world_P_LR[, i] + GDPoilelast * world_Y_LR[, i]
}

world_P_LR_withY_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_withY_crudep[, i] <- world_P_LR_crudep[, i] + GDPoilelast * world_Y_LR_crudep[, i]
}

world_P_LR_withY_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_withY_crudepmax[, i] <- world_P_LR_crudepmax[, i] + GDPoilelast * world_Y_LR_crudepmax[, i]
}

world_P_LR_withY_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_P_LR_withY_prodpmax[, i] <- world_P_LR_prodpmax[, i] + GDPoilelast * world_Y_LR_prodpmax[, i]
}


# Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
est.world_P_SR_withY <- apply(world_P_SR_withY, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_withY_crudep <- apply(world_P_SR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_withY_crudepmax <- apply(world_P_SR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_SR_withY_prodpmax <- apply(world_P_SR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_P_LR_withY <- apply(world_P_LR_withY, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_withY_crudep <- apply(world_P_LR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_withY_crudepmax <- apply(world_P_LR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_P_LR_withY_prodpmax <- apply(world_P_LR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))


# Collect the results in a data frame for plotting in ggplot2
P_SR_dat_withY <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_withY[1, ], middle = est.world_P_SR_withY[2, ], upper = est.world_P_SR_withY[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "CRUDE OIL_REGIONS"
  )

P_SR_dat_withY_crudep <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_withY_crudep[1, ], middle = est.world_P_SR_withY_crudep[2, ], upper = est.world_P_SR_withY_crudep[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "CRUDE\nOIL"
  )

P_SR_dat_withY_crudepmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_withY_crudepmax[1, ], middle = est.world_P_SR_withY_crudepmax[2, ], upper = est.world_P_SR_withY_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "CRUDE\nOIL\nPMAX"
  )

P_SR_dat_withY_prodpmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_SR_withY_prodpmax[1, ], middle = est.world_P_SR_withY_prodpmax[2, ], upper = est.world_P_SR_withY_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "PETROLEUM\nPRODUCTS\nPMAX"
  )

P_LR_dat_withY <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_withY[1, ], middle = est.world_P_LR_withY[2, ], upper = est.world_P_LR_withY[3, ]) %>%
  mutate(
    TypeLenTgh = "LONG RUN",
    BaselineType = "CRUDE OIL_REGIONS"
  )

P_LR_dat_withY_crudep <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_withY_crudep[1, ], middle = est.world_P_LR_withY_crudep[2, ], upper = est.world_P_LR_withY_crudep[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "CRUDE\nOIL"
  )

P_LR_dat_withY_crudepmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_withY_crudepmax[1, ], middle = est.world_P_LR_withY_crudepmax[2, ], upper = est.world_P_LR_withY_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "CRUDE\nOIL\nPMAX"
  )

P_LR_dat_withY_prodpmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_P_LR_withY_prodpmax[1, ], middle = est.world_P_LR_withY_prodpmax[2, ], upper = est.world_P_LR_withY_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "PETROLEUM\nPRODUCTS\nPMAX"
  )


# For final plot, I select only one year and leave out the baseline constructed out of regions
all.worldelast.p.withY <- rbind(P_SR_dat_withY_crudep, P_LR_dat_withY_crudep, P_SR_dat_withY_crudepmax, P_LR_dat_withY_crudepmax, P_SR_dat_withY_prodpmax, P_LR_dat_withY_prodpmax) %>%
  mutate(middle = round(middle, 3)) %>%
  filter(Year == "2017")

all.worldelast.p.withY$TypeLength <- factor(all.worldelast.p.withY$TypeLength, levels = c("SHORT RUN", "LONG RUN"))
all.worldelast.p.withY$BaselineType <- factor(all.worldelast.p.withY$BaselineType, levels = c("CRUDE\nOIL", "CRUDE\nOIL\nPMAX", "PETROLEUM\nPRODUCTS\nPMAX"))


world.elast.p.plot.withY <- ggplot(all.worldelast.p.withY, aes(x = BaselineType, y = middle)) +
  facet_wrap(~TypeLength) +
  geom_point(data = all.worldelast.p.withY, aes(x = BaselineType, y = middle), color = "black") +
  geom_errorbar(aes(ymin = lower, ymax = upper)) +
  geom_text(aes(label = middle), hjust = 1, vjust = 0.5, size = 3.5, angle = 0, show.legend = FALSE) +
  # geom_ribbon(data=all.worldelast.p.withY, aes(ymin=lower, ymax=upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Price Baseline Details", title = "") +
  theme(axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 10, face = "bold")) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))

world.elast.p.plot.withY
```

We construct world price and income elasticities as weighted averages of the baseline elasticities of the transportation and non-transportation sectors. The weights are based on crude oil consumption projections for the year 2017 from EIA's International Energy Outlook 2013 (56% transportation and 44% non-transportation). As additional step, we adjust the resulting short and long-run world crude oil demand price elasticities to include changes in income as an indirect mechanism by which demand responds to price shocks according to the formula $\epsilon_{D,P}^*=\epsilon_{D,P} + \epsilon_{D,Y}*\epsilon_{GDP,P}$ where $\epsilon_{A,B}$ is the elasticity of $A$ with respect to $B$, $D$ is demand, $P$ is price, $Y$ is income, and $GDP$ is gross domestic product.^[Combining the direct and indirect effect (via income) of an oil price increase on demand is common when crude oil demand elasticity is used to assess the costs of oil supply shocks (e.g., Brown and Huntington, 2013) because those events have a well-documented macroeconomic impact. For different applications of the elasticity parameter, this adjustment might not be appropriate.] Using a value of -0.02 for the elasticity of GDP with respect to oil price $\epsilon_{GDP,P}$ (DOE, 2016), this second-order effect does not increase the price elasticity value significantly. The mean and 68% confidence interval for the resulting world oil crude demand price elasticities, based on results from 20,000 random draws from normal distributions truncated at mean +/- one standard deviation for each of the 8 type-sector baselines, are shown in Figure 4. All the elasticities in Figure 4 are evaluated at the average length of run of the elasticity data points included in the metaregression analysis. The average length of run is 0.9 and 11.3 years for the short-run and long-run elasticities respectively.  


```{r worldelasts2, eval=TRUE, include = FALSE}
# Produce another version of the plot based directly on the elasticity baselines and their standard errors (rather than the standard errors of the intercept term only)

## Focus on sectoral baselines only
out_summaryb <- out_summary1 %>%
  filter(case2 %in% c("P_1_1_0_1", "P_1_1_1_0", "Y_1_1_0_1", "Y_1_1_1_0")) %>%
  mutate(caserun = paste(case2, run, BaselineType, sep = "_"))

# Simulate confidence intervals for all the baseline world oil elasticities
baseline <- list()
sterror <- list()

for (i in 1:nrow(out_summaryb)) {
  baseline[i] <- out_summaryb$baseline[i]
  sterror[i] <- out_summaryb$sterror.baseline[i]
}

# Set seed and draw 20000 points out of each of the baseline elasticities
set.seed(14)

elast.simb <- matrix(c(0), ndraws, nrow(out_summaryb))
colnames(elast.simb) <- out_summaryb$caserun

for (i in 1:length(baseline)) {
  # truncated normal distribution
  elast.simb[, i] <- rtruncnorm(ndraws, a = as.numeric(baseline[i]) - 1 * as.numeric(sterror[i]), b = as.numeric(baseline[i]) + 1 * as.numeric(sterror[i]), mean = as.numeric(baseline[i]), sd = as.numeric(sterror[i]))
}

# For each draw, compute weighted averages to obtain the predicted baseline world elasticities

#### SHORT-RUN PRICE ELASTICITIES
#################################

## based on sectoral baselines
world_PSR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_SR_crudep"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_SR_crudep"]
}

## based on sectoral baselines and for crude price maximum
world_PSR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_SR_crudepmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_SR_crudepmax"]
}

## based on sectoral baselines and for product price maximum
world_PSR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_SR_prodpmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_SR_prodpmax"]
}

#### LONG-RUN PRICE ELASTICITIES
################################

## based on sectoral baselines
world_PLR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_LR_crudep"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_LR_crudep"]
}

## based on sectoral baselines and for crude price maximum
world_PLR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_LR_crudepmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_LR_crudepmax"]
}

## based on sectoral baselines and for product price maximum
world_PLR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "P_1_1_0_1_LR_prodpmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "P_1_1_1_0_LR_prodpmax"]
}

#### SHORT-RUN INCOME ELASTICITIES
##################################

## based on sectoral baselines
world_YSR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YSR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_SR_crudep"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_SR_crudep"]
}

## based on sectoral baselines and for crude price maximum
world_YSR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YSR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_SR_crudepmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_SR_crudepmax"]
}

## based on sectoral baselines and for product price maximum
world_YSR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YSR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_SR_prodpmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_SR_prodpmax"]
}

#### LONG-RUN INCOME ELASTICITIES
##################################

## based on sectoral baselines
world_YLR_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YLR_crudep[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_LR_crudep"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_LR_crudep"]
}

## based on sectoral baselines and for crude price maximum
world_YLR_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YLR_crudepmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_LR_crudepmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_LR_crudepmax"]
}

## based on sectoral baselines and for product price maximum
world_YLR_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_YLR_prodpmax[, i] <-
    (worldelastw[worldelastw$RegSect == "non_OECD_Non-transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Non-transportation", c(i + 2)]) *
    elast.simb[, "Y_1_1_0_1_LR_prodpmax"] +
    (worldelastw[worldelastw$RegSect == "non_OECD_Transportation", c(i + 2)] +
      worldelastw[worldelastw$RegSect == "OECD_Transportation", c(i + 2)]) *
      elast.simb[, "Y_1_1_1_0_LR_prodpmax"]
}

#####

## Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
est.world_PSR_crudep <- apply(world_PSR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_PSR_crudepmax <- apply(world_PSR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_PSR_prodpmax <- apply(world_PSR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_PLR_crudep <- apply(world_PLR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_PLR_crudepmax <- apply(world_PLR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_PLR_prodpmax <- apply(world_PLR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_YSR_crudep <- apply(world_YSR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_YSR_crudepmax <- apply(world_YSR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_YSR_prodpmax <- apply(world_YSR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_YLR_crudep <- apply(world_YLR_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_YLR_crudepmax <- apply(world_YLR_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_YLR_prodpmax <- apply(world_YLR_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

## collect the results in a data frame for plotting in ggplot2
PSR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_crudep[1, ], middle = est.world_PSR_crudep[2, ], upper = est.world_PSR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "crudep"
  )

PSR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_crudepmax[1, ], middle = est.world_PSR_crudepmax[2, ], upper = est.world_PSR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "crudepmax"
  )

PSR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_prodpmax[1, ], middle = est.world_PSR_prodpmax[2, ], upper = est.world_PSR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Price",
    BaselineType = "prodpmax"
  )

PLR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_crudep[1, ], middle = est.world_PLR_crudep[2, ], upper = est.world_PLR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "crudep"
  )

PLR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_crudepmax[1, ], middle = est.world_PLR_crudepmax[2, ], upper = est.world_PLR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "crudepmax"
  )

PLR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_prodpmax[1, ], middle = est.world_PLR_prodpmax[2, ], upper = est.world_PLR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Price",
    BaselineType = "prodpmax"
  )

YSR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YSR_crudep[1, ], middle = est.world_YSR_crudep[2, ], upper = est.world_YSR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "crudep"
  )

YSR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YSR_crudepmax[1, ], middle = est.world_YSR_crudepmax[2, ], upper = est.world_YSR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "crudepmax"
  )

YSR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YSR_prodpmax[1, ], middle = est.world_YSR_prodpmax[2, ], upper = est.world_YSR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Short-Run Income",
    BaselineType = "prodpmax"
  )

YLR_crudep_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YLR_crudep[1, ], middle = est.world_YLR_crudep[2, ], upper = est.world_YLR_crudep[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudep"
  )

YLR_crudepmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YLR_crudepmax[1, ], middle = est.world_YLR_crudepmax[2, ], upper = est.world_YLR_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudepmax"
  )

YLR_prodpmax_dat <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_YLR_prodpmax[1, ], middle = est.world_YLR_prodpmax[2, ], upper = est.world_YLR_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "Long-Run Income",
    BaselineType = "crudepmax"
  )

worldelast.p <- rbind(PSR_crudep_dat, PLR_crudep_dat, PSR_crudepmax_dat, PLR_crudepmax_dat, PSR_prodpmax_dat, PLR_prodpmax_dat) %>%
  mutate_at(c("TypeLength", "BaselineType"), as.factor)

worldelast.p$TypeLength <- factor(worldelast.p$TypeLength, levels = c("Short-Run Price", "Long-Run Price"))


world.elastp.plot <- ggplot(worldelast.p, aes(x = Year, y = middle, color = BaselineType)) +
  facet_wrap(~TypeLength) +
  geom_line(data = worldelast.p, color = "black") +
  geom_ribbon(data = worldelast.p, aes(ymin = lower, ymax = upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Year", title = "") +
  theme(axis.text.x = element_text(size = 12, angle = 90, hjust = 1), axis.text.y = element_text(size = 12), axis.title = element_text(size = 12)) +
  theme(plot.title = element_text(size = 16, face = "bold")) +
  # scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
  # ylim(-0.20, 0)+
  scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6))
world.elastp.plot

worldelast.y <- rbind(YSR_crudep_dat, YLR_crudep_dat, YSR_crudepmax_dat, YLR_crudepmax_dat, YSR_prodpmax_dat, YLR_prodpmax_dat) %>%
  mutate_at(c("TypeLength", "BaselineType"), as.factor)

worldelast.y$TypeLength <- factor(worldelast.y$TypeLength, levels = c("Short-Run Income", "Long-Run Income"))


world.elasty.plot <- ggplot(worldelast.y, aes(x = Year, y = middle, color = BaselineType)) +
  facet_wrap(~TypeLength) +
  geom_line(data = worldelast.y, color = "black") +
  geom_ribbon(data = worldelast.y, aes(ymin = lower, ymax = upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Year", title = "") +
  theme(axis.text.x = element_text(size = 12, angle = 90, hjust = 1), axis.text.y = element_text(size = 12), axis.title = element_text(size = 12)) +
  theme(plot.title = element_text(size = 16, face = "bold"))
# scale_y_continuous(limits = c(-2, 2), breaks = pretty_breaks(n = 12)) +
scale_x_continuous(limits = c(2010, 2040), breaks = pretty_breaks(n = 6))
world.elasty.plot

# Combine price and income plots
require(gridExtra)
worldelast.plot <- grid.arrange(world.elastp.plot, world.elasty.plot, ncol = 2)

# Incorporating income effects into the price elasticity estimate (using a GDP price elasticity of -2.325% , which is the average coming out of the ORNL GDP elasticity meta-analysis. I put it together based on Dave's email from 2014/10/22)
# For each draw, compute weighted averages to obtain the predicted baseline world elasticities
GDPoilelast <- -0.02

## SHORT_RUN
world_PSR_withY_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_withY_crudep[, i] <- world_PSR_crudep[, i] + GDPoilelast * world_YSR_crudep[, i]
}

world_PSR_withY_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_withY_crudepmax[, i] <- world_PSR_crudepmax[, i] + GDPoilelast * world_YSR_crudepmax[, i]
}

world_PSR_withY_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PSR_withY_prodpmax[, i] <- world_PSR_prodpmax[, i] + GDPoilelast * world_YSR_prodpmax[, i]
}

## LONG_RUN
world_PLR_withY_crudep <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_withY_crudep[, i] <- world_PLR_crudep[, i] + GDPoilelast * world_YLR_crudep[, i]
}

world_PLR_withY_crudepmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_withY_crudepmax[, i] <- world_PLR_crudepmax[, i] + GDPoilelast * world_YLR_crudepmax[, i]
}

world_PLR_withY_prodpmax <- matrix(c(0), ndraws, nyears)
for (i in 1:nyears) {
  world_PLR_withY_prodpmax[, i] <- world_PLR_prodpmax[, i] + GDPoilelast * world_YLR_prodpmax[, i]
}



# Compute the 0%, 50% and 100% quantiles to be plotted for each of the baseline elasticities
est.world_PSR_withY_crudep <- apply(world_PSR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_PSR_withY_crudepmax <- apply(world_PSR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_PSR_withY_prodpmax <- apply(world_PSR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))

est.world_PLR_withY_crudep <- apply(world_PLR_withY_crudep, 2, quantile, probs = c(0, 0.5, 1))
est.world_PLR_withY_crudepmax <- apply(world_PLR_withY_crudepmax, 2, quantile, probs = c(0, 0.5, 1))
est.world_PLR_withY_prodpmax <- apply(world_PLR_withY_prodpmax, 2, quantile, probs = c(0, 0.5, 1))


# Collect the results in a data frame for plotting in ggplot2

PSR_dat_withY_crudep <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_withY_crudep[1, ], middle = est.world_PSR_withY_crudep[2, ], upper = est.world_PSR_withY_crudep[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "CRUDE\nOIL"
  )

PSR_dat_withY_crudepmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_withY_crudepmax[1, ], middle = est.world_PSR_withY_crudepmax[2, ], upper = est.world_PSR_withY_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "CRUDE\nOIL\nPMAX"
  )

PSR_dat_withY_prodpmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PSR_withY_prodpmax[1, ], middle = est.world_PSR_withY_prodpmax[2, ], upper = est.world_PSR_withY_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "SHORT RUN",
    BaselineType = "PETROLEUM\nPRODUCTS\nPMAX"
  )

PLR_dat_withY_crudep <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_withY_crudep[1, ], middle = est.world_PLR_withY_crudep[2, ], upper = est.world_PLR_withY_crudep[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "CRUDE\nOIL"
  )

PLR_dat_withY_crudepmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_withY_crudepmax[1, ], middle = est.world_PLR_withY_crudepmax[2, ], upper = est.world_PLR_withY_crudepmax[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "CRUDE\nOIL\nPMAX"
  )

PLR_dat_withY_prodpmax <- data.frame(Year = seq(2010, 2040, 1), lower = est.world_PLR_withY_prodpmax[1, ], middle = est.world_PLR_withY_prodpmax[2, ], upper = est.world_PLR_withY_prodpmax[3, ]) %>%
  mutate(
    TypeLength = "LONG RUN",
    BaselineType = "PETROLEUM\nPRODUCTS\nPMAX"
  )

# For final plot, I select only one year and leave out the baseline constructed out of regions# For each draw, compute weighted averages to obtain the predicted baseline world elasticities
worldelast.p.withY <- rbind(
  PSR_dat_withY_crudep, PSR_dat_withY_crudepmax, PSR_dat_withY_prodpmax,
  PLR_dat_withY_crudep, PLR_dat_withY_crudepmax, PLR_dat_withY_prodpmax
)

worldelast.p.withY$TypeLength <- factor(worldelast.p.withY$TypeLength, levels = c("SHORT RUN", "LONG RUN"))

TypeLength <- c("SHORT RUN", "LONG RUN")
TypeLength2 <- c("SHORT RUN (~1 YEAR)", "LONG RUN (~10 YEARS)")
TypeLengthmatch <- data.frame(TypeLength, TypeLength2)

worldelast.p.withY <- left_join(worldelast.p.withY, TypeLengthmatch, by = "TypeLength") %>%
  mutate(middle = round(middle, 3)) %>%
  filter(Year == "2017")

worldelast.p.withY$BaselineType <- factor(worldelast.p.withY$BaselineType, levels = c("CRUDE\nOIL", "CRUDE\nOIL\nPMAX", "PETROLEUM\nPRODUCTS\nPMAX"))
worldelast.p.withY$TypeLength2 <- factor(worldelast.p.withY$TypeLength2, levels = c("SHORT RUN (~1 YEAR)", "LONG RUN (~10 YEARS)"))


world.elastp.plot.withY <- ggplot(worldelast.p.withY, aes(x = BaselineType, y = middle)) +
  facet_wrap(~TypeLength) +
  geom_point(data = worldelast.p.withY, aes(x = BaselineType, y = middle), color = "black") +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.3) +
  geom_text(aes(label = middle), hjust = -0.2, vjust = 0.5, size = 3.2, angle = 0, show.legend = FALSE) +
  # geom_ribbon(data=all.worldelast.p.withY, aes(ymin=lower, ymax=upper), alpha = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Elasticity", x = "Price Baseline Details", title = "") +
  theme(axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 10, face = "bold")) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
world.elastp.plot.withY
ggsave("../Output/world.elastp.plot.withY.png", width = 6.5, height = 4.5, units = "in", dpi = 600)
```

```{r outworldelastplot, fig.width=6.5, fig.height=4, echo = FALSE}
all.worldelast.p.withY.2017 <- all.worldelast.p.withY[all.worldelast.p.withY$Year == "2017", ]
# kable(all.worldelast.p.withY.2017, digits = 3, caption="Estimated World Oil Demand Elasticities")

world.elastp.plot.withY
```

**Figure 4. Estimated short-run and long-run world crude oil demand elasticities with respect to price (including income effect)**


```{r WorldElast.compare, eval = TRUE, include=FALSE, echo=FALSE}
# Select papers that provide world elasticity of oil demand
## Note: Burke & Nishitateno is removed because it computes world elasticities only for the transportation sector.
world.elasts <- filter(allelast.excluded, REG == "World" & REFERENCE != "BurkeNishitateno2013") %>%
  select(REFERENCE, BETA, ST_ERROR, TYPE, TYPE_LENGTH2, AVGYR, NOTES1) %>%
  # Add column to distinguish which elasticities are elasticities in production (as defined by Killian and Murphy)
  mutate(elast.in.prod = ifelse(NOTES1 == "elasticity in use", "elasticity in use", "elasticity in production")) %>%
  select(-NOTES1)

# For the purposes of this qualitative comparison, recover observations that were dropped because they were long-run elasticities for which the length of run could not be determined.
world.elasts.NAspeed <- allelast.NAspeed %>%
  filter(REGION == "World") %>%
  select(REFERENCE, BETA, ST_ERROR, VAR_SYMBOL, YEAR_START, YEAR_END) %>%
  mutate(
    TYPE = as.factor(substr(VAR_SYMBOL, 1, 1)),
    LENGTH = as.factor(ifelse(VAR_SYMBOL %in% c("P", "Y"), "LR", "SR")),
    TYPE_LENGTH2 = as.factor(paste(TYPE, LENGTH, sep = "_")),
    AVGYR = (YEAR_END + YEAR_START) / 2,
    elast.in.prod = "elasticity in production"
  ) %>%
  ungroup() %>%
  select(REFERENCE, BETA, ST_ERROR, TYPE, TYPE_LENGTH2, AVGYR, elast.in.prod)

world.elasts.all <- rbind(world.elasts, world.elasts.NAspeed)


# Add rows to include the elasticitiy values (mean and standard error) from the ORNL meta-analysis
# Note: These are all elasticities with respect to crude oil price so I will not include the baseline depicting elasticity with respect to product prices
ornl.elasts <- as.data.frame(matrix(0, ncol = 7, nrow = 2))
colnames(ornl.elasts) <- c("REFERENCE", "BETA", "ST_ERROR", "TYPE", "TYPE_LENGTH2", "AVGYR", "elast.in.prod")
ornl.elasts$REFERENCE <- c("metaregression", "metaregression")
ornl.elasts$BETA[1] <- worldelast.p.withY$middle[worldelast.p.withY$Year == "2017" & worldelast.p.withY$TypeLength == "SHORT RUN" & worldelast.p.withY$BaselineType == "CRUDE\nOIL"]
ornl.elasts$BETA[2] <- worldelast.p.withY$middle[worldelast.p.withY$Year == "2017" & worldelast.p.withY$TypeLength == "SHORT RUN" & worldelast.p.withY$BaselineType == "CRUDE\nOIL\nPMAX"]

ornl.elasts$ST_ERROR[1] <- ornl.elasts$BETA[1] - worldelast.p.withY$lower[worldelast.p.withY$Year == "2017" & worldelast.p.withY$TypeLength == "SHORT RUN" & worldelast.p.withY$BaselineType == "CRUDE\nOIL"]
ornl.elasts$ST_ERROR[2] <- ornl.elasts$BETA[1] - worldelast.p.withY$lower[worldelast.p.withY$Year == "2017" & worldelast.p.withY$TypeLength == "SHORT RUN" & worldelast.p.withY$BaselineType == "CRUDE\nOIL\nPMAX"]

ornl.elasts$TYPE <- c("P", "P")
ornl.elasts$TYPE_LENGTH2 <- c("P_SR", "P_SR")

ornl.elasts$REFERENCE <- as.factor(ornl.elasts$REFERENCE)
ornl.elasts$TYPE <- as.factor(ornl.elasts$TYPE)
ornl.elasts$TYPE_LENGTH2 <- as.factor(ornl.elasts$TYPE_LENGTH2)

ornl.elasts$AVGYR <- mean(allelast$AVGYR[allelast$ELASTICITY == "1" & allelast$TYPE_LENGTH2 == "P_SR"])

ornl.elasts$elast.in.prod <- c("elasticity in use", "elasticity in use")

world.elasts.with.ORNLmetareg <- rbind(world.elasts.all, ornl.elasts) %>%
  mutate(
    elast.in.prod = as.factor(elast.in.prod),
    TYPE_LENGTH3 = ifelse(TYPE_LENGTH2 == "P_SR", "Short-Run", "Long-Run")
  )

world.elasts.with.ORNLmetareg$TYPE_LENGTH3 <- factor(world.elasts.with.ORNLmetareg$TYPE_LENGTH3, levels = c("Short-Run", "Long-Run"))

world.elast.compare.plot <- ggplot(world.elasts.with.ORNLmetareg[world.elasts.with.ORNLmetareg$TYPE_LENGTH2 == "P_SR", ], aes(x = AVGYR, y = BETA, shape = elast.in.prod)) +
  geom_point(aes(x = AVGYR, y = BETA), size = 2) +
  geom_errorbar(aes(ymin = BETA - ST_ERROR, ymax = BETA + ST_ERROR, color = REFERENCE), width = .2) +
  # facet_wrap(~TYPE_LENGTH3, ncol = 1) +
  scale_color_manual(values = c("red", "green3", "cyan", "magenta", "orange", "pink", "black", "grey")) +
  scale_shape_manual(values = c(1, 2)) +
  scale_x_continuous(limits = c(1974, 2010), breaks = pretty_breaks(n = 10)) +
  scale_y_continuous(breaks = pretty_breaks(n = 10)) +
  labs(x = "Average Year", y = "Elasticity", title = "", color = "Reference", shape = "Elasticity Type") +
  theme(strip.text.x = element_text(size = 10)) +
  theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5)) +
  theme(axis.text.x = element_text(size = 10, angle = 0, hjust = 0.5), axis.text.y = element_text(size = 10), axis.title = element_text(size = 11, face = "bold")) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 10, face = "bold"), legend.key = element_blank(), legend.position = "right") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "grey"), panel.border = element_rect(colour = "grey", fill = NA, size = 1))
world.elast.compare.plot
ggsave("../Output/world.elast.compare.plot.png", width = 6.5, height = 4.5, units = "in", dpi = 600)
```

4.2. Comparison to other world elasticity estimates
===================================================

Figure 5 places the world oil demand elasticities (with respect to crude oil price or a new crude oil price maximum) from the metaregression in the context of other world oil demand elasticity estimates in the literature and highlights attributes that can help understanding and, to some extent, reconciling the large differences in value. 

```{r out_elastcompare, echo = FALSE, warning = FALSE}
world.elast.compare.plot
```

**Figure 5. Short-run price elasticities of world crude oil demand (metaregression vs. other published results)**


First, except for IMF (2011), all other primary studies in Figure 5 estimate systems of equations: simultaneous equations (Krichene, 2002; Askari and Krichene, 2010), structural VARs (Baumeister and Peersman, 2013; Kilian and Murphy, 2014) or a dynamic stochastic general equilibrium model (Bodenstein and Guerrieri, 2011). In all those systems, the quantity variable refers to crude oil production data and changes in consumption are assumed to be equal to changes in crude oil output. The resulting demand elasticities with respect to price can be referred to as “elasticities-in-production”—terminology introduced in Kilian and Murphy (2014)—and they tend to overstate demand responsiveness because they do not take into account the smoothing role of inventories. Kilian and Murphy (2014) address this shortcoming by also computing a substantially smaller “elasticity-in-use” (-0.26 for the “elasticity-in-use” versus -0.44 for the “elasticity-in-production”).^[Krichene (2002) and Askari and Krichene (2010) are exceptions to the otherwise larger “elasticities-in-production” summarized in Figure 5. However, their authors acknowledge the limitations of their two-stage least squares approach which takes GDP, natural gas prices, and exchange rates as exogenous. These estimates might be downward-biased due to endogeneity bias.] In contrast, the majority of studies included in the metaregressions discussed in the previous section (as well as IMF(2011)) estimate reduced form equations with crude oil consumption data as the dependent variable.  

Second, studies that consider the possibility of time-varying elasticities find crude oil demand elasticity to be declining over time (e.g., Baumeister and Peersman, 2013; Askari and Krichene, 2010). The crude oil market has experienced structural changes since the 1970s that have reduced crude oil demand responsiveness: the advent of liquid spot and future markets where participants can hedge their physical positions (Baumeister & Peersman, 2013); the reduced ability of the OECD non-transportation sector to substitute or reduce crude oil consumption after having taken advantage of “low hanging fruit” adjustments in the wake of the crude oil crises of the 1970s (Dargay and Gately, 2010); a given reduction in miles traveled provides progressively smaller fuel savings as vehicle fuel efficiency improves (Hughes et al., 2008). Thus, papers that compute a single elasticity over the long time period including the 1970s and early 1980s will likely obtain a larger elasticity than those starting later or allowing elasticity to vary over time.  

Third, crude oil demand elasticities recovered from SVAR impulse response functions represent responses to shocks and those shocks are normalized to always result in a crude oil price increase. In contrast, elasticities estimated using reduced form equations typically correspond to the average responsiveness over shocked and unshocked periods and various types of shocks implying crude oil price increases and decreases. The strong effect of the Pmax variable in the metaregressions is consistent with a larger responsiveness during that specific type of price increase. Relatedly, IMF (2011) finds world crude oil elasticity for the subset of observations in which price level was above the average price level (-0.038) to be double the average elasticity for the full price history (-0.019).  

Not all authors using SVARs agree on the magnitude of crude oil demand elasticities. Imposing bounds on the value of crude oil demand elasticity has become a common part of the strategy for identification of structural parameters in SVAR crude oil market models. As shown in Caldara et al. (2016), the two observed patterns of 1) larger volatility in crude oil prices than crude oil output and 2) near-zero covariance between reduced form residuals for global crude oil output and crude oil price are consistent with a wide range of choices for supply and demand elasticity bounds. With many feasible combinations, the choice of bounds must rely on external information which involves either a literature review or primary estimation. In some cases, the selected pair of bounds involves a very small supply elasticity (0.025) and larger demand elasticity (-0.8) (Killian and Murphy (2014); Baumeister and Peersman (2013)) and in other cases the bounds or, in Bayesian SVARs, priors are similar in absolute value for supply and demand (e.g., 0.10 and -0.10 respectively in Baumeister and Hamilton (2015) and Caldara et al. (2016)).^[The -0.8 bound on crude oil demand impulse elasticity is based on a single paper that estimates long-run price elasticity of gasoline for the United States using results from a household survey conducted in 1979 and 1988 (Hausman and Newey, 1995).] Results from our metaregression generally agree with a short-run world crude oil demand elasticity of approximately -0.1.


5. Conclusions
==============  

The aggregate response of global crude oil demand to a price or income change is the combination of responses from multiple regions and sectors. Building on that idea, we construct a world crude oil demand elasticity based on a meta-analysis of elasticities for individual regions and sectors/petroleum products obtained from 75 studies published from 2000 to 2015. We then compare the metaregression results to other estimates of the world crude oil demand elasticity in the literature.  

Global short-run elasticities with respect to crude oil price obtained from the metaregression are low (`r round(all_baselinesEstimated.2$bsl[all_baselinesEstimated.2$Grouping == "Price-SR-Transport"],3)` and `r round(all_baselinesEstimated.2$bsl[all_baselinesEstimated.2$Grouping == "Price-SR-NonTransport"],3)` for transportation and non-transportation sectors respectively). Estimated long-run elasticities reflecting decade-long adjustments are `r round(all_baselinesEstimated.2$bsl[all_baselinesEstimated.2$Grouping == "Price-LR-Transport"],3)` for the transportation sector and `r round(all_baselinesEstimated.2$bsl[all_baselinesEstimated.2$Grouping == "Price-LR-NonTransport"],3)` for other end uses. All estimated elasticities increase (in absolute value) when they convey response to a new price or income maximum and when they reflect response to end-use product prices rather than crude oil prices. The consumption-weighted average of elasticities from both sectors ranges, depending on details about the price baseline, from `r round(max(worldelast.p.withY$middle[worldelast.p.withY$TypeLength == "SHORT RUN"]),3)` to `r round(min(worldelast.p.withY$middle[worldelast.p.withY$TypeLength == "SHORT RUN"]),3)` in the short-run. The long-run range is wider (`r round(max(worldelast.p.withY$middle[worldelast.p.withY$TypeLength == "LONG RUN"]),3)`, `r round(min(worldelast.p.withY$middle[worldelast.p.withY$TypeLength == "LONG RUN"]),3)`).  

Results indicate a slightly decreasing trend in short-run transportation elasticity over time. The estimated coefficient on the trend variable for the other price-elasticities is consistent with them increasing over time but it is not statistically significant. For income elasticities, statistically significant trends only appear for the non-transportation sector and suggest that short-run income elasticity has been decreasing but long-run elasticity has been increasing. We find that countries with higher end-use price levels (inclusive of taxes) are more price elastic. The estimated relationship between income elasticities and a cross-section of income levels is weaker but consistent with higher-income countries being less income-elastic.  

No single study can produce an elasticity value well-suited for every empirical application. However, applied economists can benefit from systematic literature reviews and meta-analyses to select elasticity values useful to their specific research question. Attentiveness to key aspects of empirical application (e.g., duration of adjustment period being investigated, normal market conditions vs. disrupted market conditions) are important in selecting a value of crude oil demand elasticity. We illustrate these considerations by computing multiple elasticity baseline values.  

Even though there is an extensive body of literature on petroleum product demand elasticity estimation, it continues to be unbalanced toward study of transportation demand in high-income countries. In addition, changes in demand elasticity due to technological and policy changes are often observed in the literature with a considerable lag since most studies compute average elasticities over decades-long analysis periods. This is particularly the case for studies using time series data since they need to cover a longer time period than studies using data with a cross-sectional dimension to ensure sufficient degrees of freedom in the estimation. Thus, there continues to be room for new estimates to balance out the body of estimates from different regions and sectors and to capture evolution of elasticities over time.  

References
==========

Askari, H., & Krichene, N. (2010). An oil demand and supply model incorporating monetary policy. *Energy*, 35(5), 2013-2021.  

Balcombe, R., Mackett, R., Paulley, N., Preston, J., Shires, J., Titheridge, H., Wardman, M., & White, P. (2004). The demand for public transport: a practical guide. TRL Report TRL593.  

Banerjee, A., Dolado, J.J., Galbraith, J.W., & Hendry, D. (1993). Co-integration, error correction, and the econometric analysis of non-stationary data. Oxford University Press Catalogue.  

Basso, L. J., & Oum, T. H. (2007). Automobile fuel demand: a critical assessment of empirical methodologies. *Transport Reviews*, 27(4), 449-484. 

Baumeister, C., & Peersman, G. (2013). The role of time-varying price elasticities in accounting for volatility changes in the crude oil market. *Journal of Applied Econometrics*, 28(7), 1087-1109.  

Baumeister, C., & Hamilton, J. (2015). *Structural interpretation of vector autoregressions with incomplete identification: Revisiting the role of oil supply and demand shocks.* Manuscript, University of Notre Dame and UCSD.  

Bel, G., & Gradus, R. (2016). Effects of unit-based pricing on household waste collection demand: A meta-regression analysis. _Resource and Energy Economics_, 44, 169-182.  

Bodenstein, M., & Guerrieri, L. (2011). Oil efficiency, demand, and prices: a tale of ups and downs. Federal Reserve Board.  

Borenstein, M., Hedges, L. V., Higgins, J., & Rothstein, H. R. (2009). *Introduction to Meta-Analysis.* John Wiley & Sons, Ltd.  

Brons, M., Nijkamp, P., Pels, E., & Rietveld, P. (2008). A meta-analysis of the price elasticity of gasoline demand. A SUR approach. _Energy Economics_, 30(5), 2105-2122.  

Brown, S.P.A., & Huntington, H.G. (2013). Assessing the U.S. oil security premium. _Energy Economics_ 38: 118-127.  

Caldara, D., Cavallo, M., & Iacoviello, M. (2016). Oil Price Elasticities and Oil Price Fluctuations. Federal Reserve Board.  

Cameron, C.A., & Miller, D.L. (2015). A practitioner's guide to cluster-robust inference. *Journal of Human Resources* 50(2), 317-372.  

Daniel, V. E., Florax, R. J., & Rietveld, P. (2009). Flooding risk and housing values: An economic assessment of environmental hazard. _Ecological Economics_, 69(2), 355-365.  

Dargay, J.M., & Gately, D. (2010). World Oil Demand's Shift toward Faster Growing and Less Price-Responsive Products and Regions. *Energy Policy*, 38(10), 6261-6277.  

Dargay, J. M., Gately, D., & Huntington, H. G. (2007, August). Price and income responsiveness of world oil demand, by product. In Energy Modeling Forum Working Paper EMF OP (Vol. 61).  

Dees, S., Karadeloglou, P., Kaufmann, R. K., & S&#225;nchez, M. (2007). Modelling the world oil market: Assessment of a quarterly econometric model. *Energy Policy*, 35(1), 178-191.  

Espey, M. (1998). Gasoline demand revisited: an international meta-analysis of elasticities. *Energy Economics*, 20(3), 273-295.   

Hair, J. F. J., Anderson, R. E., Tatham, R. L., & Black, W. C. (1995). _Multivariate data analysis_. Saddle River. 3rd Edition. New York: McMillan.  

Hausman, J. A., & Newey, W. K. (1995). Nonparametric estimation of exact consumers surplus and deadweight loss. *Econometrica*, 63(6), 1445-1476.  

Havranek, T., Irsova, Z., & Janda, K. (2012). Demand for gasoline is more price-inelastic than commonly thought. *Energy Economics*, 34(1), 201-207.  

Havranek, T., & Kokes, O. (2015). "Income elasticity of gasoline demand: A meta-analysis." *Energy Economics* 47, 77-86.  

Hlavac, Marek (2015). stargazer: Well-Formatted Regression and Summary Statistics Tables. R package version 5.2. http://CRAN.R-project.org/package=stargazer  

Hughes, J. E., Knittel, C. R., & Sperling, D. (2008). Evidence of a Shift in the Short-Run Price Elasticity of Gasoline Demand. *The Energy Journal*, 29(1), 93-114.

International Monetary Fund (2011, April). Tensions from the two-speed recovery: unemployment, commodities, and capital flows. World Economic Outlook.    

Kilian, L., & Murphy, D. P. (2014). The role of inventories and speculative trading in the global market for crude oil. *Journal of Applied Econometrics*, 29(3), 454-478.  

Krichene, N. (2002). World crude oil and natural gas: a demand and supply model. *Energy Economics*, 24(6), 557-576.  

Labandeira, X., Labeaga, J.M, & L&#243;pez-Otero, X. (2017). A meta-analysis on the price elasticity of energy demand. *Energy Policy* 102, 549-568.  

Ma, C., Rogers, A. A., Kragt, M. E., Zhang, F., Polyakov, M., Gibson, F., Chalak, M., Pandit, R. & Tapsuwan, S. (2015). Consumers’ willingness to pay for renewable energy: A meta-regression analysis. _Resource and Energy Economics_, 42, 93-109.  

Menard, S. (1995). _Applied Logistic Regression Analysis_. Sage University Series on Quantitative Applications in the Social Sciences. Thousand Oaks, CA: Sage.  

Nelson, J. P. (2014). Estimating the price elasticity of beer: Meta-analysis of data with heterogeneity, dependence, and publication bias. *Journal of Health Economics*, 33, 180-187.  

Nelson, J. P., & Kennedy, P. E. (2009). The use (and abuse) of meta-analysis in environmental and natural resource economics: an assessment. *Environmental and resource economics*, 42(3), 345-377.  

Oladosu, G., Leiby, P.N., Bowman, D.C., Ur&#237;a-Mart&#237;nez, R., & Johnson, M. (2018). Impacts of oil price shocks on the U.S. economy: a meta-analysis of the oil price elasticity of GDP for net oil-importing economies. _Energy Policy_ 115, 523-544.  

Stanley, T.D., & Doucouliagos, C. (2007). Identifying and correcting publication selection bias in the efficiency-wage literature: Heckman meta-regression. Deakin University. School of Accounting, Economics and Finance. School Working Paper. Economics Series, 11, 2007.  

Stern, D. I. (2012). Interfuel Substitution: A Meta-Analysis. *Journal of Economic Surveys*, 26(2), 307-331.  

\pagebreak

APPENDIX: LIST OF REFERENCES USED IN META-ANALYSIS
==================================================

Alves, D. C., & da Silveira Bueno, R. D. L. (2003). Short-run, long-run and cross elasticities of gasoline demand in Brazil. *Energy Economics*, 25(2), 191-199.

Arzaghi, M., & Squalli, J. (2015). How price inelastic is demand for gasoline in fuel-subsidizing economies?. *Energy Economics*, 50, 117-124.

Bakhat, M., Labeaga, J. M., Labandeira, X., & L&#243;pez, X. (2012). Economic Crisis and Elasticities of Car Fuels: Evidence for Spain (Working Paper FA15-2012).

Baltagi, B. H., Bresson, G., Griffin, J. M., & Pirotte, A. (2003). Homogeneous, heterogeneous or shrinkage estimators? Some empirical evidence from French regional gasoline consumption. *Empirical Economics*, 28(4), 795-811.

Banaszak, S., Chakravorty, U., & Leung, P. (1999). Demand for ground transportation fuel and pricing policy in Asian tigers: a comparative study of Korea and Taiwan. *The Energy Journal*, 20(2), 145-165.

Baranzini, A., & Weber, S. (2013). Elasticities of gasoline demand in Switzerland. *Energy Policy*, 63, 674-680.

Barla, P., Gilbert-Gonthier, M., & Kuelah, J. R. T. (2014). The demand for road diesel in Canada. *Energy Economics*, 43, 316-322.

Belhaj, M. (2002). Vehicle and fuel demand in Morocco. *Energy Policy*, 30(13), 1163-1171.

Bhattacharyya, S. C., & Blake, A. (2009). Domestic demand for petroleum products in MENA countries. *Energy Policy*, 37(4), 1552-1560.

Blundell, R., Horowitz, J. L., & Parey, M. (2012). Measuring the price responsiveness of gasoline demand: Economic shape restrictions and nonparametric demand estimation. *Quantitative Economics*, 3(1), 29-51.

Boshoff, W. H. (2012). Gasoline, diesel fuel and jet fuel demand in South Africa. Studies in Economics and Econometrics, 36(1), 43-78.

Broadstock, D. C., & Hunt, L. C. (2010). Quantifying the impact of exogenous non-economic factors on UK transport oil demand. *Energy Policy*, 38(3), 1559-1565.

Chakravorty, U., Fesharaki, F., & Zhou, S. (2000). Domestic demand for petroleum in OPEC countries. *OPEC Review*, 24(1), 23-52.  

Chandrasiri, S. (2006). Demand for road-fuel in a small developing economy: The case of Sri Lanka. *Energy Policy*, 34(14), 1833-1840.

Chang, D., & Serletis, A. (2014). The demand for gasoline: evidence from household survey data. *Journal of Applied Econometrics*, 29(2), 291-313.

Cheung, K. Y., & Thomson, E. (2004). The demand for gasoline in China: a cointegration analysis. *Journal of Applied Statistics*, 31(5), 533-544.

Cho, W. G., Nam, K., & Pagan, J. A. (2004). Economic growth and interfactor/interfuel substitution in Korea. *Energy Economics*, 26(1), 31-50.

Christopoulos, D. K. (2000). The demand for energy in Greek manufacturing. *Energy Economics*, 22(5), 569-586.

Coyle, D., DeBacker, J., & Prisinzano, R. (2012). Estimating the supply and demand of gasoline using tax data. *Energy Economics*, 34(1), 195-200.

Dahl, C. (2001). Estimating oil product demand in Indonesia using a cointegrating error correction model. *OPEC Review*, 25(1), 1-25.

Danesin, A., & Linares, P. (2015). An Estimation of Fuel Demand Elasticities for Spain An Aggregated Panel Approach Accounting for Diesel Share. *Journal of Transport Economics and Policy*, 49(1), 1-16.

Dargay, J.M., & Gately, D. (2010). World Oil Demand's Shift toward Faster Growing and Less Price-Responsive Products and Regions. *Energy Policy*, 38(10), 6261-6277.  

Dargay, J. M., Gately, D., & Huntington, H. G. (2007, August). Price and income responsiveness of world oil demand, by product. In Energy Modeling Forum Working Paper EMF OP (Vol. 61).

Dees, S., Karadeloglou, P., Kaufmann, R. K., & Sanchez, M. (2007). Modelling the world oil market: Assessment of a quarterly econometric model. *Energy Policy*, 35(1), 178-191.

De Vita, G., Endresen, K., & Hunt, L. C. (2006). An empirical analysis of energy demand in Namibia. *Energy Policy*, 34(18), 3447-3463.

Eltony, M. N., & Al-Mutairi, N. H. (1995). Demand for gasoline in Kuwait: an empirical analysis using cointegration techniques. *Energy Economics*, 17(3), 249-253.

Frondel, M., Peters, J., & Vance, C. (2008). Identifying the Rebound: Evidence from a German Household Panel. *The Energy Journal*, 29(4), 145-163.

Gately, D., & Huntington, H. G. (2002). The asymmetric effects of changes in price and income on energy and oil demand. *The Energy Journal*, 23, 19-55.

Griffin, J. M., & Schulman, C. T. (2005). Price asymmetry in energy demand models: a proxy for energy-saving technical change?. *The Energy Journal*, 26, 1-21.

Hasanov, M. (2015). The demand for transport fuels in Turkey. *Energy Economics*, 51, 125-134.

Hausman, J. A., & Newey, W. K. (1995). Nonparametric estimation of exact consumers surplus and deadweight loss. *Econometrica*, 63(6), 1445-1476.

Hughes, J. E., Knittel, C. R., & Sperling, D. (2008). Evidence of a Shift in the Short-Run Price Elasticity of Gasoline Demand. *The Energy Journal*, 29(1), 93-114.

Hunt, L. C., & Ninomiya, Y. (2003). Unravelling trends and seasonality: a structural time series analysis of transport oil demand in the UK and Japan. *The Energy Journal*, 24(3), 63-96.

Huntington, H. G. (2011). Backcasting US oil demand over a turbulent decade. *Energy Policy*, 39(9), 5674-5680.

Huntington, H. G. (2010). Short-and long-run adjustments in US petroleum consumption. *Energy Economics*, 32(1), 63-72.

Ibrahim, I. B., & Hurst, C. (1990). Estimating energy and oil demand functions: A study of thirteen developing countries. *Energy Economics*, 12(2), 93-102.

International Monetary Fund (2011, April). Tensions from the two-speed recovery: unemployment, commodities, and capital flows. World Economic Outlook.  

Iootty, M., Pinto, H., & Ebeling, F. (2009). Automotive fuel consumption in Brazil: Applying static and dynamic systems of demand equations. *Energy Policy*, 37(12), 5326-5333.

Iwayemi, A., Adenikinju, A., & Babatunde, M. A. (2010). Estimating petroleum products demand elasticities in Nigeria: A multivariate cointegration approach. *Energy Economics*, 32(1), 73-85.

Kayser, H. A. (2000). Gasoline demand and car choice: estimating gasoline demand using household information. *Energy Economics*, 22(3), 331-348.

Li, Z., Rose, J. M., & Hensher, D. A. (2010). Forecasting automobile petrol demand in Australia: an evaluation of empirical models. *Transportation Research Part A: Policy and Practice*, 44(1), 16-38.

Lin, C. Y. C., & Prince, L. (2013). Gasoline price volatility and the elasticity of demand for gasoline. *Energy Economics*, 38, 111-117.

Lin, C. Y. C., & Zeng, J. J. (2013). The elasticity of demand for gasoline in China. *Energy Policy*, 59, 189-197.

Liu, W. (2014). Modeling gasoline demand in the United States: A flexible semiparametric approach. *Energy Economics*, 45, 244-253.

Liu, G. (2004). Estimating energy demand elasticities for OECD countries. A dynamic panel data approach. Statistics Norway, Research Department. Discussion Papers No. 373, March 2004.

Ma, H., Oxley, L., Gibson, J., & Kim, B. (2008). China's energy economy: Technical change, factor demand and interfactor/interfuel substitution. *Energy Economics*, 30(5), 2167-2183.

Mahmud, S. F. (2000). The energy demand in the manufacturing sector of Pakistan: some further results. *Energy Economics*, 22(6), 641-648.

Melo, P. C., & Ramli, A. R. (2014). Estimating fuel demand elasticities to evaluate CO 2 emissions: Panel data evidence for the Lisbon Metropolitan Area. *Transportation Research Part A: Policy and Practice*, 67, 30-46.

Nagata, Y. (2001). A Forecast of Energy Demand in Japan Considering Asymmetric Price Elasticities. *Energy Studies Review*, 10(1).

Nicol, C. J. (2003). Elasticities of demand for gasoline in Canada and the United States. *Energy Economics*, 25(2), 201-214.

Olivia, S., & Gibson, J. (2008). Household energy demand and the equity and efficiency aspects of subsidy reform in Indonesia. *The Energy Journal*, 29(1), 21-39.

Pock, M. (2007). Gasoline and diesel demand in Europe: new insights (No. 202). Reihe &#214;konomie/Economics Series, Institut f&#252;r H&#246;here Studien (IHS).

Polemis, M. L. (2006). Empirical assessment of the determinants of road energy demand in Greece. *Energy Economics*, 28(3), 385-403.

Ramanathan, R. (1999). Short-and long-run elasticities of gasoline demand in India: An empirical analysis using cointegration techniques. *Energy Economics*, 21(4), 321-330.

Rao, B. B., & Rao, G. (2009). Cointegration and the demand for gasoline. *Energy Policy*, 37(10), 3978-3983.

Reyes, O., Escalante, R., & Matas, A. (2010). La demanda de gasolinas en M&#233;xico: Efectos y alternativas ante el cambio clim&#225;tico. *Econom&#237;a: teor&#237;a y pr&#225;ctica*, (32), 83-111.

Ryan, D. L., & Plourde, A. (2002). Smaller and smaller? The price responsiveness of nontransport oil demand. *The Quarterly Review of Economics and Finance*, 42(2), 285-317.

Santos, G. F. (2013). Fuel demand in Brazil in a dynamic panel data approach. *Energy Economics*, 36, 229-240.

Schmalensee, R., & Stoker, T. M. (1999). Household gasoline demand in the United States. *Econometrica*, 67(3), 645-662.

Sene, S. O. (2012). Estimating the demand for gasoline in developing countries: Senegal. *Energy Economics*, 34(1), 189-194.

Sentenac-Chemin, E. (2012). Is the price effect on fuel consumption symmetric? Some evidence from an empirical study. *Energy Policy*, 41, 59-65.

Serletis, A., Timilsina, G. R., & Vasetsky, O. (2010). International evidence on sectoral interfuel substitution. *The Energy Journal*, 31, 1-29.

Serletis, A., & Shahmoradi, A. (2008). Semi-nonparametric estimates of interfuel substitution in US energy demand. *Energy Economics*, 30(5), 2123-2133.

Sillah, B. M., & Alsheikh, H. M. (2012). Income, price, and government expenditure elasticities of oil in the gulf cooperation council countries. *International Journal of Energy Economics and Policy*, 2(4), 333-341.

Small, K. A., & Van Dender, K. (2007). Fuel efficiency and motor vehicle travel: the declining rebound effect. *The Energy Journal*, 25-51.

Su, Q. (2011). The effect of population density, road network density, and congestion on household gasoline consumption in US urban areas. *Energy Economics*, 33(3), 445-452.

Urga, G., & Walters, C. (2003). Dynamic translog and linear logit models: a factor demand analysis of interfuel substitution in US industrial energy demand. *Energy Economics*, 25(1), 1-21.  

V&#225;squez-Cordano, A.L. (2005). La demanda agregada de combustibles l&#237;quidos en Per&#250;. Documento de Trabajo 12. Oficina de Estudios Econ&#243;micos, OSINERG.  

Wadud, Z., Graham, D. J., & Noland, R. B. (2010). Gasoline demand with heterogeneity in household responses. *The Energy Journal*, 31, 47-74.

West, S. E., & Williams, R. C. (2004). Estimates from a consumer demand system: implications for the incidence of environmental taxes. *Journal of Environmental Economics and Management*, 47(3), 535-558.  

Yatchew, A., & No, J. A. (2001). Household gasoline demand in Canada. *Econometrica*, 69(6), 1697-1709.

Ziramba, E. (2010). Price and income elasticities of crude oil import demand in South Africa: A cointegration analysis. *Energy Policy*, 38(12), 7844-7849.












